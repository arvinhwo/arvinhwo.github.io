<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>SV过程与子程序</title>
      <link href="/SV%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/"/>
      <url>/SV%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1>过程语句</h1><h2 id="概念"><a class="header-anchor" href="#概念">¶</a>概念</h2><ul><li><code>initial</code>语句<ul><li>用于初始化行为建模，仅在仿真开始时执行一次</li></ul></li><li><code>always</code>语句<ul><li>用于持续执行的行为建模，仿真过程中重复执行</li><li>需要明确列出敏感事件列表</li></ul></li><li>SV扩展了<code>always</code>块<ul><li><code>always_comb</code>：自动推断组合逻辑敏感列表，避免遗漏信号</li><li><code>always_ff</code>：明确用于时序逻辑，需指定时钟和复位条件</li><li><code>always_latch</code>：专为锁存器设计，明确设计意图，提高可维护性</li></ul></li></ul><h2 id="赋值规则"><a class="header-anchor" href="#赋值规则">¶</a>赋值规则</h2><ul><li>阻塞赋值<code>=</code><ul><li>按代码顺序立即执行，适用于组合逻辑建模</li><li>执行时后续语句需等待当前赋值完成</li></ul></li><li>非阻塞赋值<code>&lt;=</code><ul><li>赋值操作并行执行，适用于时序逻辑</li><li>在时钟边沿捕获当前值，结束后统一更新结果，避免竞争风险</li></ul></li><li>限制<ul><li>过程赋值的被赋值变量必须是寄存器类型（<code>reg</code>或<code>logic</code>），并且只能在过程块中使用</li><li>区别于连续赋值<code>assign</code>只能驱动线网类型</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> xor_comb(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> a, b,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        out = a ^ b;  <span class="comment">// 阻塞赋值，组合逻辑</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> d_latch(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> enable, d,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> q</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_latch</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (enable) <span class="keyword">begin</span></span><br><span class="line">            q = d;  <span class="comment">// 当enable为高时，q锁存d的值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> d_flipflop(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, d,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> q</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            q &lt;= <span class="number">0</span>;  <span class="comment">// 复位时q置0</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            q &lt;= d;  <span class="comment">// 时钟上升沿时q更新为d</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h1>子程序</h1><h2 id="任务与函数"><a class="header-anchor" href="#任务与函数">¶</a>任务与函数</h2><ul><li>任务用于封装可包含时序控制的行为代码块<ul><li>延时<code>#</code>、事件触发<code>@</code>、等待<code>wait</code></li></ul></li><li>无返回值，支持<code>input</code>、<code>output</code>、<code>inout</code>参数<ul><li>无输入输出时空括号可省略</li></ul></li><li><code>begin ... end</code>不再是必需的，但必须使用通用的输入类型<code>logic</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> send_data(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data, <span class="keyword">output</span> <span class="keyword">bit</span> ack);</span><br><span class="line">   #<span class="number">10</span>;          <span class="comment">// 延时10个时间单位</span></span><br><span class="line">   ack = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><ul><li>函数用于纯计算或组合逻辑，无任何时序控制，执行时间为0</li><li>必须至少有一个输入参数，通过函数名返回单一值</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add(<span class="keyword">input</span> <span class="keyword">int</span> a, b);</span><br><span class="line">   <span class="keyword">return</span> a + b;  <span class="comment">// 直接返回计算结果</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><h2 id="子程序参数"><a class="header-anchor" href="#子程序参数">¶</a>子程序参数</h2><h3 id="引用传参"><a class="header-anchor" href="#引用传参">¶</a>引用传参</h3><ul><li>在SV中，参数的传递除了可以使用<code>input</code>、<code>output</code>、<code>inout</code>进行复制外，还可以使用引用的方式传参</li><li>核心：使用<code>ref</code>实现对变量的直接引用（类似指针）<ul><li>避免大型数据（如结构体、数组）的复制开销，提升性能</li><li>子程序内部对ref参数的修改立即可见于外部调用者</li></ul></li><li>使用规则<ul><li>只使用于变量，不支持线网类型</li><li>多个并发子程序通过<code>ref</code>访问同一变量时，可能导致数据竞争<ul><li>为避免竞争，可以使用<a href="../SV%E7%BA%BF%E7%A8%8B%E4%B8%8E%E9%80%9A%E4%BF%A1">旗语或信箱</a>等方式进行同步或传递副本</li></ul></li><li>与<code>const</code>联合使用，声明可强制引用为只读，防止意外修改</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> print_sum(<span class="keyword">const</span> <span class="keyword">ref</span> <span class="keyword">int</span> arr[]);</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">foreach</span>(arr[i]) sum += arr[i];</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Sum: %0d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><h3 id="参数的缺省值"><a class="header-anchor" href="#参数的缺省值">¶</a>参数的缺省值</h3><ul><li>在声明函数时为部分或全部参数预设缺省值（默认值），当调用函数时，若未显示传入，则使用缺省值<ul><li>使用-1或其他任何越界值作为缺省值，便于获知调用时是否有指定值</li></ul></li><li>显示指定参数名<code>.parameter_name(value)</code><ul><li>使用名字进行传参，允许直接关联参数名与值，而不依赖参数在模块定义中的声明顺序</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">void</span> print_csm(<span class="keyword">const</span> <span class="keyword">ref</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] a[],</span><br><span class="line">                                  <span class="keyword">input</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] low = <span class="number">0</span>,</span><br><span class="line">                                  <span class="keyword">input</span> <span class="keyword">int</span> high = -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] checksum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (high == -<span class="number">1</span> || hign &gt;= a<span class="variable">.size</span>())</span><br><span class="line">        high = a<span class="variable">.size</span>()-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++)</span><br><span class="line">        checksum ^= a[i];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;The array checksum is %h&quot;</span>, checksum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">print_csm(a);        <span class="comment">//check a[0:size()-1]</span></span><br><span class="line">print_csm(a, <span class="number">2</span>, <span class="number">4</span>);  <span class="comment">//check a[2:4]</span></span><br><span class="line">print_csm(a, <span class="number">1</span>);     <span class="comment">//check a[1:size()-1]</span></span><br><span class="line">print_csm(a,, <span class="number">2</span>);    <span class="comment">//check a[0:2]</span></span><br><span class="line">print_csm();         <span class="comment">//编译错误，a无缺省值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示指定参数名，若low &gt; high or a.size()，for循环不执行 </span></span><br><span class="line">print_csm(a, <span class="variable">.c</span>(<span class="number">3</span>)); <span class="comment">//check a[3:size()-1]</span></span><br></pre></td></tr></table></figure><h2 id="子程序的返回"><a class="header-anchor" href="#子程序的返回">¶</a>子程序的返回</h2><h3 id="显式返回"><a class="header-anchor" href="#显式返回">¶</a>显式返回</h3><ul><li><code>void</code>函数无返回值，非<code>void</code>函数必须提供返回值<ul><li><code>return</code>关键词适用于单个返回值的函数</li><li>多返回值需用<code>output</code>或结构体</li></ul></li><li>在任何函数中，<code>return</code>语句都可用于发现错误提前终止退出<ul><li>SV支持<code>return</code>关键词灵活退出，而Verilog仅能在<code>endfunciton</code>处返回</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示返回</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">  <span class="keyword">return</span> a + b; <span class="comment">// 必须显式返回</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="comment">//提前退出</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> check(<span class="keyword">int</span> a);</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 提前退出</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Valid value&quot;</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><h3 id="隐式返回"><a class="header-anchor" href="#隐式返回">¶</a>隐式返回</h3><ul><li>当函数名被赋值时，函数名即返回变量，无需显示<code>return</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> array_t [<span class="number">5</span>];  <span class="comment">//自定义数组类型</span></span><br><span class="line">array_t at;</span><br><span class="line"><span class="keyword">function</span> array_t init(<span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (init[i])</span><br><span class="line">        init[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    at = init(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (at[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;at[%0d] = %0d&quot;</span>, i ,at[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="数组的返回"><a class="header-anchor" href="#数组的返回">¶</a>数组的返回</h3><ul><li>上述数组或结构体的返回除上面的例子外，还可以用引用参数实现</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">void</span> init (<span class="keyword">ref</span> <span class="keyword">int</span> f[<span class="number">5</span>], <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (f[i])</span><br><span class="line">        f[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    init(fa, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (fa[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;fa[%0d] = %0d&quot;</span>, i, fa[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>也可以将数组包装到一个<a href="../SV%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1">类</a>中，然后返回对象的句柄</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ArrayWrapper;</span><br><span class="line">  <span class="keyword">int</span> data[];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">input</span> <span class="keyword">int</span> size, <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    data = <span class="keyword">new</span>[size];</span><br><span class="line">    <span class="keyword">foreach</span>(data[i]) data[i] = i + start;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> ArrayWrapper create_wrapped_array(<span class="keyword">input</span> <span class="keyword">int</span> size, <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span>(size, start);  <span class="comment">// 返回新对象句柄</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  ArrayWrapper obj;</span><br><span class="line">  obj = create_wrapped_array(<span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 初始化数组 [3,4,5,6,7]</span></span><br><span class="line">  <span class="keyword">foreach</span>(obj<span class="variable">.data</span>[i]) </span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;obj.data[%0d] = %0d&quot;</span>, i, obj<span class="variable">.data</span>[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 芯片验证 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
            <tag> UVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SV数组队列</title>
      <link href="/SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97/"/>
      <url>/SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1>定宽数组</h1><ul><li>定宽数组（Fixed-Size Arrays）是SV中用于存储固定数量元素的静态数据结构</li><li>编译时确定大小，运行时不改变容量，在内存中连续存储，支持高效索引访问</li></ul><h2 id="特性与声明"><a class="header-anchor" href="#特性与声明">¶</a>特性与声明</h2><ul><li>基础格式：<code>&lt;数据类型&gt; &lt;数组名&gt;[&lt;维度1&gt;][&lt;维度2&gt;]...;</code><ul><li>紧凑声明：SV允许只声明数组宽带，使用0作为索引下界</li><li>格式化描述符：可使用<code>%p</code>打印数组、结构、类等</li><li>SV仿真器存放数组元素时使用字边界</li></ul></li></ul><p><img src="/images/image-20250715152350189.png" alt="image-20250715152350189"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array1[<span class="number">0</span>:<span class="number">7</span>];                <span class="comment">// 1x8，完整声明，索引下界0、上界7</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] arry2[<span class="number">0</span>:<span class="number">3</span>][<span class="number">0</span>:<span class="number">2</span>];   <span class="comment">// 4*3</span></span><br><span class="line"><span class="keyword">int</span> array1[<span class="number">8</span>];                  <span class="comment">// 紧凑声明</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] arry2[<span class="number">4</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li>常量数组初始化<ul><li>使用一个单引号加大括号来初始化数组，为部分或所有元素赋值</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b[<span class="number">4</span>] = &#x27;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">// 显式声明静态变量，并同时赋值</span></span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    a = &#x27;&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;                   <span class="comment">// 为全部元素赋值</span></span><br><span class="line">    a = &#x27;&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;                       <span class="comment">// 为前3个元素赋值</span></span><br><span class="line">    b = &#x27;&#123;<span class="number">4</span>&#123;<span class="number">8</span>&#125;&#125;;                        <span class="comment">// 全赋值8</span></span><br><span class="line">    b = &#x27;&#123;<span class="keyword">default</span>:<span class="number">42</span>&#125;;                  <span class="comment">// 全赋值42</span></span><br><span class="line">    c = &#x27;&#123;&#x27;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#x27;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;           <span class="comment">// 为全部元素赋值</span></span><br><span class="line">    c[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1</span>;                        <span class="comment">// 为最后一个元素赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="foreach循环"><a class="header-anchor" href="#foreach循环">¶</a>foreach循环</h2><ul><li>索引变量自动声明，只在循环内有效</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src[<span class="number">5</span>], dst[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> rev[<span class="number">6</span>:<span class="number">2</span>];                       <span class="comment">// 索引从6开始，递减索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="built_in">$size</span>(src); i++)</span><br><span class="line">        src[i] = i;</span><br><span class="line">    <span class="keyword">foreach</span> (dst[j])                    <span class="comment">// 等同于for(int j=0; j&lt;=4; j++)</span></span><br><span class="line">        dst[j] = src[j] * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (rev[k])                    <span class="comment">// 等同于for(int k=6; j&gt;=2; k--)</span></span><br><span class="line">        rev[k] = k;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>多维数组使用foreach，用逗号将下标隔开后放在同一个方括号中</li><li>若不需要遍历所有维度，可以在方括号中忽略掉它们</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> md[<span class="number">2</span>][<span class="number">3</span>] = &#x27;&#123;&#x27;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#x27;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (md[i,j])                               <span class="comment">// 遍历所有维度，i++(j++)</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;md[%d][%d] = %d&quot;</span>, i, j, md[i][j]);</span><br><span class="line">    <span class="keyword">foreach</span> (md[i]) <span class="keyword">begin</span>                           <span class="comment">// 分维度遍历，与上面等效</span></span><br><span class="line">        <span class="built_in">$write</span>(<span class="string">&quot;%2d:&quot;</span>, i);                          <span class="comment">// $write输出后不换行</span></span><br><span class="line">        <span class="keyword">foreach</span> (md[,j])</span><br><span class="line">        <span class="built_in">$write</span>(<span class="string">&quot;md[%d][%d] = %d&quot;</span>, i, j, md[i][j]);</span><br><span class="line">        <span class="built_in">$display</span>;                                   <span class="comment">// $display输出后换行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="比较和复制"><a class="header-anchor" href="#比较和复制">¶</a>比较和复制</h2><ul><li>可以不使用循环而对数组进行聚合比较和复制，聚合操作适用于整个数组而不是单个元素</li><li>对于数组的加、减法等算术运算不能使用聚合操作，应该使用foreach循环</li><li>对于异或等逻辑运算，应该使用循环或合并数组</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src[<span class="number">5</span>] = &#x27;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, dst[<span class="number">5</span>] = &#x27;&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;src %s dst&quot;</span>, (src == dst) ? <span class="string">&quot;==&quot;</span> : <span class="string">&quot;!=&quot;</span>);         <span class="comment">// 所有元素值是否相等</span></span><br><span class="line">    dst = src                                                   <span class="comment">// 复制src元素到dst</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;src[1:4] %s dst[1:4]&quot;</span>,</span><br><span class="line">             (src[<span class="number">1</span>:<span class="number">4</span>] == dst[<span class="number">1</span>:<span class="number">4</span>]) ? <span class="string">&quot;==&quot;</span> : <span class="string">&quot;!=&quot;</span>);             <span class="comment">// 比较第1~4个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时使用数组下标和位下标打印</span></span><br><span class="line">    <span class="built_in">$displayb</span>(<span class="string">&quot;dst[0][2:1]&quot;</span>);                                   <span class="comment">// &#x27;b10，dst[0]是4</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1>合并数组</h1><h2 id="特性与声明-v2"><a class="header-anchor" href="#特性与声明-v2">¶</a>特性与声明</h2><ul><li>合并数组是一种特殊的多维数组，其所有维度在内存中连续存储<ul><li>区别于普通向量，合并数组适合处理具有自然分层的结构（如网络包、图像数据）</li><li>区别于普通数组使用字边界的存放方式，使得合并数组支持直接的位级操作（如异或运算）</li></ul></li><li>声明合并数组时，数组大小和合并位宽必须在变量名前指定<ul><li>数组大小格式必须是<code>[msb:lsb]</code>，而不是<code>[size]</code></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] A;       <span class="comment">// 简单的logic变量，存储32bit，访问bit片段需要使用切片</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] B[<span class="number">8</span>];     <span class="comment">// 非合并数组，使用字边界，bit不连续</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] [<span class="number">7</span>:<span class="number">0</span>] C;  <span class="comment">// 4x8合并数组，连续存储，数组大小是4，合并8位</span></span><br><span class="line"><span class="keyword">int</span> [<span class="number">1</span>:<span class="number">0</span>] D;          <span class="comment">// 2x32合并数组，数组大小是2，int合并32位</span></span><br><span class="line"><span class="comment">// 合并数组C的内存布局与向量A相同，但索引方式不同，下图为内存布局图示</span></span><br><span class="line"><span class="comment">//         合并数组 C[3:0][7:0]               普通向量 A[31:0]</span></span><br><span class="line"><span class="comment">//       ┌───────────────────────┐          ┌───────────────────────┐</span></span><br><span class="line"><span class="comment">//字节3   │       C[3][7:0]       │ 31-24    │ A[31:24]              │</span></span><br><span class="line"><span class="comment">//       ├───────────────────────┤          ├───────────────────────┤</span></span><br><span class="line"><span class="comment">//字节2   │       C[2][7:0]       │ 23-16    │ A[23:16]              │</span></span><br><span class="line"><span class="comment">//       ├───────────────────────┤          ├───────────────────────┤</span></span><br><span class="line"><span class="comment">//字节1   │       C[1][7:0]       │ 15-8     │ A[15:8]               │</span></span><br><span class="line"><span class="comment">//       ├───────────────────────┤          ├───────────────────────┤</span></span><br><span class="line"><span class="comment">//字节0   │       C[0][7:0]       │ 7-0      │ A[7:0]                │</span></span><br><span class="line"><span class="comment">//       └───────────────────────┘          └───────────────────────┘</span></span><br></pre></td></tr></table></figure><h2 id="混合使用"><a class="header-anchor" href="#混合使用">¶</a>混合使用</h2><ul><li>合并数组（Packed Array）和非合并数组（Unpacked Array）可以混合使用<ul><li>合并数组作为非合并数组的元素类型</li><li>支持更复杂的硬件建模需求，如数据包、寄存器组</li><li>优化内存布局：合并部分连续、非合并灵活分散</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// barray是一个有5个合并数据作为元素的非合并数组</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] [<span class="number">7</span>:<span class="number">0</span>] barray [<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] oneword = <span class="number">32&#x27;h012345678</span>;</span><br><span class="line">barray[<span class="number">0</span>] = oneword;</span><br><span class="line"><span class="comment">// barray[0][3] = 8&#x27;h01;</span></span><br><span class="line"><span class="comment">// barray[0][1][6] = 1&#x27;b1;</span></span><br></pre></td></tr></table></figure><img src="/images/image-20250718164324555.png" alt="image-20250718164324555" style="zoom: 33%;" /><h1>动态数组</h1><h2 id="特性与声明-v3"><a class="header-anchor" href="#特性与声明-v3">¶</a>特性与声明</h2><ul><li>动态数组在声明时使用空的下标<code>[]</code>，表示数组尺寸在编译时未指定</li><li>仿真运行时通过<code>new[]</code>操作符显式地预分配内存大小</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dyn[],d2[];                  <span class="comment">// 声明动态数组</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">5</span>];                <span class="comment">// 分配5个元素空间</span></span><br><span class="line">    <span class="keyword">foreach</span> (dyn[j]) dyn[j] = j; <span class="comment">// 初始化元素（例如：dyn[0]=0, dyn[1]=1...）</span></span><br><span class="line">    d2 = dyn;                    <span class="comment">// 复制一个动态数组</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">20</span>](dyn);          <span class="comment">// 重新分配20个整数并进行复制</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">100</span>];              <span class="comment">// 重新分配100个整数，舍弃旧值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>基本数据类型（如<code>int</code>）相同，定宽数组和动态数据之间可以相互赋值<ul><li>当把一个定宽数组复制给一个动态数组时，会自动分配空间</li><li>适用于想声明一个常数数组但又不想统计元素的个数</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] mask[] = `&#123;<span class="number">2&#x27;b00</span>, <span class="number">2&#x27;b01</span>, <span class="number">2&#x27;b10</span>, <span class="number">2&#x27;b11</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>声明多维动态数组时，需按照从左到右的维度构造</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[][];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    d = <span class="keyword">new</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (d[i]) d[i] = <span class="keyword">new</span>[i+<span class="number">123</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (d[i,j]) d[i][j] = i + j;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="常用内建方法"><a class="header-anchor" href="#常用内建方法">¶</a>常用内建方法</h2><ul><li>长度操作：<code>array.size()</code>获取数组当前元素个数，等同于<code>$size(array)</code></li><li>删除内存：<code>array.delete()</code>释放数组内存</li><li>插入元素：<code>array.insert(index, value)</code>在指定索引位置插入元素，数组大小自动增加</li><li>删除元素：<code>array.delete(index)</code>删除指定索引处的元素，数组大小减1</li></ul><blockquote><p>动态数据使用上述内建函数消耗性能，更多内建方法见最后一章</p></blockquote><h1>队列</h1><h2 id="特性与声明-v4"><a class="header-anchor" href="#特性与声明-v4">¶</a>特性与声明</h2><ul><li>队列 (queues) 特性<ul><li>动态：队列长度在仿真期间自动伸缩，无需预分配大小</li><li>同质：队列中所有元素的类型必须相同</li><li>有序：队列中的元素是有序的，能够通过索引访问</li><li>高效操作：SV提供内置的方法高效地在队列的任意位置删减元素</li></ul></li><li>队列声明<ul><li>声明队列的语法与数组类似，但需使用<code>$</code></li><li>队列的常量初始化不再需要使用<code>'</code></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> my_int_q[$];              <span class="comment">// 声明一个整数队列</span></span><br><span class="line">my_class_type my_object_q[$]; <span class="comment">// 声明一个自定义类对象句柄队列</span></span><br><span class="line">my_int_q[$] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><h2 id="常用内建方法-v2"><a class="header-anchor" href="#常用内建方法-v2">¶</a>常用内建方法</h2><ul><li>长度操作：<code>q.size()</code>返回队列中元素的当前数量，等同于<code>$size(q)</code></li><li>删除内存：<code>array.delete()</code>释放数组内存</li><li>删除元素：<code>q.delete(index)</code>删除指定索引处的元素</li><li>插入元素：<code>q.insert(index, item)</code>在指定索引处插入一个元素</li><li>头部插入：<code>q.push_front(item)</code>在队列的头部插入一个元素</li><li>尾部插入：<code>q.push_back(item)</code>在队列的尾部插入一个元素</li><li>头部发送：<code>q.pop_front()</code>移除并返回队列头部的元素</li><li>尾部发送：<code>q.pop_back()</code>移除并返回队列尾部的元素</li><li>移除重复：<code>q.unique()</code>移除队列中的重复元素</li></ul><h1>关联数组</h1><h2 id="特性与声明-v5"><a class="header-anchor" href="#特性与声明-v5">¶</a>特性与声明</h2><ul><li>关联数组（Associative Arrays）允许使用任意类型（如整型、字符串等）作为索引（键Key），快速存取对应的值，原理示例<code>Key: “apple” -&gt; 哈希表 -&gt; 索引值 -&gt; 定位存储位置（通）-&gt; 返回值</code><ul><li>动态：内存仅在写入元素时分配，无需预分配</li><li>无序：存储非连续索引的数据（如大范围地址的稀疏数据），避免内存浪费</li><li>灵活：索引可以为任意类型</li></ul></li></ul><img src="/images/image-20250721163601864.png" alt="image-20250721163601864" style="zoom:50%;" /><ul><li>声明格式：<code>data_type array_name [index_type];</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明及初始化</span></span><br><span class="line"><span class="keyword">int</span> fruit_prices[<span class="keyword">string</span>] = &#x27;&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;orange&quot;</span>: <span class="number">4</span>&#125;;</span><br><span class="line">fruit_prices[<span class="string">&quot;grape&quot;</span>] = <span class="number">6</span>; <span class="comment">// 动态赋值</span></span><br><span class="line"><span class="comment">// foreach循环遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (fruit_prices[i]) <span class="keyword">begin</span>  </span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;fruit_prices[%s] = %0d&quot;</span>, i, fruit_prices[i]);  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// first/next循环遍历</span></span><br><span class="line"><span class="keyword">string</span> key;</span><br><span class="line"><span class="keyword">if</span> (my_array<span class="variable">.first</span>(key)) <span class="keyword">begin</span>  <span class="comment">// 获取第一个键存入字符串变量key</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;my_array[%s] = %0d&quot;</span>, key, my_array[key]); <span class="comment">// 打印键值</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span> (my_array<span class="variable">.next</span>(key));  <span class="comment">// 获取下一个键，直到返回0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="常用内建方法-v3"><a class="header-anchor" href="#常用内建方法-v3">¶</a>常用内建方法</h2><ul><li>删除内存：<code>array.delete()</code></li><li>删除键值对：<code>array.delete(key)</code></li><li>检查键存在：<code>array.exitsts(key)</code>检查指定键是否存在，若存在返回布尔值1</li><li>数量查询：<code>array.nun()</code>查询数组中键值对的总数量</li><li>获取首键：<code>array.first(ref)</code>获取第一个键赋值给参数ref</li><li>获取未键：<code>array.last(ref)</code>获取最后一个键赋值给参数ref</li><li>获取下一键：<code>array.next(ref)</code>获取下一个键赋值给参数ref</li><li>获取上一键：<code>array.prev(ref)</code>获取上一个键赋值给参数ref</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> memory_model;  </span><br><span class="line">  <span class="comment">// 假设这是一个简单的内存模型，用于存储和检索数据  </span></span><br><span class="line">  <span class="keyword">byte</span> memory[<span class="keyword">int</span>];  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> write(<span class="keyword">int</span> addr, <span class="keyword">byte</span> data);  </span><br><span class="line">    memory[addr] = data;  </span><br><span class="line">  <span class="keyword">endfunction</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">byte</span> read(<span class="keyword">int</span> addr);  </span><br><span class="line">    <span class="keyword">if</span> (memory<span class="variable">.exists</span>(addr)) <span class="keyword">return</span> memory[addr];  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 假设如果地址不存在，则返回0  </span></span><br><span class="line">  <span class="keyword">endfunction</span>  </span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><h1>数组的方法</h1><ul><li>数组内建方法汇总，使用于任何非合并的数组类型，包括定宽数组、动态数组、队列和关联数组</li></ul><h2 id="缩减"><a class="header-anchor" href="#缩减">¶</a>缩减</h2><ul><li>数组的缩减方法是指将数组缩减成一个值，结果和元素的位宽一致</li><li>缩减方法可以用来计算数组中所有元素的和、积或逻辑运算<ul><li>和积：<code>array.sum()</code>、<code>array.product()</code></li><li>与或：<code>array.and()</code>、<code>array.or()</code></li><li>异或：<code>array.xor()</code></li></ul></li><li>SV并没有内建从数组中随机选取一个元素的方法，但可以生成一个随机索引</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">4</span>] = &#x27;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> random_index, selected_element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机索引（0 到 3）</span></span><br><span class="line">random_index = $urandom_range(my_array<span class="variable">.size</span>() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选取元素</span></span><br><span class="line">selected_element = my_array[random_index];</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;随机选取的元素: %d&quot;</span>, selected_element);</span><br></pre></td></tr></table></figure><h2 id="定位-条件"><a class="header-anchor" href="#定位-条件">¶</a>定位/条件</h2><ul><li>用于查找数组中所有满足指定条件的元素，并将结果以队列形式（无<code>'</code>）返回</li><li>数组定位方法：min、max、unique<ul><li><code>array.min()</code>和<code>array.max()</code>返回数组的最值队列</li><li><code>array.unique()</code>返回数组中唯一值的队列</li></ul></li><li>数组定位方法：find<ul><li><code>array.find() with (condition)</code>强制使用<code>with</code>语句查找指定条件，并以队列形式返回<ul><li>无匹配时返回空队列<code>&#123;&#125;</code>，需在代码中检查结果中是否有效</li><li><code>with</code>支持复杂逻辑，如<code>item &gt; 2 &amp;&amp; intem &lt; 8</code></li></ul></li><li><code>array.find_first() with (conditon)</code>以队列形式返回首个满足条件的元素</li><li><code>array.find_last() with (conditon)</code>以队列形式返回最后一个满足条件的元素</li><li><code>array.find_index() with (conditon)</code>以队列形式返回首个满足条件的元素的索引<ul><li>对于<code>find_index</code>方法，返回的队列类型是双状态<code>int</code>而不是四状态<code>integer</code></li></ul></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#x27;&#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> found_queue[$] = arr<span class="variable">.find</span>() <span class="keyword">with</span> (item &gt; <span class="number">5</span>);   <span class="comment">// found_queue = &#123;7, 9&#125;</span></span><br><span class="line"><span class="comment">// found_queue.delete();</span></span><br><span class="line">found_queue = arr<span class="variable">.find_first</span>() <span class="keyword">with</span> (item % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 首个偶数：&#123;2&#125;</span></span><br><span class="line">found_queue = arr<span class="variable">.find_last</span>() <span class="keyword">with</span> (item &lt; <span class="number">6</span>); <span class="comment">// 最后一个小于6的数：&#123;5&#125;</span></span><br><span class="line"><span class="keyword">int</span> index_queue[$] = arr<span class="variable">.find_index</span>() <span class="keyword">with</span> (item == <span class="number">9</span>); <span class="comment">// 索引：&#123;3&#125;</span></span><br></pre></td></tr></table></figure><ul><li>在条件语句<code>with</code>中，<code>item</code>被称为重复参数，是一个缺省的名字，也可以指定其他名字，以下四个语句是等同的</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">found_queue = arr<span class="variable">.find</span>() <span class="keyword">with</span> (item == <span class="number">3</span>);</span><br><span class="line">found_queue = arr<span class="variable">.find</span> <span class="keyword">with</span> (item == <span class="number">3</span>);</span><br><span class="line">found_queue = arr<span class="variable">.find</span>(item) <span class="keyword">with</span> (item == <span class="number">3</span>);</span><br><span class="line">found_queue = arr<span class="variable">.find</span>(x) <span class="keyword">with</span> (x == <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>当把数组缩减方法<code>sum()</code>与条件语句<code>with</code>结合使用时，可以检测表达式为真的次数</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count, total, d[] = `&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">count = d<span class="variable">.sum</span>(x) <span class="keyword">with</span> (x &gt; <span class="number">7</span>);        <span class="comment">// 2 = sum&#123;1,0,1,0,0,0&#125;</span></span><br><span class="line">total = d<span class="variable">.sum</span>(x) <span class="keyword">with</span> ((x &gt; <span class="number">7</span>) * x)   <span class="comment">// 17 = sum&#123;9,0,8,0,0,0&#125;</span></span><br><span class="line">total = d<span class="variable">.sum</span>(x) <span class="keyword">with</span> (x &lt; <span class="number">8</span> ? x : <span class="number">0</span>) <span class="comment">// 12 = sum&#123;0,1,0,3,4,4&#125;</span></span><br></pre></td></tr></table></figure><ul><li>下面介绍了一种使用数组定位方法建立记分板的方法，使用<code>typedef</code>创建包结构（对于包信息的存储，更好的方法是使用类）<ul><li>例子中<code>check_addr()</code>函数在计分板中寻找和参数匹配的地址</li><li><code>find_index()</code>方法返回一个<code>int</code>队列</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] pr;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; Packet;</span><br><span class="line"></span><br><span class="line">Packet scb[$];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> check_addr(<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr);</span><br><span class="line">    <span class="keyword">int</span> intq[$];</span><br><span class="line">    </span><br><span class="line">    intq = scb<span class="variable">.find_index</span>() <span class="keyword">with</span> (item<span class="variable">.addr</span> == addr);</span><br><span class="line">    <span class="keyword">case</span>(intq<span class="variable">.size</span>())</span><br><span class="line">        <span class="number">0</span>: <span class="built_in">$display</span>(<span class="string">&quot;Addr %h not found in scoreboard&quot;</span>, addr);</span><br><span class="line">        <span class="number">1</span>: scb<span class="variable">.delete</span>(intq[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">$display</span>(<span class="string">&quot;ERROR: Multiple hits for addr %h&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endfunction</span> : check_addr</span><br></pre></td></tr></table></figure><h2 id="排序"><a class="header-anchor" href="#排序">¶</a>排序</h2><ul><li>只有定宽数组、动态数组、队列可以排序、反转、打乱次序，关联数组不能重新排序</li><li>排序方法改变了原始数组，而定位方法是新建一个队列来保存结果<ul><li><code>array.sort()</code>按照元素大小进行升序排序</li><li><code>array.rsort()</code>按照元素大小进行降序排序</li><li><code>array.reverse()</code>反转数组中元素的顺序</li><li><code>array.shuffle()</code>打乱数组中元素的顺序</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[] = &#x27;&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">d<span class="variable">.sort</span>();    <span class="comment">//&#x27;&#123;1,3,4,4,8,9&#125;</span></span><br><span class="line">d<span class="variable">.rsort</span>();   <span class="comment">//&#x27;&#123;9,8,4,4,3,1&#125;</span></span><br><span class="line">d<span class="variable">.reverse</span>(); <span class="comment">//&#x27;&#123;4,4,3,8,1,9&#125;</span></span><br><span class="line">d<span class="variable">.shuffle</span>(); <span class="comment">//&#x27;&#123;9,4,3,8,1,4&#125;</span></span><br></pre></td></tr></table></figure><ul><li>使用子域对一个结构数组进行排序时，<code>reverse</code>和<code>shuffle</code>方法不能带<code>with</code>语句</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> &#123; <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] red, green, blue&#125; color[];</span><br><span class="line">color = &#x27;&#123;&#x27;&#123;red:<span class="number">7</span>, grean:<span class="number">4</span>, blue:<span class="number">9</span>&#125;, &#x27;&#123;red:<span class="number">3</span>, grean:<span class="number">2</span>, blue:<span class="number">9</span>&#125;, &#x27;&#123;red:<span class="number">5</span>, grean:<span class="number">2</span>, blue:<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">color<span class="variable">.sort</span> <span class="keyword">with</span> (item<span class="variable">.red</span>);           <span class="comment">//只对红色像素进行重新排序</span></span><br><span class="line"><span class="comment">//&#x27;&#123;&#x27;&#123;red:3, grean:2, blue:9&#125;, &#x27;&#123;red:5, grean:2, blue:1&#125;, &#x27;&#123;red:7, grean:4, blue:9&#125;&#125;</span></span><br><span class="line">color<span class="variable">.sort</span>(x) <span class="keyword">with</span> (x<span class="variable">.green</span>, x<span class="variable">.blue</span>)  <span class="comment">//先对绿色再对蓝色进行重新排序</span></span><br></pre></td></tr></table></figure><h1>选择数据结构</h1><blockquote><p>本章介绍一些如何正确选择存储类型（数据结构）的经验法则</p></blockquote><ul><li>网络数据包建模<ul><li>特点：长度固定、顺序读取</li><li>针对长度固定或可变的数据可分别采用定宽数组或动态数组</li></ul></li><li>保存期望值的记分板<ul><li>特点：仿真前长度位置，按值存取，长度经常变化</li><li>一般情况下可使用队列，方便在仿真期间连续增加和删除元素</li><li>如果记分板由数百个元素，而且需要经常对元素进行增删操作，则使用关联数组在速度上可能更快</li><li>如果将事务建模成对象，那么记分板可以是句柄的队列</li><li>如果不用记分板进行搜索，那么只需要把预期的数值存入信箱（mailbox）</li></ul></li><li>有序结构<ul><li>如果数据按照可预见的顺序输出，可以使用队列</li><li>如果输出顺序不确定，则使用关联数组</li></ul></li><li>对特大容量存储器建模<ul><li>如果不需要用到所有存储空间，可以使用关联数组实现稀疏存储</li><li>确保使用的是双状态类型的32比特合并数据，以节约仿真器使用的内存</li></ul></li><li>文件中的命令名或操作码<ul><li>特点：把字符串转换成固定值</li><li>从文件中读出字符串，然后使用命令作为字符串索引在关联数组中查找命令名或操作码</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 芯片验证 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
            <tag> UVM </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SV数据类型</title>
      <link href="/SV%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/SV%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1>四状态类型</h1><h2 id="逻辑类型"><a class="header-anchor" href="#逻辑类型">¶</a>逻辑类型</h2><ul><li><p><code>logic</code>：推荐替代<code>wire</code>和<code>reg</code>的类型</p><ul><li><code>reg</code>：Verilog遗留类型，过程赋值中存储值</li><li><code>wire</code>：Verilog遗留类型，连续赋值或端口连接</li></ul></li><li><p>可表示四种状态：0、1、X（未知）、Z（高阻）</p></li><li><p>可用于线网连接，也可用于过程赋值，编译器根据上下文自行判断</p></li><li><p>只能有一个驱动，否则编译报错</p><ul><li>如双向总线<code>inout</code>应该使用线网类型<code>wire</code>或<code>tri</code></li></ul></li></ul><h2 id="整数类型"><a class="header-anchor" href="#整数类型">¶</a>整数类型</h2><ul><li><code>integer</code>：带符号的四值整数，不指定明确位宽<ul><li>位宽由实现定义，通常是32位</li><li>主要用于循环控制、通用计算，不用于硬件建模</li></ul></li><li><code>time t</code>：存储仿真时间值的无符号四值整数，不指定明确位宽<ul><li><code>timeunit 1ns;</code>用于指定仿真中<code>#</code>延迟</li><li><code>timeprecision 1ps;</code> 用于指定<code>$time</code>单位</li></ul></li></ul><h1>双状态类型</h1><blockquote><p>相比于四值类型，引入双值类型有利于提高仿真器性能并减少内存的使用量</p></blockquote><h2 id="整数类型-v2"><a class="header-anchor" href="#整数类型-v2">¶</a>整数类型</h2><ul><li><code>bit</code>：最常用的二值类型，无符号整数</li><li><code>bit [31:0]</code>：32比特无符号整数</li><li><code>unsigned int</code>：32比特无符号整数</li><li><code>int</code>：32比特有符号整数，范围是 (-128, 127)</li><li><code>byte</code> ：8比特有符号整数</li><li><code>shortint</code>：16比特有符号整数</li><li><code>longint</code>：64比特有符号整数</li></ul><blockquote><p>注意：当把双状态变量连接到被测设计输出时，若输出X或Z态会被转换成双状态值而测试代码无法察觉。使用<code>$isunknown</code>操作符，在表达式任意位出现X或Z态时返回1</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">$isunknown</span>(iport) == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;@%t: 4-state value detected on iport %b&quot;</span>, <span class="built_in">$time</span>, iport);</span><br></pre></td></tr></table></figure><h1>类型转换</h1><h2 id="静态转换"><a class="header-anchor" href="#静态转换">¶</a>静态转换</h2><ul><li>语法：<code>目标类型'(表达式)</code></li><li>强制改变表达式类型，不进行越界检查</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">int</span>&#x27;(<span class="number">10</span><span class="variable">.0</span> - <span class="number">0</span><span class="variable">.1</span>);           <span class="comment">// 浮点转整型（截断小数）</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] byte_val = <span class="keyword">unsigned</span>&#x27;(-<span class="number">1</span>); <span class="comment">// 有符号转无符号（结果为255）</span></span><br><span class="line"><span class="keyword">void</span>&#x27;(function_call());             <span class="comment">// 忽略函数返回值  </span></span><br></pre></td></tr></table></figure><h2 id="动态转换"><a class="header-anchor" href="#动态转换">¶</a>动态转换</h2><ul><li>语法：<code>$cast(目标变量, 源表达式)</code></li><li>返回值：1表示转换成功，0表示转换失败</li><li>应用场景<ul><li>非枚举值赋给枚举变量时需显式检查，避免引入非法值</li><li>当父类句柄指向子类对象时，将父类句柄转换为子类句柄</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举转换</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, BLUE&#125; color_e;    <span class="comment">// RED=0, BLUE=1</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">color_e color;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">$cast</span>(color, c)) <span class="built_in">$error</span>(<span class="string">&quot;越界&quot;</span>); <span class="comment">// c=2超出枚举范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类向下转型</span></span><br><span class="line"><span class="keyword">class</span> Parent; <span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent; <span class="keyword">endclass</span></span><br><span class="line">Parent p = <span class="keyword">new</span> Child();</span><br><span class="line">Child c;</span><br><span class="line"><span class="built_in">$cast</span>(c, p);  <span class="comment">// 合法向下转型</span></span><br></pre></td></tr></table></figure><h2 id="隐式转换"><a class="header-anchor" href="#隐式转换">¶</a>隐式转换</h2><ul><li>由编译器自动完成，无需额外语法<ul><li>不同位宽/符号类型：自动扩展/截断、补零或符号扩展</li><li>可能引入风险</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] x_vec = <span class="number">&#x27;b11x0</span>; </span><br><span class="line"><span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] b_vec = x_vec; <span class="comment">// 风险：b_vec=&#x27;b010（x被转为0），四值-&gt;二值，可能隐蔽错误</span></span><br></pre></td></tr></table></figure><h1>特殊类型</h1><ul><li>浮点数类型<ul><li><code>real</code>：双精度浮点数，等效于IEEE 754标准的64位浮点</li><li><code>shortreal</code>：单精度浮点数，32位</li></ul></li><li>空类型<ul><li><code>void</code>声明无返回值的函数或任务</li></ul></li><li>句柄类型<ul><li><code>chandle</code>存储由C/C++通过DPI传递的指针</li></ul></li><li>事件类型<ul><li><code>event</code>用于声明同步时间，无数据，仅作为同步信号标识</li><li>通过操作符<code>-&gt;</code>触发事件，<code>@</code>或<code>wait()</code>等待事件</li></ul></li><li>字符串<ul><li>用于存储动态文本字符串，本质是字符队列</li></ul></li></ul><h1>字符串</h1><h2 id="特性"><a class="header-anchor" href="#特性">¶</a>特性</h2><ul><li>动态长度：运行时自动调整长度，无需预定义大小</li><li>ASCII存储：每个字符以字节形式存储 (ASCII 编码)</li><li>空终止符：自动维护结尾的<code>\0</code>字符，与C语言兼容</li><li>索引访问：支持<code>str[i]</code>访问字符</li><li>支持转移序列：<code>\n</code> <code>\t</code> <code>\\</code> <code>\&quot;</code> <code>\0</code> <code>\xHH</code> (十六进制)</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> msg = <span class="string">&quot;Hello SV!&quot;</span>;         <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">string</span> empty_str;                 <span class="comment">// 默认值 &quot;&quot; </span></span><br><span class="line"><span class="keyword">string</span> path = <span class="string">&quot;dir/file.txt&quot;</span>;     <span class="comment">// 路径字符串</span></span><br><span class="line"><span class="keyword">string</span> hex_str = <span class="string">&quot;A\x42C&quot;</span>;        <span class="comment">// 包含十六进制字符 (ABC)</span></span><br></pre></td></tr></table></figure><h2 id="内建方法"><a class="header-anchor" href="#内建方法">¶</a>内建方法</h2><h3 id="长度操作"><a class="header-anchor" href="#长度操作">¶</a>长度操作</h3><ul><li><code>len()</code>或<code>length()</code>：返回字符串长度</li><li><code>putc(int i, byte c)</code>：替换位置<code>i</code>的的字符为<code>c</code>，索引从0开始</li><li><code>getc(int i)</code>：获取位置<code>i</code>的字符</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> word = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> length = word<span class="variable">.len</span>();       <span class="comment">// length = 4</span></span><br><span class="line">word<span class="variable">.putc</span>(length-<span class="number">1</span>, &#x27;!&#x27;);      <span class="comment">// 修改为 &quot;tes!&quot;</span></span><br><span class="line"><span class="keyword">byte</span> last_char = word<span class="variable">.getc</span>(<span class="number">3</span>); <span class="comment">// 返回 &#x27;!&#x27; (ASCII 33)</span></span><br></pre></td></tr></table></figure><h3 id="大小写转换"><a class="header-anchor" href="#大小写转换">¶</a>大小写转换</h3><ul><li><code>toupper()</code>：转为全大写</li><li><code>tolower()</code>：转为全小写</li></ul><blockquote><p>大写：Uppercase Letter；小写：Lowercase Letter</p></blockquote><h3 id="子串操作"><a class="header-anchor" href="#子串操作">¶</a>子串操作</h3><ul><li><code>substr(int s, int e)</code>：提取子串<code>[s,e]</code></li><li><code>delete(int s, int e)</code>：删除子串</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> full = <span class="string">&quot;SystemVerilog&quot;</span>;</span><br><span class="line"><span class="keyword">string</span> sub = full<span class="variable">.substr</span>(<span class="number">6</span>, <span class="number">8</span>);  <span class="comment">// &quot;Ver&quot;</span></span><br></pre></td></tr></table></figure><h3 id="比较与搜索"><a class="header-anchor" href="#比较与搜索">¶</a>比较与搜索</h3><ul><li><code>compare(string s)</code>：区分大小写比较，相等时返回0，大于时返回1，小于时返回-1</li><li><code>icompare(string s)</code>：不区分大小写比较</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> a = <span class="string">&quot;apple&quot;</span>, b = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> cmp1 = a<span class="variable">.compare</span>(b);     <span class="comment">// 非零值 (区分大小写)</span></span><br><span class="line"><span class="keyword">int</span> cmp2 = a<span class="variable">.icompare</span>(b);    <span class="comment">// 0 (不区分大小写)</span></span><br></pre></td></tr></table></figure><ul><li><code>find(string substr)</code>：正向（从左往右）查找字符串位置<ul><li>大小写敏感</li><li>返回子串第一次出现的起始索引或-1</li><li>用于提取前缀、解析命令</li></ul></li><li><code>rfind(string substr)</code>：反向（从右往左）查找子串位置<ul><li>大小写敏感</li><li>返回子串最后一次出现的起始索引或-1</li><li>用于提取后缀、处理文件扩展名或路径</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> s = <span class="string">&quot;apple,orange,apple&quot;</span>;</span><br><span class="line"><span class="keyword">string</span> file_path = <span class="string">&quot;/home/user/report_2023.pdf&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> pos1 = s<span class="variable">.find</span>(<span class="string">&quot;apple&quot;</span>);    <span class="comment">// 返回 0 (第一个&quot;apple&quot;)</span></span><br><span class="line"><span class="keyword">int</span> pos2 = s<span class="variable">.rfind</span>(<span class="string">&quot;apple&quot;</span>);   <span class="comment">// 返回 13 (最后一个&quot;apple&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dot_pos = file_path<span class="variable">.rfind</span>(<span class="string">&quot;.&quot;</span>);      <span class="comment">// 查找最后一个点号的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dot_pos != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">string</span> extension = file_path<span class="variable">.substr</span>(dot_pos, file_path<span class="variable">.len</span>()-<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Extension: %s&quot;</span>, extension); <span class="comment">// 输出 &quot;.pdf&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a class="header-anchor" href="#类型转换">¶</a>类型转换</h3><ul><li><code>atoi()</code>：字符串-&gt;十进制整数</li><li><code>atohex()</code>：字符串-&gt;十六进制整数</li><li><code>atobin()</code>：字符串-&gt;二进制整数</li><li><code>atoreal()</code>：字符串-&gt;实数</li><li><code>hextoa(int i)</code>：十六进制整数-&gt;字符串<ul><li>SV不直接提供<code>itoa()</code>，需先使用<code>$sformatf</code></li></ul></li><li><code>bintoa(int i)</code>：二进制整数-&gt;字符串<ul><li>需先使用<code>$sformatf</code></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="string">&quot;7F&quot;</span><span class="variable">.atohex</span>();  <span class="comment">// 十六进制转整数 → 127</span></span><br><span class="line"><span class="keyword">real</span> pi = <span class="string">&quot;3.1416&quot;</span><span class="variable">.atoreal</span>(); <span class="comment">// 字符串转实数</span></span><br></pre></td></tr></table></figure><h3 id="格式化"><a class="header-anchor" href="#格式化">¶</a>格式化</h3><ul><li><code>$sformatf</code>：格式化字符串生成器<ul><li>优先使用此函数代替拼接</li><li>SV不直接提供<code>itoa()</code>，需使用<code>$sformatf</code></li><li>尽管大多数仿真支持<code>$psprintf</code>函数，功能也和<code>$sformatf</code>相同，但并不是SV的原生函数</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">string</span> hex_str = <span class="built_in">$sformatf</span>(<span class="string">&quot;%h&quot;</span>, data);     <span class="comment">// 默认格式 → &quot;ff&quot;</span></span><br><span class="line"><span class="keyword">string</span> hex_fmt = <span class="built_in">$sformatf</span>(<span class="string">&quot;0x%h&quot;</span>, data);    <span class="comment">// 带前缀 → &quot;0xff&quot;</span></span><br><span class="line"><span class="keyword">string</span> hex_auto = <span class="built_in">$sformatf</span>(<span class="string">&quot;%0h&quot;</span>, data);    <span class="comment">// &quot;ff&quot; (推荐)</span></span><br><span class="line"><span class="keyword">string</span> hex_4bit = <span class="built_in">$sformatf</span>(<span class="string">&quot;%4h&quot;</span>, value);   <span class="comment">// &quot;  ff&quot; (空格填充)</span></span><br><span class="line"><span class="keyword">string</span> hex_04bit = <span class="built_in">$sformatf</span>(<span class="string">&quot;%04h&quot;</span>, value); <span class="comment">// &quot;00ff&quot; (零填充)</span></span><br></pre></td></tr></table></figure><h1>结构体</h1><h2 id="类型重命名"><a class="header-anchor" href="#类型重命名">¶</a>类型重命名</h2><ul><li><code>typedef</code>语句为现有的数据类型创建新名称（别名）<ul><li>提高代码的可读性、复用性和可维护性</li><li>约定俗成：一般所有用户自定义类型都带后缀<code>_t</code></li><li><code>typedef</code>定义的类型与原始类型完全等效</li></ul></li><li>定义数组类型的语法：<code>typedef &lt;元素类型&gt; &lt;新类型&gt; [&lt;维度&gt;];</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Verilog风格</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> OPSIZE 8</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> OPREG reg [`OPSIZE-1:0]</span></span><br><span class="line">`OPREG op_a, op_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SystemVerilog风格</span></span><br><span class="line"><span class="keyword">parameter</span> OPSIZE = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">reg</span> [OPSIZE-<span class="number">1</span>:<span class="number">0</span>] opreg_t;</span><br><span class="line">opreg_t op_a op_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数组类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] byte_array [<span class="number">64</span>];</span><br><span class="line">byte_array buffer;</span><br></pre></td></tr></table></figure><h2 id="包"><a class="header-anchor" href="#包">¶</a>包</h2><ul><li>可以把<code>parameter</code>和<code>typedef</code>语句放到一个程序包（package）里，使之能被整个设计和测试平台使用<ul><li>包允许在模块、包、程序和接口间共享声明</li></ul></li><li>使用<code>import</code>语句从包里导入符号<ul><li>引用的模块优先使用自己索引路径中的符号，若没有才去包里寻找</li><li>使用范围操作符<code>::</code>导入指定的符号</li></ul></li><li>包是完全独立的，可以被放到任何需要的地方<ul><li>包只能看到包内部定义的符号，或者包自己导入的包</li><li>不能层次化引用来自包外部的符号</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ABC总线的包</span></span><br><span class="line"><span class="keyword">package</span> ABC;</span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">int</span> abc_data_width = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">logic</span> [abc_data_width-<span class="number">1</span>:<span class="number">0</span>] abc_data_t;</span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">time</span> timeout = <span class="number">100</span>ns;</span><br><span class="line">    <span class="keyword">string</span> message = <span class="string">&quot;ABC done&quot;</span>;</span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">    <span class="keyword">import</span> ABC::*;                <span class="comment">// 导入包中所有符号</span></span><br><span class="line">    </span><br><span class="line">    abc_data_t data;                    <span class="comment">// 来自包ABC的符号</span></span><br><span class="line">    <span class="keyword">string</span> message = <span class="string">&quot;Test timed out&quot;</span>;  <span class="comment">// 本地的message隐藏了包里的message符号</span></span><br><span class="line">    <span class="comment">//若确实需要使用ABC中的messge，则使用ABC::message指定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="variable">#(timeout)</span>;                     <span class="comment">// 来自包ABC的符号</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Timeout - %s&quot;</span>, message);</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="创建结构体"><a class="header-anchor" href="#创建结构体">¶</a>创建结构体</h2><ul><li><code>struct</code>语句把若干变量组合到一个结构中<ul><li>封装数据，便于模块间传递（可综合）</li><li>约定俗成：一般用户自定义类型带后缀<code>_s</code></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;          <span class="comment">// 8位红、绿、蓝通道</span></span><br><span class="line">&#125; pixel_s;                      <span class="comment">// 定义结构体类型 pixel_s</span></span><br><span class="line"></span><br><span class="line">pixel_s my_pixel;               <span class="comment">// 声明变量</span></span><br><span class="line">my_pixel = &#x27;&#123;<span class="number">&#x27;h10</span>, <span class="number">&#x27;h20</span>, <span class="number">&#x27;h30</span>&#125;; <span class="comment">// 结构体赋值</span></span><br></pre></td></tr></table></figure><ul><li><code>packed</code>关键字将结构体中的数据合并到尽可能小的空间中<ul><li>若需经常对整个结构体进行复制，使用合并结构效率更高</li><li>若需经常对结构内的个体进行操作，使用非合并结构效率更高</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例中的pixel_s占用了三个长字的存储空间，即使实际只需三个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;         <span class="comment">// 使用packed进行压缩</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;          <span class="comment">// 8位红、绿、蓝通道</span></span><br><span class="line">&#125; pixel_s_p;</span><br></pre></td></tr></table></figure><h2 id="流操作符"><a class="header-anchor" href="#流操作符">¶</a>流操作符</h2><ul><li>流操作符用于数据打包和解包，简化数据的序列化操作<ul><li><code>&gt;&gt;</code>（从左至右打包或解包）：将数据打包成比特流，或从比特流中解包提取数据</li><li><code>&lt;&lt;</code>（从右至左打包或解包）：反序打包数据，或反序解包比特流</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打包（Pack）：将多个变量组合成比特流，如总线数据传输</span></span><br><span class="line">type_packed = &#123; &gt;&gt; &#123;var1, var2, ...&#125; &#125;;  <span class="comment">// 从左至右打包</span></span><br><span class="line">type_packed = &#123; &lt;&lt; &#123;var1, var2, ...&#125; &#125;;  <span class="comment">// 从右至左打包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解包（Unpack）：从比特流中提取数据，如DUT输出数据的解析</span></span><br><span class="line">&#123; &gt;&gt; &#123;var1, var2, ...&#125; &#125; = type_packed;  <span class="comment">// 从左至右解包</span></span><br><span class="line">&#123; &lt;&lt; &#123;var1, var2, ...&#125; &#125; = type_packed;  <span class="comment">// 从右至左解包</span></span><br></pre></td></tr></table></figure><ul><li>支持数据结构，使用与结构体、数组等复杂类型</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; packet_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包：将结构体打包成比特流</span></span><br><span class="line">packet_t tx_packet;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">39</span>:<span class="number">0</span>] packed_stream; <span class="comment">// 总宽度：8-bit + 32-bit = 40-bit</span></span><br><span class="line">tx_packet<span class="variable">.addr</span> = <span class="number">8&#x27;hA5</span>;</span><br><span class="line">tx_packet<span class="variable">.data</span> = <span class="number">32&#x27;h1234_5678</span>;</span><br><span class="line">packed_stream = &#123; &gt;&gt; &#123;tx_packet<span class="variable">.addr</span>, tx_packet<span class="variable">.data</span>&#125; &#125;;</span><br><span class="line"><span class="comment">// 从左至右打包：addr在前，data在后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解包：从比特流中提取数据</span></span><br><span class="line">packet_t rx_packet;</span><br><span class="line">&#123; &gt;&gt; &#123;rx_packet<span class="variable">.addr</span>, rx_packet<span class="variable">.data</span>&#125; &#125; = packed_stream;</span><br><span class="line"><span class="comment">// 解包后：rx_packet.addr = 8&#x27;hA5, rx_packet.data = 32&#x27;h1234_5678</span></span><br></pre></td></tr></table></figure><ul><li>可指定片段宽度，再将数据按照指定宽度分段后再打包或解包</li><li>比特流结果不能直接赋值给<a href="../SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97">非合并数组</a><ul><li>这是因为非合并数组相邻元素间可能存在间隙，如定宽数组使用字边界</li><li>需在赋值表达式的左边使用流操作符把比特流拆分到非合并数组中</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] stream = <span class="number">32&#x27;hA5A5_A5A5</span>;</span><br><span class="line"><span class="keyword">int</span> arr [<span class="number">0</span>:<span class="number">3</span>]; <span class="comment">// 非合并数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值违反语言规则</span></span><br><span class="line">arr = stream; <span class="comment">// 编译报错</span></span><br><span class="line"><span class="comment">// 正确：左侧流操作符拆分比特流</span></span><br><span class="line">&#123; &gt;&gt; &#123;arr&#125; &#125; = stream;      <span class="comment">// 等价于按32比特分段，未被赋值的部分自动填充默认值0</span></span><br><span class="line">&#123; &gt;&gt; <span class="keyword">byte</span> &#123;arr&#125; &#125; = stream; <span class="comment">// 按照指定片段宽度解包</span></span><br></pre></td></tr></table></figure><h1>枚举类型</h1><h2 id="定义与特性"><a class="header-anchor" href="#定义与特性">¶</a>定义与特性</h2><ul><li><p>定义</p><ul><li>枚举类型<code>enum</code>定义一组命名常量集合</li><li>增强可读性和安全性，避免手动赋值繁琐易出错</li></ul></li><li><p>特性</p><ul><li><p>默认首标签为0，后续标签自动递增</p><ul><li>也可以显式指定任意数值，未赋值的标签继承上一个标签值+1</li></ul></li><li><p>默认基类为<code>int</code>，支持自定义基类，需显式声明宽度</p><ul><li>例如<code>enum bit &#123;TRUE=1, FALSE=0&#125; Boolean;</code></li></ul></li><li><p>标签值在同一枚举类型中必须唯一</p></li><li><p>标签名在同一模块中必须唯一，并且不能以数字开头</p></li><li><p>支持范围语法批量生成标签</p></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;RED, YELLOW, GREEN&#125; light;  <span class="comment">// 默认标签：RED=0, YELLOW=1, GREEN=2</span></span><br><span class="line"><span class="keyword">enum</span> &#123;R, Y, G&#125; color;             <span class="comment">// 默认标签：R=0, Y=1, G=2</span></span><br><span class="line"><span class="comment">//标签值重复：虽然RED和R默认都为0，但属于两个不同的枚举类型，相互独立并不冲突</span></span><br><span class="line"><span class="comment">//也可使用显示赋值，避免打印时混淆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标签名称重复：同一模块内不同枚举类型的标签名称重复会导致编译错误，哪怕值不同</span></span><br><span class="line"><span class="keyword">enum</span> &#123;R = <span class="number">10</span>, Y, G&#125; color_e;      <span class="comment">// 默认标签：R=10, Y=11, G=12</span></span><br><span class="line"><span class="comment">//应对方法：使用唯一的标签名；在不同的模块中使用</span></span><br><span class="line"><span class="comment">//或使用typedef定义枚举类型，为每个枚举类型创建独立类型，减少名称污染风险</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;RESET, S[<span class="number">5</span>], W[<span class="number">6</span>:<span class="number">9</span>]&#125; state; <span class="comment">// 生成 RESET, S0-S4, W6-W9</span></span><br></pre></td></tr></table></figure><h2 id="自定义枚举类型"><a class="header-anchor" href="#自定义枚举类型">¶</a>自定义枚举类型</h2><ul><li>使用<code>typedef</code>定义可复用的枚举类型<ul><li>支持包导入，需显式导入包<code>import ABC::*;</code>，<code>*</code>也可以是指定的枚举类型</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;INIT, DECODE, IDLE&#125; fsm_state_e; <span class="comment">//使用后缀_e表示枚举类型</span></span><br><span class="line">fsm_state_e st, nst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (st)</span><br><span class="line">        IDLE: nst = INIT;</span><br><span class="line">        INIT: nst = DECODE;</span><br><span class="line">        <span class="keyword">default</span>: nst = IDLE;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Next state is %s&quot;</span>, nst<span class="variable">.name</span>());</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="枚举类型子程序"><a class="header-anchor" href="#枚举类型子程序">¶</a>枚举类型子程序</h2><ul><li><code>first()</code>或<code>first</code>返回第一个枚举常量</li><li><code>last()</code>返回最后一个枚举常量</li><li><code>next()</code>返回下一个枚举常量</li><li><code>next(N)</code>返回第N个枚举常量</li><li><code>prev()</code>返回前一个枚举常量</li><li><code>prev(N)</code>返回前第N个枚举常量</li></ul><blockquote><p>当到达枚举常量列表的头或尾时，函数<code>next</code>和<code>prev</code>会自动以环形方式绕回</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有枚举成员</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, BLUE, GREEN&#125; color_e;</span><br><span class="line">color_e color;</span><br><span class="line">color = color<span class="variable">.first</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Color = %0d/%s&quot;</span>, color, color<span class="variable">.name</span>());</span><br><span class="line">        color = color<span class="variable">.next</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">while</span> (color != color<span class="variable">.first</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 芯片验证 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
            <tag> UVM </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>站点目录</title>
      <link href="/%E7%AB%99%E7%82%B9%E7%9B%AE%E5%BD%95/"/>
      <url>/%E7%AB%99%E7%82%B9%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1>芯片验证</h1><h2 id="SystemVerilog"><a class="header-anchor" href="#SystemVerilog">¶</a>SystemVerilog</h2><h3 id="SV数据结构"><a class="header-anchor" href="#SV数据结构">¶</a>SV数据结构</h3><ul><li><a href="../SV%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">SV数据类型</a>：四值类型、双值类型、字符串、结构体与枚举类型等</li><li><a href="../SV%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F">SV常量变量</a>：常量，静态变量、自动变量，时间值</li><li><a href="../SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97">SV数组队列</a>：定宽数组、合并数组、动态数组、队列、关联数组，以及数组的内建方法</li></ul><h3 id="SV进程与线程"><a class="header-anchor" href="#SV进程与线程">¶</a>SV进程与线程</h3><ul><li><a href="../SV%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F">SV过程与子程序</a>：过程语句、任务、函数，子程序的参数与返回</li><li>SV线程间通信</li></ul><h1>知识储备</h1><ul><li><a href="MIPI%E6%A1%86%E6%9E%B6">MIPI框架</a>：MIPI框架概述，CSI-2、DSI协议栈简介</li></ul><h1>操作指南</h1><ul><li><a href="../Typora%E6%8A%80%E5%B7%A7">Typora技巧</a>：Typora实用技巧，PicGo上传图床</li></ul><h1>环境部署</h1><ul><li><a href="../Blog%E6%90%AD%E5%BB%BA">Blog搭建</a>：Git绑定GitHub，Hexo框架部署，CDN解析，NEXT配置，Typora联动</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>SV常量变量</title>
      <link href="/SV%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F/"/>
      <url>/SV%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1>常量</h1><h2 id="全局"><a class="header-anchor" href="#全局">¶</a>全局</h2><ul><li><code>define</code>定义宏常量<ul><li>全局跨文件文本常量替换</li></ul></li></ul><h2 id="模块级"><a class="header-anchor" href="#模块级">¶</a>模块级</h2><ul><li><code>parameter</code>定义可重写模块级常量<ul><li>编译时常量，实例化时可被覆盖</li><li>支持表达式计算</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> RAM #(</span><br><span class="line">    <span class="keyword">parameter</span> DEPTH = <span class="number">1024</span>,                      <span class="comment">// 简单常量</span></span><br><span class="line">    <span class="keyword">parameter</span> ADDR_WIDTH = <span class="built_in">$clog2</span>(DEPTH),        <span class="comment">// 表达式计算</span></span><br><span class="line">    <span class="keyword">parameter</span> [<span class="number">7</span>:<span class="number">0</span>] INIT_VALUE = <span class="number">8&#x27;hA5</span>           <span class="comment">// 带类型声明</span></span><br><span class="line">) (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>] addrs</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">localparam</span> HIGH_BIT = ADDR_WIDTH - <span class="number">1</span>;        <span class="comment">// 派生常量</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化时覆盖参数</span></span><br><span class="line">RAM <span class="variable">#(.DEPTH(2048), .INIT_VALUE(8&#x27;hFF)) ram_inst()</span>;</span><br></pre></td></tr></table></figure><ul><li><code>localparam</code>定义不可重写模块级常量<ul><li>模块内部专用常量</li><li>不能被外部覆盖，常用于派生参数</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] a, b</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">localparam</span> OP_ADD = <span class="number">2&#x27;b00</span>;            <span class="comment">// 操作码常量</span></span><br><span class="line">    <span class="keyword">localparam</span> OP_SUB = <span class="number">2&#x27;b01</span>;</span><br><span class="line">    <span class="keyword">localparam</span> OP_AND = <span class="number">2&#x27;b10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">localparam</span> RESULT_WIDTH = <span class="number">9</span>;          <span class="comment">// 内部计算结果位宽</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="块、类级"><a class="header-anchor" href="#块、类级">¶</a>块、类级</h2><ul><li><code>const</code>定义运行时可初始化的常量<ul><li>可在类、函数、initial块中使用</li><li>需要显示初始化，初始化后不可变</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE;     <span class="comment">// 声明</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> size);</span><br><span class="line">        MAX_SIZE = size;    <span class="comment">// 在构造函数中初始化</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">real</span> PI = <span class="number">3</span><span class="variable">.1415926</span>;         <span class="comment">// initial块常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">byte</span> START_ADDR = <span class="number">8&#x27;h40</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="枚举常量"><a class="header-anchor" href="#枚举常量">¶</a>枚举常量</h2><ul><li><code>typedef enum</code>定义枚举常量<ul><li>用于定义状态机、命令码等有限值集合</li><li>自动或手动赋值，提高代码可读性</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;       <span class="comment">// 显式指定底层类型</span></span><br><span class="line">    IDLE  = <span class="number">3&#x27;b001</span>,              <span class="comment">// 手动赋值</span></span><br><span class="line">    START = <span class="number">3&#x27;b010</span>,</span><br><span class="line">    RUN   = <span class="number">3&#x27;b100</span>,</span><br><span class="line">    ERROR = <span class="number">3&#x27;b111</span></span><br><span class="line">&#125; state_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;                   <span class="comment">// 自动赋值</span></span><br><span class="line">    RED,    <span class="comment">// 0</span></span><br><span class="line">    GREEN,  <span class="comment">// 1</span></span><br><span class="line">    BLUE    <span class="comment">// 2</span></span><br><span class="line">&#125; color_t;</span><br></pre></td></tr></table></figure><h2 id="常量函数"><a class="header-anchor" href="#常量函数">¶</a>常量函数</h2><ul><li>用于复杂计算生成常量值</li><li>在编译时求值，只能包含常量表达式</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> clog2(<span class="keyword">input</span> <span class="keyword">int</span> n);</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span> + clog2(n &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> MEM_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">localparam</span> ADDR_W = clog2(MEM_SIZE); <span class="comment">// 计算结果为常量</span></span><br></pre></td></tr></table></figure><h1>静态变量</h1><h2 id="声明"><a class="header-anchor" href="#声明">¶</a>声明</h2><ul><li>隐式静态变量：<code>module</code>、<code>program</code>中的<code>function</code>和<code>task</code>中声明的变量默认是静态的</li><li>显示静态变量：使用<code>static</code>关键词显式声明</li></ul><h2 id="特性"><a class="header-anchor" href="#特性">¶</a>特性</h2><ul><li><p>存储在全局数据区，固定内存位置</p></li><li><p>同一个模块多次实例化时共享静态变量</p><ul><li>由于使用共享的静态存储区，这也可能导致不用线程之间窜用</li></ul></li><li><p>适用场景</p><ul><li>模块级配置参数</li><li>硬件寄存器建模</li><li>时序逻辑总是使用静态变量保持状态<ul><li>如跨多个时钟周期保持值的计数器</li></ul></li><li>跨时间控制语句的变量</li></ul></li></ul><h2 id="生命周期"><a class="header-anchor" href="#生命周期">¶</a>生命周期</h2><ul><li>从仿真开始（时间0）持续到仿真结束</li><li>在多次触发的过程块中，只在仿真时间为0时进行一次初始化</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 仅仿真开始时初始化为0，声明并非执行语句，后续不再重复初始化</span></span><br><span class="line">    count &lt;= count + <span class="number">1</span>;    <span class="comment">// 每次触发递增</span></span><br><span class="line"><span class="keyword">end</span>   <span class="comment">// 输出序列：1, 2, 3...（非0,1,2...）</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 等效硬件行为，更推荐</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] counter = <span class="number">0</span>;  <span class="comment">// 综合为带初始值的寄存器</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1>自动变量</h1><h2 id="声明-v2"><a class="header-anchor" href="#声明-v2">¶</a>声明</h2><ul><li>隐式自动变量：<code>class</code>内部的<code>fucntion</code>、<code>task</code>中声明的变量默认是自动的，<code>initial</code>和<code>always</code>中声明的变量默认也是自动的</li><li>显示自动变量：使用<code>automatic</code>关键词显示声明<ul><li>建议在需要动态存储时，显式声明<code>automatic</code>，而非依赖隐式规则，避免混淆</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program块中显示指定自动存储方式</span></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test();</span><br><span class="line">    <span class="comment">//用检测数据何时被写入存储器任务</span></span><br><span class="line">    <span class="keyword">task</span> wait_for_bus(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr, expect_data,</span><br><span class="line">                      <span class="keyword">output</span> <span class="keyword">logic</span> success);</span><br><span class="line">        <span class="keyword">while</span> (bus_addr !== addr)</span><br><span class="line">            @(bus_addr);</span><br><span class="line">        sucess = (bus_data == expect_data);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure><h2 id="特性-v2"><a class="header-anchor" href="#特性-v2">¶</a>特性</h2><ul><li>存储在栈帧中，动态分配内存</li><li>多实例独立，每次调用创建独立副本</li><li>适用场景<ul><li>纯计算逻辑中使用自动变量</li><li>递归函数必须使用自动变量</li><li>不需要保持状态的中间变量</li><li>验证环境中的临时对象</li></ul></li></ul><h2 id="生命周期-v2"><a class="header-anchor" href="#生命周期-v2">¶</a>生命周期</h2><ul><li>仅在作用域激活期间存在</li><li>每次进入作用域时重新初始化</li><li>作用域结束时销毁</li><li><code>initial</code>中的自动变量可能在进程挂起后被回收，根据仿真器调度选项而定</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;         <span class="comment">// 错误：在always内部隐式声明自动变量</span></span><br><span class="line">    count &lt;= count + <span class="number">1</span>;    <span class="comment">// 永远输出1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> calculate();</span><br><span class="line">    <span class="keyword">automatic</span> <span class="keyword">int</span> temp = <span class="number">0</span>;  <span class="comment">// 每次调用时初始化为0</span></span><br><span class="line">    temp++;</span><br><span class="line">    <span class="built_in">$display</span>(temp);  <span class="comment">// 总是显示1</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">automatic</span> <span class="keyword">int</span> delay = <span class="number">10</span>;</span><br><span class="line">  #delay;  <span class="comment">// 挂起delay个时间单位</span></span><br><span class="line">  <span class="comment">// 调度器计划在($time + &amp;delay)时唤醒这个进程</span></span><br><span class="line">  <span class="comment">// 这里&amp;delay为delay的内存位置，而非实际值</span></span><br><span class="line">  <span class="comment">// 如果delay已被回收，仿真器可能无法确定何时唤醒</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1>时间值</h1><h2 id="单位与精度"><a class="header-anchor" href="#单位与精度">¶</a>单位与精度</h2><ul><li>一种方法是使用编译指示语句``timescale`。确保时延有适宜的量程和精度<ul><li>当采用多种``timescale`时，可能会因编译次序导致问题</li><li>建议每个文件末尾都以``timescale`结束，将其恢复为公司规定的默认值</li></ul></li><li>另一种方式是使用<code>timeunit</code>和<code>timeprecision</code>声明语句为每个模块指明时间<ul><li>若使用上述语句替代``timescale`，要求把它们放入每个带时延的模块中</li></ul></li></ul><h2 id="时间参数"><a class="header-anchor" href="#时间参数">¶</a>时间参数</h2><ul><li>控制时间显示格式：<code>$timeformat(四个参数)</code>，主要影响<code>$display</code>、<code>monitor</code>等任务中<code>%t</code>格式符的输出<ul><li>第一个参数：时间单位指数（必填），如-9对应1ns、-12对应1ps</li><li>第二个参数：小数点后保留位数（默认0）</li><li>第三个参数：时间值后的后缀（默认空字符串）</li><li>第四个参数：时间字符串的最小宽度（默认20），自动左侧补空格</li></ul></li><li><code>$time</code>的返回值是根据所在模块的时间精度要求进行舍入的整数，<code>$realtime</code>的返回值则是带小数部分的完整实数<ul><li>在计算时延时也可以使用<code>time t</code>或<code>realtime r</code>定义变量存储数据</li><li>如在``timescase 1ns/100ps<code>中，</code>time t = 800ps<code>以1ns存储，</code>realtime r = 800ps`以0.8ns存储</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> timing;</span><br><span class="line">    <span class="keyword">timeunit</span> <span class="number">1</span>ns;</span><br><span class="line">    <span class="keyword">timeprecision</span> <span class="number">1</span>ps;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$timeformat</span>(-<span class="number">9</span>, <span class="number">3</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        #<span class="number">1</span>     <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//1.000ns</span></span><br><span class="line">        #<span class="number">2</span>ns   <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//3.000ns</span></span><br><span class="line">        #<span class="number">0</span><span class="variable">.1ns</span> <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//3.100ns</span></span><br><span class="line">        #<span class="number">41</span>ps  <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//3.141ns</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 芯片验证 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
            <tag> UVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIPI框架</title>
      <link href="/MIPI%E6%A1%86%E6%9E%B6/"/>
      <url>/MIPI%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1>MIPI概述</h1><h2 id="MIPI简介"><a class="header-anchor" href="#MIPI简介">¶</a>MIPI简介</h2><ul><li><p><a href="www.mipi.org">MIPI联盟</a>（Mobile Industry Processor Interface Alliance，移动产业处理器接口联盟）是2003年由ARM、Nokia、意法半导体（ST）、德州仪器（TI）等公司成立的一个联盟</p><ul><li>成员规模超350家，覆盖芯片厂商、终端品牌、汽车制造商、测试机构</li><li>99%的智能手机使用至少3项MIPI标准（CSI-2 + DSI + I3C）</li></ul></li><li><p>MIPI协议把移动设备内部的接口如摄像头、显示屏、基带、射频接口等标准化，以减少设计的复杂度、提高设备的性能、同时降低功耗和成本</p><ul><li>MIPI并非单一接口或协议，而是包含一套协议和标准，以满足各种子系统的要求<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li></ul></li></ul><h2 id="MIPI框架"><a class="header-anchor" href="#MIPI框架">¶</a>MIPI框架</h2><p>MIPI框架主要包含四个方面的协议</p><ul><li>多媒体（Multimedia）：面向功能，每种多媒体协议栈通常又由三个层次构成<ul><li>应用层（Application Layer）：直接面向用户的顶层协议</li><li>协议层（Protocol/Link Layer）：定义数据包结构、流控、错误校验等逻辑传输机制</li><li>物理层（Multimedia-PHY Layer）：负责电气信号传输、时钟同步和物理连接</li></ul></li><li>控制与数据（Control &amp; Data）：功能使能层，构成控制网络，实现子系统协同<ul><li>纵向：提供从控制逻辑到物理层的控制链</li><li>横向：串联多媒体、存储、调试等子系统</li><li>效能：通过RFFE单线制、I3C多主控等专用优化，降低功耗/面积/延迟</li></ul></li><li>芯片间互联（Chip-to-Chip\IPC, Inter Process Communications）：通过高速、标准化、低延时实现异构芯片（如APU/GPU/Modem）的高效协同，同样分为几个层级<ul><li>物理层：使用更高速率的M-PHY，或抗干扰更强的A-PHY</li><li>协议层：UniPro，流控与错误恢复，类比TCP/IP的可靠性机制</li><li>接口抽象层：HCI，统一管理UniPro和M-PHY的软件API，配置链路状态、功耗模式</li><li>场景化应用协议：如AP-Modem专用低延迟通道LLI等，绕开协议栈开销</li></ul></li><li>调试与追踪（Debug &amp; Trace），提供全流程覆盖的协议支持，并且不干扰功能</li></ul><img src="/images/image-20250711094554653.png" alt="image-20250711094554653" style="zoom:50%;" /><blockquote><p>GNSS：Global Navigation Satellite System，全球导航卫星系统<br>Codec：Coder-Decoder，编解码器<br>FM Radio：Frequency Modulation Radio，调频广播<br>ETPS：Embedded Test and Programming Support<br>eTrak：实时调试与数据追踪<br>Cellular：蜂窝<br>LNA：Low Noise Amplifier，低噪声放大器<br>Antenna Tuner：天线调谐器</p></blockquote><h2 id="MIPI协议"><a class="header-anchor" href="#MIPI协议">¶</a>MIPI协议</h2><h3 id="多媒体"><a class="header-anchor" href="#多媒体">¶</a>多媒体</h3><img src="/images/image-20250711145624735.png" alt="image-20250711145624735" style="zoom:50%;" /><ul><li><p>CSI-2 (Camera Serial Interface 2): 高速摄像头串行接口，主流手机/车载摄像头传输协议</p></li><li><p>D-PHY: 差分串行物理层，CSI-2 和 DSI 常用的低成本物理层</p><ul><li>最低配置：1对数据线+1对时钟线</li><li>使用基于差分信号的NRZ编码</li></ul></li><li><p>C-PHY: C表示Clock-less，较D-PHY有更高带宽效率的物理层，常用于 CSI-2 和 DSI</p><ul><li>无需额外布置时钟线，3线制（Triplet）每通道</li><li>使用3-phase符号编码，嵌入时钟信息</li></ul></li><li><p>DSI (Display Serial Interface): 高速显示屏串行接口，用于手机/平板等屏幕驱动</p></li><li><p>CSI-3: 新一代摄像头接口，基于MIPI M-PHY或C-PHY，扩展性更强（如车用多摄像头）</p></li><li><p>SLIMbus (Serial Low-power Inter-chip Media Bus): 数字音频数据传输总线</p></li><li><p>SoundWire: 新一代数字音频接口，简化布线，替代SLIMbus</p></li></ul><blockquote><p>SLIMbus/SoundWire 是完整协议栈（含应用层+协议层+物理层），物理层非D/C-PHY</p></blockquote><h3 id="控制与数据"><a class="header-anchor" href="#控制与数据">¶</a>控制与数据</h3><img src="/images/image-20250711145606842.png" alt="image-20250711145606842" style="zoom:50%;" /><ul><li>I3C (Improved Inter-Integrated Circuit): 革命性传感器控制总线/改进型I2C，融合I2C/SPI/UART优点，高速、低功耗、多主控，用于陀螺仪/加速度计传感器控制、电源管理</li><li>I3C Basic: I3C 的子集，低成本、简化版传感器控制总线</li><li>RFFE (RF Front-End Control Interface): 射频前端控制接口，制手机天线开关、功率放大器</li><li>SPMI (System Power Management Interface): 处理器与外设间的电源管理通信协议</li><li>SSIC (SuperSpeed Inter-Chip): 基于USB 3.0的芯片间高速数据传输协议</li></ul><blockquote><p>I3C 因同时涵盖高效控制与简化调试，横跨 Control &amp; Data 和 Debug &amp; Trace 领域</p></blockquote><h3 id="芯片间互联"><a class="header-anchor" href="#芯片间互联">¶</a>芯片间互联</h3><img src="/images/image-20250711150529204.png" alt="image-20250711150529204" style="zoom:50%;" /><ul><li>M-PHY: 高速、可扩展物理层，用于芯片间或板间互连（如UFS存储接口）</li><li>UniPro (Unified Protocol): 基于M-PHY的应用层协议，构建通用芯片互连（如UFS）</li><li>LLI (Low Latency Interface): 应用处理器与调制解调器间超低延迟通信接口</li><li>HCI (HYBRID Command Interface): 管理 UniPro 和 M-PHY 栈的通用接口</li><li>DigRF: （已被后续协议替代）早期基带与射频芯片间数字接口</li><li>A-PHY (Automotive SerDes PHY): 长距离、高抗扰车规级高速物理层（用于车载摄像头/显示屏互连）</li></ul><h3 id="控制与调试"><a class="header-anchor" href="#控制与调试">¶</a>控制与调试</h3><ul><li>SDBI (Serial Debug Bus Interface): 基于I3C的低引脚数调试接口</li><li>STP (System Trace Protocol): 跨多核系统的软件跟踪协议</li><li>TWP (Trace Wrapper Protocol): 封装不同跟踪源数据的协议</li><li>MTB (MIPI Trace Buffer): 低成本片上跟踪缓冲区规范</li><li>PTI (Parallel Trace Interface): 替代传统并行调试接口的标准</li><li>BIST (Built-In Self Test): 集成自测试框架（如CSI-2 TX/RX测试）</li><li>SYS-T (System Trace): 定义时间戳和系统事件格式的框架</li><li>NIDnT (Non-Intrusive Debug and Trace): 用于I3C的非侵入式调试规范</li></ul><h1>MIPI CSI-2</h1><p><img src="/images/image-20250711114740490.png" alt="image-20250711114740490"></p><h2 id="协议概述"><a class="header-anchor" href="#协议概述">¶</a>协议概述<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></h2><ul><li><p>CSI协议旨在为高清摄像头和应用处理器之间提供一个高速的串行接口</p></li><li><p>目前常见的摄像头接口协议有CSI-2、USB3.0、DVP，相比DVP接口和USB3.0接口，CSI-2接口在图像数据的传输性能上拥有明显的优势<br><img src="/images/image-20250711152614939.png" alt="image-20250711152614939"></p><ul><li><p>串行传输</p><ul><li>使用的数据线相对较少，并且CSI-2一般采用双线差分传输 （D-PHY）</li><li>噪声同时加载到并行传输的两条差分线可以相互抵消，具有更强的抗干扰能力</li></ul></li><li><p>校验编码</p><ul><li>ECC能够监测2bit以内的数据出错和纠正1bit的数据出错</li><li>CRC能够监测多bit的数据出错，使CSI-2接口对数据传输具备更高容错</li></ul></li><li><p>功耗与传输速率</p><ul><li><p>CSI-2接口支持高速(HS)与低功耗(LP)两种模式协同工作</p></li><li><p>高速模式下使用 0.2V 低压差分电压，用于传输图像数据，其传输速度范围在</p><p>80Mbps 至 1000Mbps</p></li><li><p>低功耗模式下使用 12V 差分电压，用于传输控制命令，最高传输速度为 10Mbps</p></li><li><p>接口在正常工作时，会在一次高速模式传输后插入低功耗模式，两种模式相互切换使得 CSI-2接口同时兼顾了低功耗需求</p></li></ul></li></ul></li></ul><h2 id="总体框架"><a class="header-anchor" href="#总体框架">¶</a>总体框架</h2><p><img src="/images/image-20250711154506468.png" alt="image-20250711154506468"></p><ul><li>应用层：面向用户，可在应用层中实现对原始图像数据进行高级编码以及处理各种算法</li><li>协议层：由以下层级构成<ul><li>像素与字节的组包层：在发送端中，组包层负责将来自应用层的图片像素信息打包成为字节，然后输送至低级协议层中</li><li>解包层：在接收端中，解包层将来自低级协议层中的字节解压并还原，然后将数据流传输至接收端应用层</li><li>低级协议层：对起始指令SoT和终止指令SoT之间串行数据建立bit级和byte级同步，并将数据传输至下一层，包含对大小端的控制</li><li>通道管理层：数据通道的数量可以根据带宽需求进行选择，在发送端，接口将字节分发到一个或多个通道；在接收端，接口从通道中收集字节并将其合并重组，恢复出原始的数据流</li></ul></li><li>物理层：规范了传输媒介，电气特性，I/O电路以及bit级和byte级的同步机制，支持High-Speed模式和Low-Power模式，所有功能最终映射为：<ul><li>模拟电路：差分放大器、压控振荡器VCO、比较器</li><li>数字电路：移位寄存器、状态机、FIFO</li><li>无源器件：终端电阻、电容（AC耦合）</li></ul></li></ul><p><img src="/images/image-20250711171639524.png" alt="image-20250711171639524"></p><h2 id="数据包格式"><a class="header-anchor" href="#数据包格式">¶</a>数据包格式</h2><ul><li>用于CSI-2中D-PHY物理层的数据包可以分为长数据包和短数据包</li></ul><h3 id="长数据包"><a class="header-anchor" href="#长数据包">¶</a>长数据包</h3><p><img src="/images/image-20250711161101845.png" alt="image-20250711161101845"></p><ul><li>长数据包格式如上图所示，由三个部分组成<ul><li>32bit数据包头（PH），并由以下部分构成<ul><li>8bit数据标识符号（DI, Data Identifier）：由bit7-6的虚拟通道和bit5-0的数据类型构成</li><li>16bit字计数值（WC, Word Count）：统计长数据包的字节数，在有需要的情况表示第几帧或是第几行</li><li>8bit VCX+ECC校验位：由bit7-6的虚拟通道扩展位和bit5-0的ECC校验位构成</li></ul></li><li>有效载荷：具有可变字节数量的专用数据</li><li>16bit数据包页脚（PF）：即16bit CRC校验位</li></ul></li></ul><h3 id="短数据包"><a class="header-anchor" href="#短数据包">¶</a>短数据包</h3><p><img src="/images/image-20250711161111820.png" alt="image-20250711161111820"></p><ul><li>短数据包结构如上图所示，与长数据包结构相似，不同之处在于<ul><li>短数据包只包含有一个数据包头，数据包填充字段和数据包尾均不存在</li></ul></li></ul><h2 id="CCI接口"><a class="header-anchor" href="#CCI接口">¶</a>CCI接口</h2><h3 id="多速率模式"><a class="header-anchor" href="#多速率模式">¶</a>多速率模式</h3><ul><li>CCI，即摄像头控制接口，用于配置发送端口，使用两线接口（时钟线 SCL 和数据线 SDA），并具有半双工，串行的特点，兼容I2C协议，支持多速率模式<ul><li>传统I2C兼容模式（FM, Fast Mode）：400 Kbps<ul><li>开漏输出：只能依赖NMOS主动拉低电平，依赖外部上拉电阻Rp</li><li>数据采样点位于SCL高电平中点</li></ul></li><li>增强I2C模式（FM+, Fast Mode）：1 Mbps<ul><li>推挽输出（Push-Pull Output）：由PMOS上拉管 + NMOS下拉管组成互补输出级（Totem Pole，图腾柱），不再依赖Rp</li><li>上升速度更快（PMOS导通决定），抗干扰更强（主动驱动低阻），但功耗更高（开关瞬态功耗）</li></ul></li><li>单数据模式（SDR，I3C专用）12.5 Mbps<ul><li>单边沿触发器：SCL上升沿锁存SDA数据</li></ul></li><li>双数据模式（DDR，I3C专用）25 Mbps<ul><li>双边沿触发器：SCL上升沿/下降沿各锁存1 bit</li></ul></li></ul></li></ul><h3 id="数据结构"><a class="header-anchor" href="#数据结构">¶</a>数据结构</h3><ul><li>CCI数据传输协议遵循I2C规范，其读写结构如下图所示</li></ul><p><img src="/images/image-20250711170045936.png" alt="image-20250711170045936"></p><p><img src="/images/image-20250711170100702.png" alt="image-20250711170100702"></p><h2 id="CSI-2接口模型"><a class="header-anchor" href="#CSI-2接口模型">¶</a>CSI-2接口模型</h2><ul><li>CSI-2规范定义了发送端和接收端的协议和控制接口CCI，可选择D-PHY或C-PHY物理层作为高速串行数据的传输接口选项</li><li>C-PHY和D-PHY在物理连接上存在多处不同，主从机必须使用同一种物理层<ul><li>C-PHY具备更高的传输速率，但只支持CSI-2</li><li>D-PHY同时支持CSI-2和DSI，具备更高兼容性</li></ul></li></ul><p><img src="/images/image-20250711170601360.png" alt="image-20250711170601360"></p><blockquote><p>一般情况下，对低于五百万像素的摄像头只需使用两对差分数据线，即两条数据通道</p></blockquote><h1>MIPI DSI</h1><ul><li>DSI协议栈从框架上来看和CSI类似，并且能够实现摄像头-处理器-屏幕的功能组合</li></ul><img src="/images/1646035937837020.png" alt="img" style="zoom: 80%;" /><h2 id="协议概述-v2"><a class="header-anchor" href="#协议概述-v2">¶</a>协议概述<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></h2><p><img src="/images/image-20250711174305103.png" alt="image-20250711174305103"></p><ul><li>DSI 定义了主机处理器与显示外设之间传输图像和指令的接口协议</li><li>它采用了MIPI 联盟已有的 DPI-2、DBI-2 定义的像素格式，和 DCS 定义的命令集标准</li></ul><blockquote><ul><li>DPI-2 (Display Pixel Interface 2)<ul><li>显示控制器（Source）到显示面板（Sink）的并行像素流格式协议</li><li>用于直连型显示驱动，无需帧缓存，如MCU直接驱动LCD屏</li></ul></li><li>DBI-2 (Display Bus Interface 2)<ul><li>基于显示缓存的命令/数据总线协议，具备两种操作模式<ul><li>Command Mode：发送配置命令，如初始化序列</li><li>Video Mode：写入帧缓存数据，像素刷新</li></ul></li><li>面板内置帧存，如手机AMOLED屏</li></ul></li><li>DCS (Display Command Set)<ul><li>显示面板的初始化与控制指令集协议，适用于DBI-2/DSI接口</li><li>统一不同面板厂商的驱动代码</li></ul></li></ul></blockquote><h2 id="框架模型"><a class="header-anchor" href="#框架模型">¶</a>框架模型</h2><ul><li>DSI的框架与CSI类似，同样分为了应用层、协议层和物理层</li></ul><p><img src="/images/image-20250711174126995.png" alt="image-20250711174126995"></p><h2 id="DCS命令集简介"><a class="header-anchor" href="#DCS命令集简介">¶</a>DCS命令集简介</h2><ul><li>DCS是用于实现DSI和DBI-2协议的命令集<ul><li>主机处理器通过向显示模块发送命令，可以写入图像数据、配置显示模块工作状态或读取显示状态和数据</li><li>在显示端，显示控制器接收并解析命令，根据命令执行相应的操作</li></ul></li><li>DCS命令按照类型可以分短命令和长命令，前者不包含或只包含一个参数，后者包含多个参数</li><li>按照功能可分为制造商命令集和用户命令集<ul><li>制造商命令集是一种设备相关的协议，用于为出厂设备写入默认参数，设备配置完成出厂后，该命令集应被禁止，显示设备不再响应此命令集的命令</li><li>用户命令集是一种设备无关的协议，用于操作系统的硬件抽象层，下图位常用DCS用户命令集</li></ul></li></ul><p><img src="/images/image-20250711174737174.png" alt="image-20250711174737174"></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://github.com/DRubioG/MIPI_Specification#">MIPI Specs</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>陈锐弦.基于FPGA和MIPI CSI-2的双摄像头图像采集系统设计[D].西安电子科技大学,2021. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>张豪.基于FPGA的MIPI-DSI发送接口设计与实现[D].华中科技大学,2019. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 知识储备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIPI </tag>
            
            <tag> CSI-2 </tag>
            
            <tag> DSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Blog搭建</title>
      <link href="/Blog%E6%90%AD%E5%BB%BA/"/>
      <url>/Blog%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1>Git-GitHub</h1><h2 id="安装Git"><a class="header-anchor" href="#安装Git">¶</a>安装Git</h2><ul><li><p>简介</p><ul><li>Git 是分布式版本控制工具，核心价值在于高效管理代码变更、支持离线协作与灵活分支策略</li><li>对比集中式系统（如 SVN），安全性更高（本地即备份）且协作更灵活</li></ul></li><li><p>下载</p><ul><li><a href="https://git-scm.com/downloads/win">Download</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li></ul></li></ul><h2 id="绑定GitHub"><a class="header-anchor" href="#绑定GitHub">¶</a>绑定GitHub</h2><ul><li>利用SSH来完成GitHub的绑定并提交文件</li><li>SSH专为会话和其他网络服务提供安全性的协议，加密压缩数据、加快传输速度<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></li></ul><h3 id="SSH密钥"><a class="header-anchor" href="#SSH密钥">¶</a>SSH密钥</h3><ul><li><p>右键打开Git Bash，输入<code>ssh</code>查看本机是否安装SSH</p></li><li><p>输入<code>ssh-keygen -t rsa</code>生成<code>RSA</code>算法公钥和私钥，若成功则打印公钥指纹</p></li></ul><img src="/images/image-20250709141654216.png" alt="image-20250709141654216" style="zoom:50%;" /><blockquote><p>公钥指纹是公钥的哈希值，用于快速验证服务器身份</p></blockquote><h3 id="绑定GitHub-v2"><a class="header-anchor" href="#绑定GitHub-v2">¶</a>绑定GitHub</h3><ul><li>Git Bash中输入<code>cat ~/.ssh/id_rsa.pub</code>打印并复制公钥</li><li>登录 GitHub → Settings → <strong>SSH and GPG Keys</strong> → New SSH Key</li><li>Git Bash中输入<code>ssh -T git@github.com</code>，若打印信息<code>You've successfully authenticated</code>则绑定成功</li></ul><h2 id="Git仓库"><a class="header-anchor" href="#Git仓库">¶</a>Git仓库</h2><h3 id="本地下载"><a class="header-anchor" href="#本地下载">¶</a>本地下载</h3><ul><li>进入GitHub仓库复制HTTPS协议或SSH协议的下载链接</li></ul><img src="/images/image-20250709141636991.png" alt="image-20250709141636991" style="zoom: 33%;" /><ul><li>Git Bash中输入<code>git clone &lt;url&gt;</code>，获取远程仓库到本地仓库（工作区）<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></li></ul><img src="/images/image-20250709142631646.png" alt="image-20250709142631646" style="zoom: 50%;" /><ul><li>在<code>git clone &lt;url&gt;</code>中集成了多步操作<ul><li>本地新建远程仓库目录</li><li>初始化仓库：<code>git init</code></li><li>添加远程地址：<code>git remote add origin &lt;url&gt;</code></li><li>获取远程数据：<code>git fetch origin</code></li><li>自动检出默认分支：<code>git checkout main</code></li></ul></li></ul><blockquote><p>分支操作<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><ul><li>检出默认分支：自动设置默认分支（Branch）为当前工作主线，其他分支隐藏</li><li>clone时所有分支均会被下载，默认分支一般被命名为main或者master</li><li>新建分支一般用于新功能开发、修复bug或多人协作，避免直接在主线上进行修改</li></ul></blockquote><h3 id="文件追踪"><a class="header-anchor" href="#文件追踪">¶</a>文件追踪</h3><ul><li>进入工作区新建文件后，可使用<code>git status</code>查看仓库状态</li><li>使用<code>git add &lt;file&gt;</code>或<code>git add -A</code>将未被追踪的文件添加到临时缓冲区</li></ul><img src="/images/image-20250709142821701.png" alt="image-20250709142821701" style="zoom:50%;" /><blockquote><p>使用<code>git rm -cached &lt;file&gt;</code>移除追踪但保留文件</p></blockquote><h3 id="提交变更"><a class="header-anchor" href="#提交变更">¶</a>提交变更</h3><ul><li>使用<code>git commit -am &quot;msg of update&quot;</code>将修改提交至本地仓库<ul><li>此操作会更新本地.git目录，是上传远程前的必要步骤</li><li>完成后可使用<code>git log</code>查看本次更新的提交信息及哈希值</li></ul></li><li>使用<code>git push origin main</code>将本地仓库提交至远程仓库<ul><li>origin是远程主机的名字</li><li>main是默认分支</li></ul></li></ul><img src="/images/image-20250709142916006.png" alt="image-20250709142916006" style="zoom:50%;" /><blockquote><p>首次提交需添加邮箱信息，后续修改邮箱信息也可使用以下命令</p><ul><li><code>git config --global user.email &quot;your@email.com&quot;</code></li><li><code>git config --global user.email &quot;your name&quot;</code></li></ul></blockquote><h1>Hexo框架</h1><h2 id="安装node-js"><a class="header-anchor" href="#安装node-js">¶</a>安装node.js</h2><blockquote><p>Node.js 是一个开源的、跨平台的 <strong>JavaScript 运行时环境</strong>，用于在服务器端执行 JavaScript 代码</p></blockquote><ul><li>下载<a href="https://nodejs.org/en/">node.js</a><sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup></li><li>在命令行中使用<code>node -v</code>和<code>npm -v</code>检查是否成功安装</li></ul><p><img src="/images/image-20250709142934524.png" alt="image-20250709142934524"></p><h2 id="Hexo部署"><a class="header-anchor" href="#Hexo部署">¶</a>Hexo部署</h2><blockquote><p>Hexo 是一个基于 Node.js 的静态博客框架， 能够将Markdown 文档快速渲染成静态的 HTML 网页<sup class="footnote-ref"><a href="#fn6" id="fnref6">[6]</a></sup></p></blockquote><h3 id="本地部署"><a class="header-anchor" href="#本地部署">¶</a>本地部署</h3><ul><li>在目标位置打开Git Bash，使用<code>npm install -g hexo-cli</code>安装Hexo<ul><li>输入<code>hexo init</code>初始化博客</li><li>输入<code>hexo g</code>静态部署（hexo generate）</li><li>输入<code>hexo s</code>开始进程（hexo server）</li></ul></li></ul><p><img src="/images/image-20250709143108331.png" alt="image-20250709143108331"></p><ul><li>打开网页 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看，Git Bash中使用<code>ctrl</code>+<code>c</code>停止运行</li></ul><img src="/images/image-20250709143123112.png" alt="image-20250709143123112" style="zoom:50%;" /><h3 id="GitHub部署"><a class="header-anchor" href="#GitHub部署">¶</a>GitHub部署</h3><ul><li>创建一个.github.io的仓库</li></ul><img src="/images/image-20250709143245133.png" alt="image-20250709143245133" style="zoom:50%;" /><ul><li>编辑Blog中的_config.yml文件，添加GitHub部署地址</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:arvinhwo/arvinhwo.github.io.git</span>  <span class="comment"># your url</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><ul><li><p>输入<code>npm install hexo -deployer-git --save</code>安装Git插件</p><ul><li>输入<code>hexo clean</code>清除缓存文件db.json和静态文件public</li><li>输入<code>hexo g</code>生成网站静态文文件</li><li>输入<code>hexo d</code>部署到指定仓库（hexo deploy）</li></ul></li><li><p>部署完成后，打开网页 <a href="https://arvinhwo.github.io/">https://arvinhwo.github.io/</a> 查看</p></li></ul><h3 id="解析域名"><a class="header-anchor" href="#解析域名">¶</a>解析域名</h3><ul><li>使用<code>ping your.github.io -4</code>获取GitHub服务器的IPV4地址</li></ul><img src="/images/image-20250709143406082.png" alt="image-20250709143406082" style="zoom:67%;" /><ul><li>在已购域名的控制台中添加github.io的解析记录，经CDN服务商加速访问</li></ul><img src="/images/image-20250709143416072.png" alt="image-20250709143416072" style="zoom: 67%;" /><ul><li><p>在Blog\source路径中添加CNAME文件，存入域名arvinhwo.com后，依次以下命令重新部署</p><ul><li><code>hexo clean</code></li><li><code>hexo g</code></li><li><code>hexo d</code></li></ul></li><li><p>打开GitHub检查CNAME是否被正确设置</p></li><li><p>浏览器输入域名 <a href="http://arvinhwo.com">arvinhwo.com</a> 进入</p></li></ul><h3 id="草稿发布"><a class="header-anchor" href="#草稿发布">¶</a>草稿发布</h3><ul><li>建立文章草稿<code>hexo new draft &lt;filename&gt;</code><ul><li>将新文章建立在source/_drafts目录</li><li><code>hexo generate</code>不编译到public目录下</li><li><code>hexo deploy</code>也不部署到GitHub中</li></ul></li><li>本机预览草稿<code>hexo s --draft</code><ul><li>不影响再次<code>hexo s</code>生成的预览内容</li></ul></li><li>草稿发表<code>hexo p &lt;filename&gt;</code><ul><li>将文章从source/draft移动到source/posts</li></ul></li></ul><h2 id="NEXT主题"><a class="header-anchor" href="#NEXT主题">¶</a>NEXT主题<sup class="footnote-ref"><a href="#fn7" id="fnref7">[7]</a></sup></h2><h3 id="菜单设置"><a class="header-anchor" href="#菜单设置">¶</a>菜单设置</h3><ul><li>打开themes/next目录下的主题配置文_config.yml，查找menu</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span> <span class="comment">#||前面是目标连接，后面是图标名称</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span> <span class="comment">#首页</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user#关于</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span><span class="comment">#标签</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span><span class="comment">#分类</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span><span class="comment">#归档</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar#日历</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap#站点地图，供搜索引擎爬取</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat#公益404</span></span><br></pre></td></tr></table></figure><ul><li>根目录下使用命令在source中建立文件夹<ul><li><code>hexo new page &quot;categories&quot;</code></li><li><code>hexo new page &quot;tags&quot;</code></li></ul></li><li>修改所生成文件夹中的index.md文件自定义标题</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2025-07-09 11:44:14</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h3 id="头像图标"><a class="header-anchor" href="#头像图标">¶</a>头像图标</h3><ul><li>在主题配置文件中搜索avatar设置头像</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="comment"># Replace the default image and set the url here.</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/A.png</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be dispalyed in circle.</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># If true, the avatar will be rotated with the cursor.</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><ul><li>搜索favicon设置图标，<a href="https://www.iconfont.cn/">图标素材网站</a></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-A.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-A.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/favicon-A.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure><h3 id="版权说明"><a class="header-anchor" href="#版权说明">¶</a>版权说明</h3><ul><li>在主题配置文件中查找creative_commons选择协议</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">language:</span> <span class="string">deed.zh</span></span><br></pre></td></tr></table></figure><ul><li>也可在页脚配置文件 themes\next\layout_partial\footer.swig中添加</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;copyright&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">p</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">span</span>&gt;版权声明：本博客采用&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">a</span> href=&quot;https://creativecommons.org/licenses/by-nc-sa/<span class="number">4.0</span>/<span class="string">&quot; target=&quot;</span>_blank<span class="string">&quot; rel=&quot;</span>noopener<span class="string">&quot;&gt;BY-NC-SA 4.0&lt;/a&gt;</span></span><br><span class="line"><span class="string">    &lt;span&gt;许可协议。&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/p&gt;</span></span><br></pre></td></tr></table></figure><h3 id="博文置顶"><a class="header-anchor" href="#博文置顶">¶</a>博文置顶</h3><ul><li>重新安装插件<ul><li><code>npm r hexo-generator-index</code></li><li><code>npm i hexo-generator-index-pin-top --S</code></li></ul></li><li>在博文的YAML中添加<code>top: true</code></li><li>编辑themes/next/layout/_macro/post.swig，定位到&quot;post-meta&quot;，插入如下代码</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;post-meta&quot;&gt;</span><br><span class="line">&#123;% if post<span class="selector-class">.top</span> %&#125;</span><br><span class="line">&lt;<span class="selector-tag">i</span> class=&quot;fa fa-thumb-tack&quot;&gt;&lt;/<span class="selector-tag">i</span>&gt;</span><br><span class="line">    &lt;<span class="attribute">font</span> <span class="attribute">color</span>=<span class="number">7</span>D26CD&gt;置顶&lt;/<span class="attribute">font</span>&gt;</span><br><span class="line">    &lt;<span class="selector-tag">span</span> class=&quot;post-meta-divider&quot;&gt;|&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure><h3 id="文章字数"><a class="header-anchor" href="#文章字数">¶</a>文章字数</h3><ul><li>Blog根目录使用Git Bash执行<code>npm install hexo-wordcount --save</code></li><li>编辑站点配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">symbols_count_time:</span></span><br><span class="line">  <span class="attr">symbols:</span> <span class="literal">true</span>                <span class="comment"># 文章字数统计</span></span><br><span class="line">  <span class="attr">time:</span> <span class="literal">true</span>                   <span class="comment"># 文章阅读时长</span></span><br><span class="line">  <span class="attr">total_symbols:</span> <span class="literal">true</span>          <span class="comment"># 站点总字数统计</span></span><br><span class="line">  <span class="attr">total_time:</span> <span class="literal">true</span>             <span class="comment"># 站点总阅读时长</span></span><br><span class="line">  <span class="attr">exclude_codeblock:</span> <span class="literal">false</span>     <span class="comment"># 排除代码字数统计</span></span><br></pre></td></tr></table></figure><ul><li>若需统计站点文章总字数，在/themes/next/layout/_partials/footer.swig文件尾部加上</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;theme-info&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">div</span> class=&quot;powered-by&quot;&gt;&lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">  &lt;<span class="selector-tag">span</span> class=&quot;post-count&quot;&gt;博客全站共&#123;&#123; totalcount(site) &#125;&#125;字&lt;/<span class="selector-tag">span</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><h3 id="浏览进度"><a class="header-anchor" href="#浏览进度">¶</a>浏览进度</h3><ul><li>直接修改主题配置文件_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h3 id="代码块渲染"><a class="header-anchor" href="#代码块渲染">¶</a>代码块渲染</h3><ul><li>对于高版本的next可以直接修改主题配置文件_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># Available values: normal | night | night eighties | night blue | night bright | solarized | solarized dark | galactic</span></span><br><span class="line">  <span class="comment"># See: https://github.com/chriskempson/tomorrow-theme</span></span><br><span class="line">  <span class="attr">highlight_theme:</span> <span class="string">night</span> <span class="string">bright</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Show text copy result.</span></span><br><span class="line">    <span class="attr">show_result:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br></pre></td></tr></table></figure><ul><li>对于低版本的next，可以在主题根目录下的source\css\main.styl的末尾添加</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">.highlight</span></span><br><span class="line">    <span class="string">background:rgb(4,</span> <span class="number">4</span><span class="string">,</span> <span class="number">4</span><span class="string">)</span></span><br><span class="line">    <span class="attr">border-radius:</span> <span class="string">5px</span></span><br><span class="line">    <span class="attr">box-shadow:</span> <span class="number">0</span> <span class="string">10px</span> <span class="string">30px</span> <span class="number">0</span> <span class="string">rgba(0,</span> <span class="number">0</span><span class="string">,</span> <span class="number">0</span><span class="string">,</span> <span class="number">.4</span><span class="string">)</span></span><br><span class="line">    <span class="attr">padding-top:</span> <span class="string">30px</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&amp;::before</span></span><br><span class="line">      <span class="attr">background:</span> <span class="comment">#fc625d</span></span><br><span class="line">      <span class="attr">border-radius:</span> <span class="number">50</span><span class="string">%</span></span><br><span class="line">      <span class="attr">box-shadow:</span> <span class="string">20px</span> <span class="number">0</span> <span class="comment">#fdbc40, 40px 0 #35cd4b</span></span><br><span class="line">      <span class="attr">content:</span> <span class="string">&#x27; &#x27;</span></span><br><span class="line">      <span class="attr">height:</span> <span class="string">12px</span></span><br><span class="line">      <span class="attr">left:</span> <span class="string">12px</span></span><br><span class="line">      <span class="attr">margin-top:</span> <span class="string">-20px</span></span><br><span class="line">      <span class="attr">position:</span> <span class="string">absolute</span></span><br><span class="line">      <span class="attr">width:</span> <span class="string">12px</span></span><br></pre></td></tr></table></figure><h2 id="站点配置"><a class="header-anchor" href="#站点配置">¶</a>站点配置</h2><blockquote><p>使用Typora作为文本编辑器，参见本站文章<a href="../Typora%E6%8A%80%E5%B7%A7">Typora技巧</a></p></blockquote><h3 id="引用文章"><a class="header-anchor" href="#引用文章">¶</a>引用文章</h3><ul><li>在Hexo渲染出的网页中引用已发布的文章，首先修改站点配置文件_config.yml中的permalink</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://arvinhwo.com</span></span><br><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br></pre></td></tr></table></figure><ul><li>Typora引用使用<code>[titile](../filename_without.md)</code>的Markdown代码</li></ul><h3 id="引用图片"><a class="header-anchor" href="#引用图片">¶</a>引用图片</h3><ul><li>在blog/source/路径下新建images文件夹，.md文件放入默认位置blog/source/_posts/</li><li>将Typora-格式-设置图片根目录设置为source，体现在文章的YAML中即为<code>typora-root-url: ./..</code></li><li>将Typora-偏好设置-图片设置如下</li></ul><img src="/images/image-20250709150435441.png" alt="image-20250709150435441" style="zoom: 33%;" /><ul><li>此后Typora中和Hexo渲染均可正确显示图片</li></ul><blockquote><p>由于Gitee不允许个人使用仓库当作图床使用，也可改用GitHub图床<sup class="footnote-ref"><a href="#fn8" id="fnref8">[8]</a></sup>，若使用GitHub作为图床同样需要CDN加速</p></blockquote><ul><li>由于不适用和文件同名的文件夹用于存储文件，可以关闭站点配置文件中的<code>post_asset_floder: false</code>，这样在使用<code>hexo new</code>、<code>hexo new draft</code>和<code>hexo p</code>命令时，不再自动生成同名文件夹</li></ul><h3 id="添加脚注"><a class="header-anchor" href="#添加脚注">¶</a>添加脚注</h3><ul><li>Hexo无法渲染Typora中的脚注，因此使用插件解决<ul><li>卸载原渲染插件<code>npm un hexo-renderer-marked --save</code></li><li>安装GitHub风格渲染插件<code>npm i hexo-renderer-markdown-it --save</code></li><li>修改站点配置文件_config.yml</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Markdown-it config</span></span><br><span class="line"><span class="comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="comment"># 渲染设置</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="comment"># 置为true时，html内容保持不变；置为false时，html内容将被转义成普通字符串</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否生成与XHTML完全兼容的标签（虽然我不懂是什么意思）</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 置为true时，每个换行符都被渲染成一个&lt;br&gt;（即Hexo的默认表现）；置为false时，只有空行才会被渲染为&lt;br&gt;（GFM的默认表现）</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别链接并把它渲染成链接</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别印刷格式（意思是把(c)渲染为©这样的）</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 如果typographer被设置为true，则该选项用于设置将dumb quotes（&quot;&quot;）自动替换为smart quotes</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="comment"># 设置所需插件</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">  <span class="comment"># 锚点设置</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;v&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br></pre></td></tr></table></figure><h3 id="任务列表"><a class="header-anchor" href="#任务列表">¶</a>任务列表</h3><ul><li>安装GitHub风格渲染插件<code>npm install hexo-renderer-markdown-it --save</code></li><li>安装缺失依赖项<code>npm install markdown-it-task-lists --save</code></li><li>编辑站点配置配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-task-lists</span>  <span class="comment"># 启用任务列表插件</span></span><br></pre></td></tr></table></figure><h3 id="公式渲染"><a class="header-anchor" href="#公式渲染">¶</a>公式渲染</h3><ul><li>Hexo无法渲染Typora中的公式块，因此安装插件<code>npm install hexo-filter-mathjax --save</code></li><li>配置站点配置文件_config.yml</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">mathjax:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># See: https://mhchem.github.io/MathJax-mhchem/</span></span><br><span class="line">    <span class="attr">mhchem:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h3 id="标题编号"><a class="header-anchor" href="#标题编号">¶</a>标题编号</h3><ul><li>对于Hexo-NEXT渲染的html文件，默认为TOC标题自动添加编号，但是缺少对正文标题编号的自动添加，可在 themes\next\source\css\main.styl 的末尾添加</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-block</span> &#123;</span><br><span class="line">  <span class="selector-class">.post-body</span> &#123;<span class="attribute">counter-reset</span>: h1&#125;</span><br><span class="line">          <span class="selector-tag">h1</span> &#123;<span class="attribute">counter-reset</span>: h2&#125;</span><br><span class="line">          <span class="selector-tag">h2</span> &#123;<span class="attribute">counter-reset</span>: h3&#125;</span><br><span class="line">          <span class="selector-tag">h3</span> &#123;<span class="attribute">counter-reset</span>: h4&#125;</span><br><span class="line">          <span class="selector-tag">h4</span> &#123;<span class="attribute">counter-reset</span>: h5&#125;</span><br><span class="line">          <span class="selector-tag">h5</span> &#123;<span class="attribute">counter-reset</span>: h6&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-body</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h1; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h2; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h3</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h3; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h4</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h4; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h5</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h5; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h6</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h6; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h6) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/103325381">Git安装教程</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://blog.csdn.net/qq_35246620/article/details/54317740">SSH的原理及其应用</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/87732909">常用git命令</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://www.runoob.com/git/git-branch.html">Git分支管理</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://blog.csdn.net/antma/article/details/86104068">node.js安装步骤</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li><li id="fn6" class="footnote-item"><p><a href="https://hexo.io/docs/">Hexo使用文档</a> <a href="#fnref6" class="footnote-backref">↩︎</a></p></li><li id="fn7" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/106060640">NEXT优化1</a>；<a href="https://choubin.site/2019/12/30/CustomBlogTheme/">NEXT优化2</a> <a href="#fnref7" class="footnote-backref">↩︎</a></p></li><li id="fn8" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/138012354">Blog使用GitHub图床</a> <a href="#fnref8" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 环境部署 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> Hexo </tag>
            
            <tag> Next </tag>
            
            <tag> Typora </tag>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora技巧</title>
      <link href="/Typora%E6%8A%80%E5%B7%A7/"/>
      <url>/Typora%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1>Typora技巧</h1><h2 id="编辑"><a class="header-anchor" href="#编辑">¶</a>编辑</h2><ul><li>撤销：<code>ctrl</code>+<code>z</code></li><li>取消撤销：<code>ctrl</code>+<code>y</code></li><li>跳转至光标位置：<code>ctrl</code>+<code>j</code></li><li>跳转至顶部：<code>ctrl</code>+<code>home</code></li><li>跳转至底部：<code>ctrl</code>+<code>end</code></li><li>替代：<code>ctrl</code>+<code>h</code></li><li>查找下一个：<code>enter</code></li><li>查找上一个：<code>shift</code>+<code>enter</code></li><li>选择词：<code>ctrl</code>+<code>d</code></li><li>删除词：<code>ctrl</code>+<code>shift</code>+<code>d</code></li><li>选择行(表格中)/句子(句号或回车)：<code>ctrl</code>+<code>l</code></li><li>删除行(表格中)：<code>ctrl</code>+<code>shift</code>+<code>backspace</code></li><li>选择表格中单元格/段落中同格式：<code>ctrl</code>+<code>e</code></li></ul><h2 id="格式"><a class="header-anchor" href="#格式">¶</a>格式</h2><ul><li><strong>加粗</strong>：快捷键<code>ctrl</code>+<code>b</code><br>源代码：<code>**strong**</code></li><li><em>斜体</em>：快捷键<code>ctrl</code>+<code>i</code><br>源代码：<code>*emphasis*</code></li><li><u>下划线</u>：快捷键<code>ctrl</code>+<code>u</code></li><li><s>删除线</s>：快捷键<code>alt</code>+<code>shift</code>+<code>5</code></li><li><code>代码</code>：快捷键<code>ctrl</code>+<code>shift</code>+<code>反单引号</code><br>源代码：<code>反单引号 code 反单引号</code></li></ul><blockquote><p>以上格式均支持先快捷键后输入文本，及先输入文件后快捷键</p></blockquote><h2 id="标题"><a class="header-anchor" href="#标题">¶</a>标题</h2><ul><li>设置标题：<code>ctrl</code>+<code>1~6</code><br>源代码：<code>#</code>+<code>Space</code>+Heading</li><li>标题升级：<code>ctrl</code>+<code>=</code></li><li>标题降级：<code>ctrl</code>+<code>-</code></li><li>取消标题：<code>ctrl</code>+<code>0</code></li></ul><h2 id="段落"><a class="header-anchor" href="#段落">¶</a>段落</h2><ul><li>新段落：<code>enter</code></li><li>同段落新行：<code>shift</code>+<code>enter</code></li><li>缩进：<code>ctrl</code>+<code>[</code> 或 <code>tab</code></li><li>减少缩进：<code>ctrl</code>+<code>]</code> 或 <code>shift</code>+ <code>tab</code></li></ul><h2 id="列表"><a class="header-anchor" href="#列表">¶</a>列表</h2><h3 id="无序列表"><a class="header-anchor" href="#无序列表">¶</a>无序列表</h3><ul><li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>]</code><br>源代码：<code>*</code>/<code>+</code>/<code>-</code>+<code>Space </code>+ Paragraph</li><li>设置子列表等同缩进<br>取消子列表等同取消缩进</li></ul><blockquote><p>无序列表示例：</p><ul><li>段落1 (Enter)</li><li>段落2行1 (Shift+Enter)<br>段落2行2</li><li>段落3<ul><li>子列表段落1</li></ul></li></ul></blockquote><h3 id="有序列表"><a class="header-anchor" href="#有序列表">¶</a>有序列表</h3><ul><li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>[</code><br>源代码：<code>1.</code> +<code>Space </code>+ Paragraph</li></ul><blockquote><p>有序列表示例：</p><ol><li>有序段落1<ol><li>有序段落1.1<ol><li>有序段落1.1.1</li></ol></li></ol></li></ol></blockquote><h3 id="任务列表"><a class="header-anchor" href="#任务列表">¶</a>任务列表</h3><ul><li>任务列表：<code>ctrl</code>+<code>shift</code>+<code>x</code></li></ul><blockquote><p>任务列表示例：</p><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 任务1</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 任务2</li></ul></blockquote><h2 id="功能"><a class="header-anchor" href="#功能">¶</a>功能</h2><h3 id="区块"><a class="header-anchor" href="#区块">¶</a>区块</h3><ul><li>段落引用：<code>ctrl</code>+<code>shift</code>+<code>Q</code><br>源代码：<code>&gt;</code>+<code>Space</code></li><li>取消引用等同取消缩进</li></ul><blockquote><p>引用区块示例，用于进一步解释段落中的内容</p></blockquote><h3 id="链接"><a class="header-anchor" href="#链接">¶</a>链接</h3><ul><li>将链接复制入剪切板后：<code>ctrl</code>+<code>k</code><br>源代码：<code>[titile](url)</code> or <code>[titile](#handing)</code></li></ul><blockquote><p>示例：<br>网页跳转：<a href="https://support.typora.io/Shortcut-Keys/#change-shortcut-keys">Typora快捷键</a><br>文内跳转：标题-<a href="#%E7%BC%96%E8%BE%91">编译</a><br>本地文件跳转同理</p></blockquote><ul><li>此外，提供另一种显示链接的方法，便于集中管理所有链接：<ul><li>源代码：<code>[titile][]</code></li><li>UI界面：段落-&gt;链接引用，再补全<code>[titile]:link url &quot;optional&quot;</code></li></ul></li></ul><blockquote><p><a href="https://blog.csdn.net/he_nan/article/details/105850141" title="网页名称可选">链接测试</a></p></blockquote><h3 id="脚注"><a class="header-anchor" href="#脚注">¶</a>脚注</h3><ul><li>脚标源代码：<code>[^1]</code></li><li>脚注代码：<code>[^1]:脚注</code><br>脚注UI：段落-&gt;脚注</li></ul><blockquote><p>示例：<br>使用脚注对于正文扩展进行说明<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><br>在Typora的编辑中，可将脚标与脚注放在一起<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p></blockquote><ul><li>自定义快捷键<ul><li>打开文件-偏好设置-通用-高级设置</li><li>配置conf.user.json文件，配置以下快捷键</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;keyBinding&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Footnotes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ctrl+Shift+P&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="代码"><a class="header-anchor" href="#代码">¶</a>代码</h3><ul><li>段落内代码<br>快捷键：<code>ctrl</code>+<code>shift</code>+<code>反单引号</code><br>源代码：<code>反单引号 code 反单引号</code></li><li>代码块<br>快捷键：<code>ctrl</code>+<code>shift</code>+<code>k</code><br>源代码：<code>三反单引号 code block 三反单引号</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyperclip</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageGrab</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image_to_base64</span>(<span class="params">image</span>):</span><br><span class="line">    buffered = io.BytesIO()</span><br><span class="line">    image.save(buffered, <span class="built_in">format</span>=<span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(buffered.getvalue()).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image = ImageGrab.grabclipboard()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(image, Image.Image):</span><br><span class="line">            base64_image = image_to_base64(image)</span><br><span class="line">            pyperclip.copy(<span class="string">f&quot;![image](data:image/png;base64,<span class="subst">&#123;base64_image&#125;</span>)\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;图像已转换为Base64并复制&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        raw_path = pyperclip.paste().strip(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">        file_path = os.path.normpath(raw_path)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(file_path):</span><br><span class="line">            <span class="keyword">with</span> Image.<span class="built_in">open</span>(file_path) <span class="keyword">as</span> img:</span><br><span class="line">                base64_image = image_to_base64(img)</span><br><span class="line">            pyperclip.copy(<span class="string">f&quot;![image](data:image/png;base64,<span class="subst">&#123;base64_image&#125;</span>)\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;文件图像已转换为Base64并复制&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;剪切板无有效图像或文件&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="公式"><a class="header-anchor" href="#公式">¶</a>公式</h3><ul><li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>m</code><br>源代码：<code>$$math bock$$</code></li></ul><blockquote><p>公式示例-薛定谔方程（一维定态）</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>&gt;</mo><mo>−</mo><mfrac><msup><mi mathvariant="normal">ℏ</mi><mn>2</mn></msup><mrow><mn>2</mn><mi>m</mi></mrow></mfrac><mfrac><mrow><msup><mi>d</mi><mn>2</mn></msup><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>d</mi><msup><mi>x</mi><mn>2</mn></msup></mrow></mfrac><mo>+</mo><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>&gt;</mo></mrow><annotation encoding="application/x-tex">&gt; -\frac{\hbar^2}{2m}\frac{d^2\psi(x)}{dx^2} + V(x)\psi(x) = E\psi(x)&gt; </annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.1771em;vertical-align:-0.686em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">ℏ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">&gt;</span></span></span></span></span></blockquote><h3 id="图片"><a class="header-anchor" href="#图片">¶</a>图片</h3><ul><li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>i</code>或复制后直接<code>ctrl</code>+<code>v</code><br>源代码：<code>![titile](url/localpath)</code></li></ul><img src="/images/image-20250709141106758.png" alt="image-20250709141106758" style="zoom: 33%;" /><ul><li>设置本地图片副本存储位置</li><li>使用PicGo图床上传，在Gitee保存图片副本<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><ul><li>安装<a href="https://nodejs.org/en/">Node.js</a></li><li>注册<a href="https://gitee.com/">Gitee</a></li><li>新建开源Gitee<a href="https://gitee.com/arvinhwo/typoraimage">仓库</a></li><li>生成Gitee<a href="D:%5CDocument%5CPassword.txt">私人令牌</a></li><li>在Typora中下载<a href="C:%5CUsers%5Carvin%5CAppData%5CRoaming%5CTypora%5Cpicgo">PicGo-Core</a></li><li>打开配置文件</li><li>验证图片上传选项</li></ul></li><li>点击格式-图像-上传所有本地图片批量上传</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;gitee&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;仓库地址（不带gitee的域名）&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee 私人令牌 必填&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义存储路径，可以不填&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;域名，没有可以不填&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;分支名，默认是 master&quot;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDDHHmmss&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><img src="/images/image-20250709142115308.png" alt="image-20250709142115308" style="zoom:50%;" /><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>脚注可用于解释英文缩略词等 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>脚注在导出HTML中会按顺序在文末 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://juejin.cn/post/7089308017266524197">PicGo-Gitee参考教程</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
            <tag> Blog </tag>
            
            <tag> PicGo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
