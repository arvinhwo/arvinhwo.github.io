<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>LFSR原理</title>
      <link href="/LFSR%E5%8E%9F%E7%90%86/"/>
      <url>/LFSR%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="定义">定义</h1><ul><li>线性反馈移位寄存器（Linear Feedback Shift Register，LFSR），其运算是确定的，所以，由寄存器所生成的数据流完全决定于寄存器当时或者之前的状态<ul><li>种子：赋给 LFSR 的初始值</li><li>抽头：影响 LFSR 下一个状态的比特位</li></ul></li></ul><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msub><mi>g</mi><mi>n</mi></msub><msup><mi>x</mi><mi>n</mi></msup><mo>+</mo><msub><mi>g</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><msup><mi>x</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msup><mo>+</mo><mo>⋯</mo><mo>+</mo><msub><mi>g</mi><mn>1</mn></msub><mi>x</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x) = g_n x^n + g_{n-1} x^{n-1} + \cdots + g_1 x + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.9088em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1514em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1.0724em;vertical-align:-0.2083em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8641em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6667em;vertical-align:-0.0833em;"></span><span class="minner">⋯</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.7778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span></span><ul><li>本源多项式：决定了线性移位寄存器的反馈结构<ul><li>反馈系数 g_i 可以为0或1，但g_n和g_0只能为1</li><li>因为当 g_i 为0时表示不存在该反馈路径</li></ul></li><li>逻辑运算：异或、同或<ul><li>使用异或门的 LFSR 全<code>0</code>状态下为无效状态</li><li>使用同或门的 LFSR 全<code>1</code>状态下为无效状态</li><li>不管是异或还是同或，都需避免选择全<code>0</code>或全<code>1</code>的种子，避免 LFSR 进入死循环</li></ul></li><li>抽头序列：选取的某些位构成的序列<ul><li>不同的抽头序列对应不同的本源多项式，产生不同的反馈路径</li><li>抽头的位置会影响LSFR的输出状态的最大长度序列（Maximum Length Sequence, MLS）<ul><li>一个n bits的LFSR最多能输出<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>n</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^n-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.7477em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>种状态</li><li>能使LFSR拥有MLS的抽头序列不唯一</li></ul></li></ul></li></ul><p><img src="/images/d404df040093a43db7ce434e675b1fef.png" alt="img"></p><h1 id="分类">分类</h1><h2 id="外部型">外部型</h2><ul><li>Fibonacci LFSR：斐波那契（外部 LFSR），又称 many-to-one</li></ul><p><img src="/images/72ed10554a9bb553e9f70c6dc25bd607.jpeg" alt="img"></p><ul><li>下例是一个本源多项式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>16</mn></msup><mo>+</mo><msup><mi>x</mi><mn>14</mn></msup><mo>+</mo><msup><mi>x</mi><mn>13</mn></msup><mo>+</mo><msup><mi>x</mi><mn>11</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x) = x^{16} + x^{14} + x^{13} + x^{11} + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">16</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">14</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">13</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">11</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的 Fibonacci LFSR<ul><li>抽头序列是 <code>[16,14,13,11]</code></li><li>抽头依次与输出比特进行异或运算，然后反馈回最左端的位</li><li>LFSR 最右端的比特为输出比特，当前状态为<code>0x8735</code> ，下一个状态是<code>0x0E6A</code></li></ul></li></ul><p><img src="/images/LFSR-F16.gif" alt="img"></p><h2 id="内部型">内部型</h2><ul><li>Galois LFSR：伽罗瓦（内部LFSR），又称one-to-many</li></ul><p><img src="/images/8890b6add5570033b9bfe7a58502d40e.jpeg" alt="img"></p><ul><li>下例是一个本源多项式为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><msup><mi>x</mi><mn>3</mn></msup><mo>+</mo><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">f(x) = x^3 + x^2 + 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8974em;vertical-align:-0.0833em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span>的 Galois LFSR<ul><li>抽头序列为<code>[3，2]</code></li></ul></li></ul><img src="/images/0f083c2a50c9f10a25041923d8755d0e.png" alt="Image 1" style="zoom:50%;" /><ul><li>这个3位的LFSR的伪功能代码可以用C描述为</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lfsr3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> temp0, temp1, temp2;</span><br><span class="line">    temp0 = ff0; </span><br><span class="line">    temp1 = ff1; </span><br><span class="line">    temp2 = ff2; </span><br><span class="line">    ff0 = temp2;</span><br><span class="line">    ff1 = temp0 ^ (<span class="number">0</span> * temp2);</span><br><span class="line">    ff2 = temp1 ^ (<span class="number">1</span> * temp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从上述代码的状态转移图中可以发现7个状态组成一个循环，这也是3为LFSR所能达到的最多状态</li></ul><img src="/images/3938a2752887e8627ad11e36e1033478.png" alt="Image 2" style="zoom:50%;" /><h1 id="实例">实例</h1><ul><li>抽头序列为<code>[3,2]</code>的3级Fibonacci LFSR</li></ul><img src="/images/c7eb25dcea5e4ad6a000681a9db6b90a.png" alt="img" style="zoom: 150%;" /><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR3_D(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] LFSR = <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">1</span>] ^ LFSR[<span class="number">2</span>];</span><br><span class="line">        LFSR[<span class="number">2</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> <span class="number">100</span>   <span class="comment">// 种子为1</span></span><br><span class="line"><span class="number">1</span> <span class="number">010</span>   <span class="comment">// 2</span></span><br><span class="line"><span class="number">2</span> <span class="number">101</span>   <span class="comment">// 5</span></span><br><span class="line"><span class="number">3</span> <span class="number">110</span>   <span class="comment">// 3</span></span><br><span class="line"><span class="number">4</span> <span class="number">111</span>   <span class="comment">// 7</span></span><br><span class="line"><span class="number">5</span> <span class="number">011</span>   <span class="comment">// 6</span></span><br><span class="line"><span class="number">6</span> <span class="number">001</span>   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><ul><li>抽头序列为<code>[4，2]</code>的4级Fibonacci LFSR</li></ul><img src="/images/3a130ac32df24e40945909900fc4a463.png" alt="Image 2" style="zoom:150%;" /><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR4_15(</span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] LFSR = <span class="number">15</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">1</span>] ^ LFSR[<span class="number">3</span>];</span><br><span class="line">        LFSR[<span class="number">3</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fibonacci_LFSR4_15</span></span><br><span class="line"><span class="comment">// status hex sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> F <span class="number">1111</span></span><br><span class="line"><span class="number">1</span> E <span class="number">0111</span></span><br><span class="line"><span class="number">2</span> C <span class="number">0011</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span> <span class="number">1001</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1100</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">1110</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>抽头序列为<code>[4，1]</code>的4级Fibonacci LFSR</li></ul><img src="/images/e8f427dc46d94eaf8e9d2365f8b93996.png" alt="Image 1" style="zoom:150%;" /><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR4_13(</span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] LFSR = <span class="number">15</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">0</span>] ^ LFSR[<span class="number">3</span>];</span><br><span class="line">        LFSR[<span class="number">3</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fibonacci_LFSR4_13</span></span><br><span class="line"><span class="comment">// status hex sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> F <span class="number">1111</span></span><br><span class="line"><span class="number">1</span> E <span class="number">0111</span></span><br><span class="line"><span class="number">2</span> D <span class="number">1011</span></span><br><span class="line"><span class="number">3</span> A <span class="number">0101</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1010</span></span><br><span class="line"><span class="number">5</span> B <span class="number">1101</span></span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">0110</span></span><br><span class="line"><span class="number">7</span> C <span class="number">0011</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">1001</span></span><br><span class="line"><span class="number">9</span> <span class="number">2</span> <span class="number">0100</span></span><br><span class="line"><span class="number">10</span> <span class="number">4</span> <span class="number">0010</span></span><br><span class="line"><span class="number">11</span> <span class="number">8</span> <span class="number">0001</span></span><br><span class="line"><span class="number">12</span> <span class="number">1</span> <span class="number">1000</span></span><br><span class="line"><span class="number">13</span> <span class="number">3</span> <span class="number">1100</span></span><br><span class="line"><span class="number">14</span> <span class="number">7</span> <span class="number">1110</span></span><br></pre></td></tr></table></figure><ul><li>抽头序列为<code>[16,14,13,11]</code>的16级Fibonacci LFSR</li></ul><p><img src="/images/d6037e33c5464a3882290ec9fda84c70.png" alt="img"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR16_16801(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] LFSR = <span class="number">34613</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">10</span>] ^ LFSR[<span class="number">12</span>] ^ LFSR[<span class="number">13</span>] ^ LFSR[<span class="number">15</span>];</span><br><span class="line">        LFSR[<span class="number">15</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">14</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//status hex sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> <span class="number">8735</span> <span class="number">1010110011100001</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span>E6A <span class="number">0101011001110000</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span>CD5 <span class="number">1010101100111000</span></span><br><span class="line"><span class="number">3</span> <span class="number">39</span>AA <span class="number">0101010110011100</span></span><br><span class="line"><span class="number">4</span> <span class="number">7354</span> <span class="number">0010101011001110</span></span><br><span class="line"><span class="number">5</span> E6A8 <span class="number">0001010101100111</span></span><br><span class="line"><span class="number">6</span> CD51 <span class="number">1000101010110011</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span>AA2 <span class="number">0100010101011001</span></span><br><span class="line"><span class="number">8</span> <span class="number">3544</span> <span class="number">0010001010101100</span></span><br><span class="line"><span class="number">9</span> <span class="number">6</span>A89 <span class="number">1001000101010110</span></span><br><span class="line"><span class="number">10</span> D513 <span class="number">1100100010101011</span></span><br><span class="line"><span class="number">11</span> AA27 <span class="number">1110010001010101</span></span><br><span class="line"><span class="number">12</span> <span class="number">544</span>E <span class="number">0111001000101010</span></span><br><span class="line"><span class="number">13</span> A89C <span class="number">0011100100010101</span></span><br><span class="line"><span class="number">14</span> <span class="number">5138</span> <span class="number">0001110010001010</span></span><br><span class="line"><span class="number">15</span> A271 <span class="number">1000111001000101</span></span><br><span class="line"><span class="number">16</span> <span class="number">44</span>E2 <span class="number">0100011100100010</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>若需要将全0状态加入上述LFSR的循环中</li></ul><p><img src="/images/5a8ad698bb944c7fa539b4d2ebd0bc19.png" alt="img"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR16_16801_0(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] LFSR = <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">10</span>] ^ LFSR[<span class="number">12</span>] ^ LFSR[<span class="number">13</span>] ^ LFSR[<span class="number">15</span>] ^ (LFSR[<span class="number">14</span>:<span class="number">0</span>]==<span class="number">15&#x27;b000000000000000</span>);</span><br><span class="line">        LFSR[<span class="number">15</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">14</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//status hex sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> <span class="number">0000</span> <span class="number">0000000000000000</span></span><br><span class="line"><span class="number">1</span> <span class="number">0001</span> <span class="number">1000000000000000</span></span><br><span class="line"><span class="number">2</span> <span class="number">0002</span> <span class="number">0100000000000000</span></span><br><span class="line"><span class="number">3</span> <span class="number">0004</span> <span class="number">0010000000000000</span></span><br><span class="line"><span class="number">4</span> <span class="number">0008</span> <span class="number">0001000000000000</span></span><br><span class="line"><span class="number">5</span> <span class="number">0010</span> <span class="number">0000100000000000</span></span><br><span class="line"><span class="number">6</span> <span class="number">0020</span> <span class="number">0000010000000000</span></span><br><span class="line"><span class="number">7</span> <span class="number">0040</span> <span class="number">0000001000000000</span></span><br><span class="line"><span class="number">8</span> <span class="number">0080</span> <span class="number">0000000100000000</span></span><br><span class="line"><span class="number">9</span> <span class="number">0100</span> <span class="number">0000000010000000</span></span><br><span class="line"><span class="number">10</span> <span class="number">0200</span> <span class="number">0000000001000000</span></span><br><span class="line"><span class="number">11</span> <span class="number">0400</span> <span class="number">0000000000100000</span></span><br><span class="line"><span class="number">12</span> <span class="number">0801</span> <span class="number">1000000000010000</span></span><br><span class="line"><span class="number">13</span> <span class="number">1002</span> <span class="number">0100000000001000</span></span><br><span class="line"><span class="number">14</span> <span class="number">2005</span> <span class="number">1010000000000100</span></span><br><span class="line"><span class="number">15</span> <span class="number">400</span>B <span class="number">1101000000000010</span></span><br><span class="line"><span class="number">16</span> <span class="number">8016</span> <span class="number">0110100000000001</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h1 id="应用">应用</h1><ul><li>伪随机数生成<ul><li>LFSR只能产生伪随机，是伪随机数生成器（Pseudo Random Number Generator，PRNG）的一种实现方案，在实际应用中，可以使用一些分立器件如D触发器构造LFSR</li><li>虽然在反馈路径确定后，LFSR的输出状态序列也是确定的，且最终会实现循环，但随着n的增大，任意时刻的输出状态的随机性也会随之增大</li></ul></li><li>数据加密<ul><li>数据发送端通过加扰将源数据流与一个随机序列异或后，再发送出去，异或操作完成后的数据流基本是伪随机的</li><li>在数据接收端也有解扰操作，解扰与加扰必须完全同步，即LFSR使用相同的公式、相同的初始值、相同时刻的输出</li></ul></li><li>CRC校验<ul><li>LFSR还可用于CRC的校验，会用到模2的多项式运算，遵循如下的运算原则：</li></ul></li></ul><img src="/images/48368b99c006653092b4985da8179729.png" alt="img" style="zoom: 67%;" />]]></content>
      
      
      <categories>
          
          <category> 知识储备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LFSR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git指南</title>
      <link href="/Git%E6%8C%87%E5%8D%97/"/>
      <url>/Git%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Git简介">Git简介</h1><h2 id="Git安装">Git安装</h2><ul><li>Git 是分布式版本控制工具，核心价值在于高效管理代码变更、支持离线协作与灵活分支策略</li><li>对比集中式系统（如 SVN），安全性更高（本地即备份）且协作更灵活</li><li><a href="https://www.runoob.com/git/git-install-setup.html">下载与安装</a></li></ul><p><img src="/images/0D32F290-80B0-4EA4-9836-CA58E22569B3.jpg" alt="img"></p><h2 id="Git框架">Git框架</h2><ul><li>Workspace：工作区是本地计算机上的项目目录，在这里进行文件的创建、修改和删除操作</li><li>Stage/Index：暂存区是一个临时存储区域，它包含了即将被提交到版本库中的文件快照（索引），在提交之前，你可以选择性地将工作区中的修改添加到暂存区</li><li>Repository：版本库包含项目的所有版本历史记录。，工作区有一个隐藏目录<code>.git</code>是 Git 的版本库</li></ul><p><img src="/images/1352126739_7909.jpg" alt="img"></p><h2 id="工作流">工作流</h2><img src="/images/git-process.png" alt="img" style="zoom:80%;" /><ul><li>克隆仓库：要参与一个已有的项目，首先需要将远程仓库克隆到本地</li><li>创建新分支：为了避免直接在 main 或 master 分支上进行开发，通常会创建一个新的分支</li><li>修改副本：在工作目录中进行代码编辑、添加新文件或删除不需要的文件</li><li>暂存修改：将修改过的文件添加到暂存区，以便进行下一步的提交操作</li><li>提交修改：将暂存区的更改提交到本地仓库，并添加提交信息</li><li>拉取最新更新：在推送本地更改之前，最好从远程仓库拉取最新的更改，以避免冲突</li><li>推送修改：将本地的提交推送到远程仓库</li></ul><h1 id="GitHub仓库">GitHub仓库</h1><ul><li>利用<a href="https://blog.csdn.net/qq_35246620/article/details/54317740">SSH</a>来完成GitHub的绑定并提交文件</li><li>SSH专为会话和其他网络服务提供安全性的协议，加密压缩数据、加快传输速度</li></ul><h2 id="SSH密钥">SSH密钥</h2><ul><li><p>右键打开Git Bash，输入<code>ssh</code>查看本机是否安装SSH</p></li><li><p>输入<code>ssh-keygen -t rsa</code>生成<code>RSA</code>算法公钥和私钥，若成功则打印公钥指纹</p></li></ul><img src="/images/image-20250709141654216.png" alt="image-20250709141654216" style="zoom:50%;" /><h2 id="SSH绑定">SSH绑定</h2><ul><li>Git Bash中输入<code>cat ~/.ssh/id_rsa.pub</code>打印并复制公钥</li><li>登录 GitHub → Settings → <strong>SSH and GPG Keys</strong> → New SSH Key</li><li>Git Bash中输入<code>ssh -T git@github.com</code>，若打印信息<code>You've successfully authenticated</code>则绑定成功</li></ul><h2 id="SSH地址">SSH地址</h2><ul><li>进入GitHub仓库复制HTTPS协议或SSH协议的下载链接</li></ul><img src="/images/image-20250709141636991.png" alt="image-20250709141636991" style="zoom: 33%;" /><h1 id="Git操作">Git操作</h1><h2 id="远程推送">远程推送</h2><ul><li>初始化本地Git仓库<code>git init</code></li><li>关联远程仓库<code>git remote add origin git@github.com:username/repo.git</code><ul><li>验证远程仓库<code>git remote -v</code></li><li>更改远程仓库<code>git remote set-url origin git@github.com:username/repo.git</code></li></ul></li><li>添加文件到缓存区<code>git add .</code><ul><li>重置暂存区<code>git reset</code></li><li>设置忽略文件或目录<code>git add .gitignore</code></li></ul></li></ul><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Output/</span><br><span class="line">jre/</span><br><span class="line">RiscvCompiler.jar</span><br><span class="line">compiler_icon.ico</span><br><span class="line">setup.iss</span><br><span class="line">toolchain/</span><br></pre></td></tr></table></figure><ul><li>使用<code>git commit -am &quot;msg of update&quot;</code>将修改提交至本地仓库<ul><li>此操作会更新本地.git目录，是上传远程前的必要步骤</li><li>完成后可使用<code>git log</code>查看本次更新的提交信息及哈希值</li><li>使用<code>git status</code>查看还未提交的文件</li></ul></li><li>拉取远程变更合并<code>git pull origin main</code></li><li>推送至主分支<code>git push -u origin main</code><ul><li><code>-u</code>将本地<code>main</code>分支与远程<code>origin（远程主机）/main（默认分支）</code>分支建立联系，未来在该分支只需输入 <code>git push</code> 或 <code>git pull</code> 即可自动关联到 <code>origin/main</code></li></ul></li></ul><img src="/images/image-20250709142916006.png" alt="image-20250709142916006" style="zoom:50%;" /><ul><li><p>首次提交需添加邮箱信息，后续修改邮箱信息也可使用以下命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;your@email.com&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your name&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="本地下载">本地下载</h2><ul><li>Git Bash中输入<code>git clone git@github.com:username/repo.git</code>，获取远程仓库到本地仓库（工作区）</li></ul><img src="/images/image-20250709142631646.png" alt="image-20250709142631646" style="zoom: 50%;" /><ul><li>在<code>git clone &lt;url&gt;</code>中集成了多步操作<ul><li>本地新建远程仓库目录</li><li>初始化仓库：<code>git init</code></li><li>添加远程地址：<code>git remote add origin &lt;url&gt;</code></li><li>获取远程数据：<code>git fetch origin</code></li><li>自动检出默认分支：<code>git checkout main</code></li></ul></li></ul><h2 id="分支管理">分支管理</h2><ul><li><p>检出默认分支：clone时所有分支均会被下载，默认分支一般被命名为main或者master；自动设置默认分支（Branch）为当前工作主线，其他分支隐藏</p></li><li><p>创建新分支并切换到该分支：<code>git checkout -b &lt;branchname&gt;</code></p></li><li><p>查看分支：<code>git branch</code>默认查看本地</p><ul><li>查看远程<code>-r</code>，查看远程和本地<code>-a</code></li></ul></li><li><p>合并分支：<code>git merge &lt;branchname&gt;</code>将其他分支合并到当前分支</p></li><li><p>删除本地分支：<code>git branch &lt;select&gt; &lt;branchname&gt;</code></p><ul><li>删除本地<code>-d</code>，删除未合并分支<code>-D</code></li></ul></li><li><p>删除远程分支<code>git push origin --delete &lt;branchname&gt;</code></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RISC-V GCC GUI</title>
      <link href="/RISC-V-GCC-GUI/"/>
      <url>/RISC-V-GCC-GUI/</url>
      
        <content type="html"><![CDATA[<h1 id="使用说明">使用说明</h1><h2 id="开源">开源</h2><ul><li>RISC-V Compiler开发基于<a href="https://www.eclipse.org/">Eclipse</a></li><li>内置GCC使用开源项目<a href="https://github.com/xpack-dev-tools/riscv-none-elf-gcc-xpack">riscv-none-elf-gcc-xpack</a></li><li>Java GUI代码开源于我的<a href="https://github.com/arvinhwo/RISC-V-GCC-GUI">GitHub仓库</a><ul><li>SSH地址：<code>git@github.com:arvinhwo/RISC-V-GCC-GUI.git</code></li></ul></li></ul><h2 id="安装">安装</h2><ul><li>选择安装位置，默认安装于<code>C:\Program Files\RiscvCompiler</code></li></ul><p><img src="/images/image-20250808110732132.png" alt="image-20250808110732132"></p><ul><li>选择快捷方式存放位置</li></ul><p><img src="/images/image-20250808110911551.png" alt="image-20250808110911551"></p><ul><li>安装预计用时1分钟</li></ul><p><img src="/images/image-20250808111219456.png" alt="image-20250808111219456"></p><h2 id="使用">使用</h2><p><img src="/images/image-20250808111335704.png" alt="image-20250808111335704"></p><ul><li>指定项目目录：C语言主程序、启动文件、链接脚本</li><li>指定主程序文件名（不带文件类型后缀），指定链接脚本</li><li>GCC编译文件自动存入指定项目目录</li></ul><img src="/images/image-20250808110227069.png" alt="image-20250808110227069" style="zoom:80%;" /><h1 id="开发准备">开发准备</h1><h2 id="安装-v2">安装</h2><ul><li><a href="../Eclipse%E6%8C%87%E5%8D%97">Eclipse安装及入门</a></li><li><a href="https://github.com/xpack-dev-tools/riscv-none-elf-gcc-xpack/releases/tag/v14.2.0-3">xpack-riscv-gcc下载</a></li><li><a href="https://jrsoftware.org/isinfo.php">Inno Setup安装</a></li></ul><h2 id="原始脚本">原始脚本</h2><h3 id="工具链变量">工具链变量</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TOOLCHAIN</span></span><br><span class="line"><span class="variable">$TOOLCHAIN_DIR</span> = <span class="string">&quot;C:\riscv\xpack-riscv-none-elf-gcc-14.2.0-3\bin&quot;</span></span><br><span class="line"><span class="variable">$RISCV_GCC</span> = <span class="string">&quot;<span class="variable">$TOOLCHAIN_DIR</span>\riscv-none-elf-gcc.exe&quot;</span></span><br><span class="line"><span class="variable">$OBJCOPY</span> = <span class="string">&quot;<span class="variable">$TOOLCHAIN_DIR</span>\riscv-none-elf-objcopy.exe&quot;</span></span><br><span class="line"><span class="variable">$OBJDUMP</span> = <span class="string">&quot;<span class="variable">$TOOLCHAIN_DIR</span>\riscv-none-elf-objdump.exe&quot;</span></span><br></pre></td></tr></table></figure><ul><li><code>gcc</code>：RISC-V架构的交叉编译器前端<ul><li>将C/C++源代码编译为RISC-V目标平台的机器码</li><li>管理整个编译流程（预处理→编译→汇编→链接）</li><li>支持RISC-V RV32/RV64指令集及扩展（如M/C/F/D等）</li></ul></li><li><code>objcopy</code>：目标文件格式转换工具<ul><li>提取/转换ELF文件中的特定段（如从.elf提取.bin固件）</li><li>生成可烧录的二进制镜像（如用于Flash编程）</li><li>修改文件头信息或段属性</li></ul></li><li><code>objdump</code>：目标文件分析诊断工具<ul><li>反汇编机器码为RISC-V汇编指令</li><li>显示ELF文件结构（段头、符号表等）</li><li>生成带地址的汇编列表文件</li></ul></li></ul><h3 id="文件变量">文件变量</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># PROJECT</span></span><br><span class="line"><span class="variable">$PROJECT_DIR</span> = <span class="string">&quot;your_project_path&quot;</span></span><br><span class="line"><span class="variable">$MAIN_CODE</span> = <span class="string">&quot;main_file_name_without_extension&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SOURCE</span></span><br><span class="line"><span class="variable">$LINKER_SCRIPT</span> = <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\sections.lds&quot;</span></span><br><span class="line"><span class="variable">$SOURCE_FILES</span> = <span class="selector-tag">@</span>(</span><br><span class="line">    <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\start.S&quot;</span>,</span><br><span class="line">    <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\<span class="variable">$MAIN_CODE</span>.c&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># OUTPUT</span></span><br><span class="line"><span class="variable">$MAP_FILE</span> = <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\sys.map&quot;</span></span><br><span class="line"><span class="variable">$ELF_OUTPUT</span> = <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\<span class="variable">$MAIN_CODE</span>.elf&quot;</span></span><br></pre></td></tr></table></figure><h3 id="编译选项">编译选项</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># OPTIONS</span></span><br><span class="line"><span class="variable">$CFLAGS</span> = <span class="selector-tag">@</span>(</span><br><span class="line">    <span class="string">&quot;-O3&quot;</span>,                  <span class="comment"># 启用最高级别优化</span></span><br><span class="line">    <span class="string">&quot;-nostdlib&quot;</span>,            <span class="comment"># 禁用标准库链接</span></span><br><span class="line">    <span class="string">&quot;-flto&quot;</span>,                <span class="comment"># 链接时优化</span></span><br><span class="line">    <span class="string">&quot;-ffreestanding&quot;</span>,       <span class="comment"># 独立环境编译</span></span><br><span class="line">    <span class="string">&quot;-ffunction-sections&quot;</span>,  <span class="comment"># 函数分段，配合链接器GC移除未使用函数</span></span><br><span class="line">    <span class="string">&quot;-fdata-sections&quot;</span>,      <span class="comment"># 数据分段，支持链接时移除未用数据</span></span><br><span class="line">    <span class="string">&quot;-fno-builtin&quot;</span>,         <span class="comment"># 禁用内置函数</span></span><br><span class="line">    <span class="string">&quot;--specs=nano.specs&quot;</span>,   <span class="comment"># 轻量库配置</span></span><br><span class="line">    <span class="string">&quot;--specs=nosys.specs&quot;</span>   <span class="comment"># 无系统调用配置</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>性能强化：编译、链接双阶段优化<ul><li><code>-O3</code>+<code>-flto</code></li></ul></li><li>裸机环境适配：确保编译结果不依赖操作系统<ul><li><code>-nostdlib</code>+<code>-ffreestanding</code>+<code>nosys.specs</code></li></ul></li><li>代码尺寸优化：移除未使用代码、数据<ul><li><code>-ffunction-sections</code>+<code>-fdata-sections</code></li></ul></li><li>精简库：减小二进制体积<ul><li><code>nano.specs</code></li></ul></li></ul><h3 id="链接选项">链接选项</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$LDFLAGS</span> = <span class="selector-tag">@</span>(</span><br><span class="line">    <span class="string">&quot;-Wl,--build-id=none&quot;</span>,   <span class="comment"># 禁用构建ID，减少二进制体积</span></span><br><span class="line">    <span class="string">&quot;-Wl,-Bstatic&quot;</span>,          <span class="comment"># 强制静态链接</span></span><br><span class="line">    <span class="string">&quot;-Wl,-T,<span class="variable">$LINKER_SCRIPT</span>&quot;</span>, <span class="comment"># 指定链接脚本，自定以内存布局</span></span><br><span class="line">    <span class="string">&quot;-Wl,-Map=<span class="variable">$MAP_FILE</span>&quot;</span>,    <span class="comment"># 生成链接映射，用于调试与内存分析</span></span><br><span class="line">    <span class="string">&quot;-L.&quot;</span>                    <span class="comment"># 添加库搜索路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>部署控制：强制静态链接（<code>-Bstatic</code>）和自定义内存布局（<code>-T</code>脚本）确保程序在目标硬件精确运行</li></ul><h3 id="编译命令">编译命令</h3><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># COMPILE</span></span><br><span class="line">&amp; <span class="variable">$RISCV_GCC</span> <span class="literal">-march</span>=rv32e <span class="literal">-mabi</span>=ilp32e <span class="variable">$CFLAGS</span> <span class="variable">$LDFLAGS</span> <span class="literal">-o</span> <span class="variable">$ELF_OUTPUT</span> <span class="variable">$SOURCE_FILES</span></span><br><span class="line">&amp; <span class="variable">$OBJDUMP</span> <span class="literal">-S</span> <span class="variable">$ELF_OUTPUT</span> &gt; (<span class="variable">$ELF_OUTPUT</span> <span class="operator">-replace</span> <span class="string">&#x27;\.elf$&#x27;</span>, <span class="string">&#x27;.s&#x27;</span>)</span><br><span class="line">&amp; <span class="variable">$OBJCOPY</span> <span class="literal">-O</span> binary <span class="variable">$ELF_OUTPUT</span> (<span class="variable">$ELF_OUTPUT</span> <span class="operator">-replace</span> <span class="string">&#x27;\.elf$&#x27;</span>, <span class="string">&#x27;.bin&#x27;</span>)</span><br><span class="line">&amp; <span class="variable">$OBJCOPY</span> <span class="literal">-O</span> verilog <span class="literal">--verilog-data-width</span> <span class="number">4</span> <span class="variable">$ELF_OUTPUT</span> (<span class="variable">$ELF_OUTPUT</span> <span class="operator">-replace</span> <span class="string">&#x27;\.elf$&#x27;</span>, <span class="string">&#x27;.hex&#x27;</span>)</span><br></pre></td></tr></table></figure><h1 id="开发记录">开发记录</h1><ul><li>Eclipse新建Java Project，不勾选<code>Create module-info.java</code></li><li>先实现调用本地GCC的GUI原型，再封装GCC及GUI</li></ul><h2 id="原型">原型</h2><ul><li>部分原型GUI代码展示，调用本地RISC-V GCC实现C程序编译</li></ul><h3 id="界面">界面</h3><ul><li>组件声明</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">JTextField</span> <span class="variable">toolchainDirField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">30</span>); <span class="comment">// 工具链路径输入框</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">JTextField</span> <span class="variable">projectDirField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">30</span>);  <span class="comment">// 项目路径输入框</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">JTextField</span> <span class="variable">mainCodeField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="string">&quot;主文件名(无后缀)&quot;</span>, <span class="number">15</span>); <span class="comment">// 主代码文件名</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">JTextField</span> <span class="variable">linkerScriptField</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextField</span>(<span class="number">30</span>); <span class="comment">// 链接脚本路径输入框</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">JTextArea</span> <span class="variable">logArea</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JTextArea</span>(<span class="number">15</span>, <span class="number">60</span>); <span class="comment">// 日志显示区域</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">JButton</span> <span class="variable">compileButton</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;开始编译&quot;</span>); <span class="comment">// 核心功能按钮</span></span><br></pre></td></tr></table></figure><ul><li>窗口布局</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">RiscvCompilerGUI</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(<span class="string">&quot;RISC-V编译工具&quot;</span>); <span class="comment">// 窗口标题</span></span><br><span class="line">    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);</span><br><span class="line">    setLayout(<span class="keyword">new</span> <span class="title class_">BorderLayout</span>(<span class="number">10</span>, <span class="number">10</span>)); <span class="comment">// 边界布局：上(输入区)、中(日志区)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加组件到窗口</span></span><br><span class="line">    add(createInputPanel(), BorderLayout.NORTH); <span class="comment">// 顶部：参数输入面板</span></span><br><span class="line">    add(<span class="keyword">new</span> <span class="title class_">JScrollPane</span>(logArea), BorderLayout.CENTER); <span class="comment">// 中间：日志区域(带滚动条)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 日志区域配置（只读+等宽字体）</span></span><br><span class="line">    logArea.setEditable(<span class="literal">false</span>);</span><br><span class="line">    logArea.setFont(<span class="keyword">new</span> <span class="title class_">Font</span>(<span class="string">&quot;Consolas&quot;</span>, Font.PLAIN, <span class="number">12</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 窗口属性设置</span></span><br><span class="line">    pack(); <span class="comment">// 自动调整大小</span></span><br><span class="line">    setLocationRelativeTo(<span class="literal">null</span>); <span class="comment">// 居中显示</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入区</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> JPanel <span class="title function_">createInputPanel</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">JPanel</span> <span class="variable">panel</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JPanel</span>(<span class="keyword">new</span> <span class="title class_">GridBagLayout</span>());</span><br><span class="line">    <span class="type">GridBagConstraints</span> <span class="variable">gbc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GridBagConstraints</span>();</span><br><span class="line">    gbc.insets = <span class="keyword">new</span> <span class="title class_">Insets</span>(<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>); <span class="comment">// 组件间距</span></span><br><span class="line">    gbc.anchor = GridBagConstraints.WEST; <span class="comment">// 左对齐</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入行1：工具链目录（标签+输入框+浏览按钮）</span></span><br><span class="line">    addInputRow(panel, gbc, <span class="number">0</span>, <span class="string">&quot;工具链目录：&quot;</span>, toolchainDirField, e -&gt; chooseDirectory(toolchainDirField));</span><br><span class="line">    <span class="comment">// 输入行2：项目目录</span></span><br><span class="line">    addInputRow(panel, gbc, <span class="number">1</span>, <span class="string">&quot;项目目录：&quot;</span>, projectDirField, e -&gt; chooseDirectory(projectDirField));</span><br><span class="line">    <span class="comment">// 输入行3：主代码文件名</span></span><br><span class="line">    addInputRow(panel, gbc, <span class="number">2</span>, <span class="string">&quot;主代码文件名：&quot;</span>, mainCodeField, <span class="literal">null</span>);</span><br><span class="line">    <span class="comment">// 输入行4：链接脚本（文件过滤.lds）</span></span><br><span class="line">    addInputRow(panel, gbc, <span class="number">3</span>, <span class="string">&quot;链接脚本：&quot;</span>, linkerScriptField, e -&gt; chooseFile(linkerScriptField, <span class="string">&quot;lds&quot;</span>));</span><br><span class="line">    <span class="comment">// 输入行5：编译按钮（跨列居中）</span></span><br><span class="line">    gbc.gridx = <span class="number">0</span>; gbc.gridy = <span class="number">4</span>; gbc.gridwidth = <span class="number">3</span>; gbc.anchor = GridBagConstraints.CENTER;</span><br><span class="line">    panel.add(compileButton, gbc);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> panel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="交互">交互</h3><ul><li>目录选择</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">chooseDirectory</span><span class="params">(JTextField field)</span> &#123;</span><br><span class="line">    <span class="type">JFileChooser</span> <span class="variable">chooser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFileChooser</span>();</span><br><span class="line">    chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY); <span class="comment">// 仅允许选择目录</span></span><br><span class="line">    <span class="keyword">if</span> (chooser.showOpenDialog(<span class="built_in">this</span>) == JFileChooser.APPROVE_OPTION) &#123;</span><br><span class="line">        <span class="comment">// 将选中的目录路径显示到输入框</span></span><br><span class="line">        field.setText(chooser.getSelectedFile().getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>文件选择</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">chooseFile</span><span class="params">(JTextField field, String ext)</span> &#123;</span><br><span class="line">    <span class="type">JFileChooser</span> <span class="variable">chooser</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JFileChooser</span>();</span><br><span class="line">    <span class="comment">// 过滤文件类型（仅显示.lds文件）</span></span><br><span class="line">    chooser.setFileFilter(<span class="keyword">new</span> <span class="title class_">FileNameExtensionFilter</span>(ext.toUpperCase() + <span class="string">&quot;文件&quot;</span>, ext));</span><br><span class="line">    <span class="keyword">if</span> (chooser.showOpenDialog(<span class="built_in">this</span>) == JFileChooser.APPROVE_OPTION) &#123;</span><br><span class="line">        <span class="comment">// 将选中的文件路径显示到输入框</span></span><br><span class="line">        field.setText(chooser.getSelectedFile().getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译按钮</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">initButtonAction</span><span class="params">()</span> &#123;</span><br><span class="line">    compileButton.addActionListener(e -&gt; &#123;</span><br><span class="line">        logArea.setText(<span class="string">&quot;&quot;</span>); <span class="comment">// 清空旧日志</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">CompileWorker</span>().execute(); <span class="comment">// 启动后台任务（避免界面卡死）</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译">编译</h3><ul><li>识别路径</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String <span class="title function_">getBuiltInToolchainDir</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 获取程序当前运行目录</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">appDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>); </span><br><span class="line">    <span class="type">String</span> <span class="variable">toolchainBinDir</span> <span class="operator">=</span> appDir + File.separator + <span class="string">&quot;toolchain&quot;</span> + File.separator + <span class="string">&quot;bin&quot;</span>;</span><br><span class="line">            </span><br><span class="line">    <span class="comment">// 检查工具链核心文件是否存在（避免打包时遗漏工具链）</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">gccFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(toolchainBinDir + File.separator + <span class="string">&quot;riscv-none-elf-gcc.exe&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!gccFile.exists()) &#123;</span><br><span class="line">        publish(<span class="string">&quot;错误：内置工具链缺失！请确保程序目录下存在 toolchain/bin/riscv-none-elf-gcc.exe&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> toolchainBinDir; <span class="comment">// 返回工具链bin目录路径（含riscv-none-elf-gcc.exe等工具）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>编译任务</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 自动获取内置工具链路径（无需用户输入）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">toolchainDir</span> <span class="operator">=</span> getBuiltInToolchainDir();</span><br><span class="line"><span class="keyword">if</span> (toolchainDir == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 工具链缺失，退出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 获取用户输入的参数（路径、文件名）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">projectDir</span> <span class="operator">=</span> projectDirField.getText().trim();</span><br><span class="line"><span class="type">String</span> <span class="variable">mainCode</span> <span class="operator">=</span> mainCodeField.getText().trim();</span><br><span class="line"><span class="type">String</span> <span class="variable">linkerScript</span> <span class="operator">=</span> linkerScriptField.getText().trim();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 检查参数是否完整</span></span><br><span class="line"><span class="keyword">if</span> (projectDir.isEmpty() || mainCode.isEmpty() || linkerScript.isEmpty()) &#123;</span><br><span class="line">publish(<span class="string">&quot;错误：请填写所有路径和参数！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 拼接工具路径（RISC-V GCC、OBJCOPY等）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">riscvGcc</span> <span class="operator">=</span> toolchainDir + <span class="string">&quot;\riscv-none-elf-gcc.exe&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">objdump</span> <span class="operator">=</span> toolchainDir + <span class="string">&quot;\riscv-none-elf-objdump.exe&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">objcopy</span> <span class="operator">=</span> toolchainDir + <span class="string">&quot;\riscv-none-elf-objcopy.exe&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 检查工具是否存在（避免路径错误）</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">new</span> <span class="title class_">File</span>(riscvGcc).exists()) &#123;</span><br><span class="line">publish(<span class="string">&quot;错误：未找到riscv-none-elf-gcc.exe，请检查工具链路径！&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5. 拼接输出文件路径（和原脚本一致）</span></span><br><span class="line"><span class="type">String</span> <span class="variable">elfOutput</span> <span class="operator">=</span> projectDir + <span class="string">&quot;\&quot; + mainCode + &quot;</span>.elf<span class="string">&quot;;</span></span><br><span class="line"><span class="string">String mapFile = projectDir + &quot;</span>\<span class="string">&quot; + mainCode + &quot;</span>.map<span class="string">&quot;;</span></span><br><span class="line"><span class="string">String asmOutput = elfOutput.replace(&quot;</span>.elf<span class="string">&quot;, &quot;</span>.s<span class="string">&quot;);</span></span><br><span class="line"><span class="string">String binOutput = elfOutput.replace(&quot;</span>.elf<span class="string">&quot;, &quot;</span>.bin<span class="string">&quot;);</span></span><br><span class="line"><span class="string">String hexOutput = elfOutput.replace(&quot;</span>.elf<span class="string">&quot;, &quot;</span>.hex<span class="string">&quot;);</span></span><br></pre></td></tr></table></figure><ul><li>文件生成</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：编译生成ELF文件（核心命令）</span></span><br><span class="line">String[] gccCommand = &#123;</span><br><span class="line">riscvGcc,</span><br><span class="line"><span class="string">&quot;-march=rv32e&quot;</span>, <span class="string">&quot;-mabi=ilp32e&quot;</span>, <span class="comment">// RISC-V架构参数（rv32e/ilp32e）</span></span><br><span class="line"><span class="string">&quot;-O3&quot;</span>, <span class="string">&quot;-nostdlib&quot;</span>, <span class="string">&quot;-flto&quot;</span>, <span class="string">&quot;-ffreestanding&quot;</span>, <span class="comment">// CFLAGS优化选项</span></span><br><span class="line"><span class="string">&quot;-ffunction-sections&quot;</span>, <span class="string">&quot;-fdata-sections&quot;</span>, <span class="string">&quot;-fno-builtin&quot;</span>,</span><br><span class="line"><span class="string">&quot;--specs=nano.specs&quot;</span>, <span class="string">&quot;--specs=nosys.specs&quot;</span>,</span><br><span class="line"><span class="string">&quot;-Wl,--build-id=none&quot;</span>, <span class="string">&quot;-Wl,-Bstatic&quot;</span>, <span class="comment">// LDFLAGS链接选项</span></span><br><span class="line"><span class="string">&quot;-Wl,-T,&quot;</span> + linkerScript, <span class="comment">// 链接脚本（用户选择的.lds）</span></span><br><span class="line"><span class="string">&quot;-Wl,-Map=&quot;</span> + mapFile, <span class="comment">// 生成map文件</span></span><br><span class="line"><span class="string">&quot;-L.&quot;</span>,</span><br><span class="line"><span class="string">&quot;-o&quot;</span>, elfOutput, <span class="comment">// 输出ELF文件</span></span><br><span class="line">projectDir + <span class="string">&quot;\start.S&quot;</span>, <span class="comment">// 源文件1：start.S（固定）</span></span><br><span class="line">projectDir + <span class="string">&quot;\&quot; + mainCode + &quot;</span>.c<span class="string">&quot; // 源文件2：主代码.c</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"><span class="string">publish(&quot;</span>执行编译命令：<span class="string">&quot; + String.join(&quot;</span> <span class="string">&quot;, gccCommand));</span></span><br><span class="line"><span class="string">if (!runCommand(gccCommand)) return null; // 执行命令，失败则退出</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 步骤2：生成反汇编.s文件（objdump -S）</span></span><br><span class="line"><span class="string">String[] objdumpCommand = &#123;objdump, &quot;</span>-S<span class="string">&quot;, elfOutput&#125;;</span></span><br><span class="line"><span class="string">publish(&quot;</span>\n执行反汇编：<span class="string">&quot; + String.join(&quot;</span> <span class="string">&quot;, objdumpCommand));</span></span><br><span class="line"><span class="string">if (!runCommandToFile(objdumpCommand, asmOutput)) return null;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 步骤3：生成bin文件（objcopy -O binary）</span></span><br><span class="line"><span class="string">String[] binCommand = &#123;objcopy, &quot;</span>-O<span class="string">&quot;, &quot;</span>binary<span class="string">&quot;, elfOutput, binOutput&#125;;</span></span><br><span class="line"><span class="string">publish(&quot;</span>\n生成bin文件：<span class="string">&quot; + String.join(&quot;</span> <span class="string">&quot;, binCommand));</span></span><br><span class="line"><span class="string">if (!runCommand(binCommand)) return null;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">// 步骤4：生成hex文件（objcopy -O verilog）</span></span><br><span class="line"><span class="string">String[] hexCommand = &#123;objcopy, &quot;</span>-O<span class="string">&quot;, &quot;</span>verilog<span class="string">&quot;, &quot;</span>--verilog-data-width<span class="string">&quot;, &quot;</span><span class="number">4</span><span class="string">&quot;, elfOutput, hexOutput&#125;;</span></span><br><span class="line"><span class="string">publish(&quot;</span>\n生成hex文件：<span class="string">&quot; + String.join(&quot;</span> <span class="string">&quot;, hexCommand));</span></span><br><span class="line"><span class="string">if (!runCommand(hexCommand)) return null;</span></span><br></pre></td></tr></table></figure><h3 id="试运行">试运行</h3><p><img src="/images/image-20250807134828543.png" alt="image-20250807134828543"></p><h2 id="打包">打包</h2><ul><li>将RISCV GCC和Java环境封装进安装包，达到开箱即用的目的</li></ul><h3 id="GCC打包">GCC打包</h3><ul><li>将编译工具链放入项目根目录并改名<code>toolchain</code><ul><li>目录结构为<code>riscv_compiler/toolchain/bin/riscv-none-elf-gcc.exe</code></li></ul></li><li>将原型中工具链路径由用户输入改为自动获取</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除原工具链路径输入框相关代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改编译逻辑，使用自动获取的工具链路径</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">CompileWorker</span> <span class="keyword">extends</span> <span class="title class_">SwingWorker</span>&lt;Void, String&gt; &#123;</span><br><span class="line">        <span class="comment">// 自动识别内置工具链路径</span></span><br><span class="line">        <span class="keyword">private</span> String <span class="title function_">getBuiltInToolchainDir</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="comment">// 获取程序当前运行目录（打包后为EXE解压的临时目录，工具链固定放在&quot;toolchain/bin&quot;下）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">appDir</span> <span class="operator">=</span> System.getProperty(<span class="string">&quot;user.dir&quot;</span>); </span><br><span class="line">            <span class="type">String</span> <span class="variable">toolchainBinDir</span> <span class="operator">=</span> appDir + File.separator + <span class="string">&quot;toolchain&quot;</span> + File.separator + <span class="string">&quot;bin&quot;</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 检查工具链核心文件是否存在（避免打包时遗漏工具链）</span></span><br><span class="line">            <span class="type">File</span> <span class="variable">gccFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(toolchainBinDir + File.separator + <span class="string">&quot;riscv-none-elf-gcc.exe&quot;</span>);</span><br><span class="line">            <span class="keyword">if</span> (!gccFile.exists()) &#123;</span><br><span class="line">                <span class="comment">// 此时 publish 方法属于 CompileWorker（SwingWorker子类），可正常调用</span></span><br><span class="line">                publish(<span class="string">&quot;错误：内置工具链缺失！请确保程序目录下存在 toolchain/bin/riscv-none-elf-gcc.exe&quot;</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> toolchainBinDir; <span class="comment">// 返回工具链bin目录路径（含riscv-none-elf-gcc.exe等工具）</span></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">protected</span> Void <span class="title function_">doInBackground</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">            <span class="comment">// 0. 自动获取内置工具链路径（无需用户输入）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">toolchainDir</span> <span class="operator">=</span> getBuiltInToolchainDir();</span><br><span class="line">            <span class="keyword">if</span> (toolchainDir == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 工具链缺失，退出</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 1. 获取用户输入的参数（路径、文件名）</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">projectDir</span> <span class="operator">=</span> projectDirField.getText().trim();</span><br><span class="line">            <span class="type">String</span> <span class="variable">mainCode</span> <span class="operator">=</span> mainCodeField.getText().trim();</span><br><span class="line">            <span class="type">String</span> <span class="variable">linkerScript</span> <span class="operator">=</span> linkerScriptField.getText().trim();</span><br><span class="line">            </span><br><span class="line">            ...</span><br></pre></td></tr></table></figure><h3 id="JAR打包">JAR打包</h3><ul><li>打包为<code>Runnable JAR file</code>类型<ul><li>选择主类入口<code>RiscvCompilerGUI - risv_compiler</code></li><li>打包依赖项<code>Package required libraries into generated JAR</code></li><li>目录结构为<code>riscv_compiler/RiscvCompiler.jar</code></li></ul></li></ul><p><img src="/images/image-20250808102045734.png" alt="image-20250808102045734"></p><ul><li>使用JDK自带的<code>jlink</code>在项目目录中生成精简JRE，使封装后的GUI能在无JDK的环境中运行<ul><li>JDK添加到环境变量后，<code>jlink --module-path jmods --add-modules java.base,java.desktop --output jre</code></li><li>目录结构为<code>riscv_compiler/jre/bin/java.exe</code></li><li>CMD验证JRE<code>jre\bin\java.exe -jar RiscvCompiler.jar</code></li></ul></li></ul><p><img src="/images/image-20250808103451834.png" alt="image-20250808103451834"></p><h3 id="EXE打包">EXE打包</h3><ul><li>在项目目录中新建<code>setup.iss</code>文件，使用Inno Setup打开并编译</li></ul><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Setup]</span></span><br><span class="line"><span class="attr">AppName</span>=RISC-V Compiler Suite</span><br><span class="line"><span class="attr">AppVersion</span>=<span class="number">1.0</span></span><br><span class="line"><span class="attr">DefaultDirName</span>=&#123;pf&#125;\RiscvCompiler</span><br><span class="line"><span class="attr">OutputDir</span>=.\Output</span><br><span class="line"><span class="attr">OutputBaseFilename</span>=RiscvCompiler_Setup</span><br><span class="line"><span class="attr">Compression</span>=lzma2</span><br><span class="line"><span class="attr">SolidCompression</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">ArchitecturesAllowed</span>=x64</span><br><span class="line"><span class="attr">ArchitecturesInstallIn64BitMode</span>=x64</span><br><span class="line"></span><br><span class="line"><span class="section">[Files]</span></span><br><span class="line">Source: &quot;.\RiscvCompiler.jar&quot;<span class="comment">; DestDir: &quot;&#123;app&#125;&quot;; Flags: ignoreversion</span></span><br><span class="line">Source: &quot;.\toolchain\*&quot;<span class="comment">; DestDir: &quot;&#123;app&#125;\toolchain&quot;; Flags: ignoreversion recursesubdirs</span></span><br><span class="line">Source: &quot;.\jre\*&quot;<span class="comment">; DestDir: &quot;&#123;app&#125;\jre&quot;; Flags: ignoreversion recursesubdirs</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Icons]</span></span><br><span class="line">Name: &quot;&#123;commondesktop&#125;\RISC-V Compiler&quot;<span class="comment">; Filename: &quot;&#123;app&#125;\RiscvCompiler.bat&quot;; IconFilename: &quot;&#123;app&#125;\compiler_icon.ico&quot;</span></span><br><span class="line">Name: &quot;&#123;commonprograms&#125;\RISC-V Compiler&quot;<span class="comment">; Filename: &quot;&#123;app&#125;\RiscvCompiler.bat&quot;; IconFilename: &quot;&#123;app&#125;\compiler_icon.ico&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Run]</span></span><br><span class="line">Filename: &quot;&#123;app&#125;\RiscvCompiler.bat&quot;<span class="comment">; Description: &quot;启动编译器&quot;; Flags: postinstall nowait skipifsilent</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Code]</span></span><br><span class="line">// 创建强制使用内置JRE的启动脚本</span><br><span class="line">procedure CreateBatchFile<span class="comment">;</span></span><br><span class="line">var</span><br><span class="line">  BatchFile: string<span class="comment">;</span></span><br><span class="line">begin</span><br><span class="line">  BatchFile := ExpandConstant(&#x27;&#123;app&#125;\RiscvCompiler.bat&#x27;)<span class="comment">;</span></span><br><span class="line">  SaveStringToFile(BatchFile,</span><br><span class="line">    &#x27;@echo off&#x27; + <span class="comment">#13#10 +</span></span><br><span class="line">    &#x27;set <span class="attr">APPDIR</span>=%~dp0<span class="string">&#x27; + #13#10 +</span></span><br><span class="line"><span class="string">    &#x27;</span>start <span class="string">&quot;&quot;</span> <span class="string">&quot;%APPDIR%jre\bin\javaw.exe&quot;</span> -jar <span class="string">&quot;%APPDIR%RiscvCompiler.jar&quot;</span><span class="string">&#x27; + #13#10,</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">end;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">procedure CurStepChanged(CurStep: TSetupStep);</span></span><br><span class="line"><span class="string">begin</span></span><br><span class="line"><span class="string">  if CurStep = ssPostInstall then</span></span><br><span class="line"><span class="string">    CreateBatchFile;</span></span><br><span class="line"><span class="string">end;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eclipse </tag>
            
            <tag> Java </tag>
            
            <tag> RISC-V </tag>
            
            <tag> GCC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SV类与对象</title>
      <link href="/SV%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/"/>
      <url>/SV%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="OOP概述">OOP概述</h1><h2 id="特性">特性</h2><ul><li>SV面向对象编程（Object Oriented Programming, OOP）是在传统Verilog基础上扩展的核心特性<ul><li>能够创建复杂的数据类型及方法，并且将它们和子程序紧密第结合在一起</li><li>能够在更加抽象的层次建立测试平台和系统级模型，使之更加易于维护</li></ul></li><li>通过封装、继承、多态等机制实现代码复用、模块化和灵活扩展<ul><li>传统的测试平台强调操作：创建一个事务、发送、接收、检查结果、产生报告</li><li>在OOP中更加聚焦于各个组件及功能，如<code>Driver</code>、<code>Monitor</code>、<code>Packet</code>、<code>Transaction</code>、<code>Scoreboard</code>等</li></ul></li></ul><h2 id="术语">术语</h2><ul><li>在Verilog中，通过创建模块并在编译时逐层例化，可以得到一个复杂的设计，其顶层模块是隐式例化的</li><li>在OOP中创建类并在运行时构造它们（创建对象），可以得到一个相似的层次结构，SV类在使用前都需例化</li></ul><table><thead><tr><th style="text-align:center">SV</th><th style="text-align:left">简介</th><th style="text-align:left">对应Verilog</th></tr></thead><tbody><tr><td style="text-align:center">类<code>class</code></td><td style="text-align:left">包含变量和子程序的基本构建块</td><td style="text-align:left">模块<code>module</code></td></tr><tr><td style="text-align:center">对象<code>object</code></td><td style="text-align:left">类的实例化</td><td style="text-align:left">模块实例化</td></tr><tr><td style="text-align:center">句柄<code>handle</code></td><td style="text-align:left">指向对象的指针</td><td style="text-align:left">``top.u_t.func/task/variable`</td></tr><tr><td style="text-align:center">属性Property</td><td style="text-align:left">存储数据的成员变量</td><td style="text-align:left"><code>reg</code>或<code>wire</code></td></tr><tr><td style="text-align:center">方法method</td><td style="text-align:left">操作变量的子程序</td><td style="text-align:left">任务和函数</td></tr><tr><td style="text-align:center">原型prototype</td><td style="text-align:left"><code>extern</code>方法名和参数</td><td style="text-align:left">不支持</td></tr></tbody></table><h1 id="类">类</h1><h2 id="定义">定义</h2><ul><li>类是对象的模板，类中的成员变量用来保存数据，而子程序用来控制这些数值<ul><li>下例为一个通用事务的类，属性：地址、校验和、存储值的数组；方法：显示地址、计算数据校验和</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display();</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Transaction: %h&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">endfunction</span> : display  <span class="comment">// 标记label</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> calc_csm();</span><br><span class="line">        csm = addr ^ data<span class="variable">.xor</span>;</span><br><span class="line">    <span class="keyword">endfunction</span> : calc_csm</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endclass</span> : Transactoin</span><br></pre></td></tr></table></figure><blockquote><p>习惯性地使用标记，在有很多嵌套块的复杂代码中用处很大，可以很好地配对<code>end</code>、<code>endtask</code>、<code>endfunction</code>、<code>endclass</code></p></blockquote><h2 id="包">包</h2><ul><li>类应在<code>program</code>或<code>module</code>，或其外的<code>package</code>中定义</li><li>在<a href="../SV%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">SV数据类型</a>这篇文章中也曾介绍过包的概念，当时是用于封装常数和结构体，包还能用于封装类<ul><li>项目文件较多时，可以使用包<code>package</code>将一组相关的类和类型定义捆绑在一起</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件abc.svh</span></span><br><span class="line"><span class="keyword">package</span> abc;      <span class="comment">// $root.abc绝对路径</span></span><br><span class="line">    <span class="keyword">class</span> Transaction;</span><br><span class="line">        <span class="keyword">int</span> pd;   <span class="comment">// $root.abc.Transaction.pd</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试文件</span></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line">    <span class="keyword">import</span> abc::*；<span class="comment">// 导入包</span></span><br><span class="line">    <span class="keyword">int</span> d;         <span class="comment">// $root.test.d</span></span><br><span class="line">    Transaction tr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> xyz;</span><br><span class="line">        <span class="keyword">int</span> l;     <span class="comment">// $root.test.xyz.l</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line">    </span><br><span class="line">    ...            <span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure><h2 id="方法">方法</h2><ul><li>类中的程序也称为方法，即类的作用域内定义的内部<code>task</code>和<code>function</code></li><li>类中的方法默认使用自动存储，即隐式<code>automatic</code></li></ul><h3 id="原型方法">原型方法</h3><ul><li>为了提高代码可读性，可以在类外定义方法<ul><li>将方法的原型定义（方法名和参数）放在类的内部</li><li>方法的程序体放在类的后面定义</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> PCI_Tran;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, data;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">void</span> display();</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> PCI_Tran::display();</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;@0t: PCI: addr = %h, data = %h&quot;</span>, <span class="built_in">$time</span>, addr, data);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><h3 id="静态方法">静态方法</h3><ul><li>类中的自动变量必须通过类的实例（对象）访问</li><li>类的静态变量和静态方法属于类的全局资源，而非某个具体对象实例<ul><li>可以直接通过类名访问<code>类名::静态成员</code>，无需实例化对象</li><li>类作用域操作符<code>::</code>，用于明确指定访问类作用域中的成员</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Counter;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total_count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">function</span> <span class="keyword">void</span> display_statics();</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;display statics test&quot;</span>);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      Counter::total_count = <span class="number">100</span>;                            <span class="comment">// 修改静态变量</span></span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">&quot;total_count：%0d&quot;</span>, Counter::total_count);    <span class="comment">// 输出：100</span></span><br><span class="line">      Transaction::display_static();                         <span class="comment">// 调用静态方法</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h1 id="对象">对象</h1><ul><li>若将类视为描述房子结构的蓝图，而对象则是一幢可以实际居住的房子，房子的地址就是句柄</li></ul><h2 id="构造">构造</h2><ul><li>创建类的实例的过程被称为实例化，实例化后的类称为对象，<code>new()</code>函数被称为构造函数（Constructor）</li><li><code>new()</code>为对象分配空间，并初始化变量，构造完成后，返回保存对象的地址，即句柄<ul><li>创建对象时使用的是<code>new()</code>，而在创建<a href="../SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97">动态数组</a>大小时使用的是<code>new[]</code>，注意区分</li></ul></li></ul><h3 id="参数化构造">参数化构造</h3><ul><li>使用参数化<code>new()</code>可以实现自定义初始值，否则默认初始化二值变量为0、四值变量为X</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a = <span class="number">3</span>);</span><br><span class="line">        addr = a;</span><br><span class="line">        data = `&#123;<span class="keyword">default</span>:<span class="number">5</span>&#125;; <span class="comment">// 所有元素均为5</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Transaction tr;         <span class="comment">// 声明一个对象的句柄</span></span><br><span class="line">    tr = <span class="keyword">new</span>(<span class="variable">.a</span>(<span class="number">10</span>));       <span class="comment">// 构造对象，并返回句柄</span></span><br><span class="line">    <span class="comment">// 使用.a(10)则addr指定10，若未使用则addr默认3</span></span><br><span class="line">    <span class="comment">// data指定固定值，csm被初始化未默认值x</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>当方法的参数名或局部变量与类的成员变量同名时，使用<code>this</code>可以明确指定要访问的是当前对象的成员变量</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass;</span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data;  <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数：参数名与成员变量同名</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data);</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.data</span> = data; <span class="comment">// 用 &#x27;this&#x27; 指定左侧是成员变量</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法：局部变量与成员同名</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> set_data(<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data);</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.data</span> = data; <span class="comment">// 明确赋值给成员变量</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] get_data();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span><span class="variable">.data</span>; <span class="comment">// 显式返回成员变量（非必需，但清晰）</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">MyClass mc;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    mc = <span class="keyword">new</span>(<span class="variable">.data</span>(<span class="number">123</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="访问">访问</h2><h3 id="直接访问">直接访问</h3><ul><li>通过对象句柄直接访问成员变量或方法<ul><li>本质是直接操作对象内部数据，依赖成员变量的公有访问权限</li><li>SV中所有成员都是公有的，除非标记为私有<code>local</code>或<code>protected</code></li></ul></li><li>直接访问破坏封装性，适用于需要在测试平台的地方访问时<ul><li>外部代码需知晓内部数据结构，无法限制输入合法性，可能导致数据异常</li><li>一旦内部变量重命名或变更类型，外界所有直接访问的代码都需要同步更改</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Counter;</span><br><span class="line">  <span class="keyword">int</span> count; <span class="comment">// 公有成员，允许直接访问</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Counter c = <span class="keyword">new</span>();</span><br><span class="line">    c<span class="variable">.count</span> = <span class="number">10</span>; <span class="comment">// 合法赋值</span></span><br><span class="line">    c<span class="variable">.count</span> = -<span class="number">5</span>; <span class="comment">// 直接赋负值，破坏数据合法性（无保护）</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Count: %0d&quot;</span>, c<span class="variable">.count</span>); <span class="comment">// 输出 -5（错误状态）</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h3 id="访问函数">访问函数</h3><ul><li>通过类的访问函数间接访问内部数据<ul><li>本质是通过接口方法控制数据交互，内部数据通常被声明为<code>local</code>或<code>protected</code></li></ul></li><li>访问函数具备更好的安全性和可维护性，但同样也会使测试平台变得更大更复杂<ul><li>可在访问函数内添加验证逻辑，确保数据合法性，同时实现日志功能，这在直接访问中是无法实现的</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Counter;</span><br><span class="line">  <span class="keyword">local</span> <span class="keyword">int</span> count; <span class="comment">// 私有成员，默认类型，外部不可直接访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> get_count(); <span class="comment">// 读取count（getter），可附加日志</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;[LOG] get_count: %0d&quot;</span>, count); <span class="comment">// 记录访问日志</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> put_count(<span class="keyword">int</span> val); <span class="comment">// 修改count（putter），验证输入合法性</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">0</span>) <span class="keyword">begin</span> <span class="comment">// 检查输入合法性</span></span><br><span class="line">      <span class="built_in">$error</span>(<span class="string">&quot;[ERROR] Invalid count: %0d (must be non-negative)&quot;</span>, val);</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 拒绝非法值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    count = val;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;[LOG] put_count: %0d&quot;</span>, count); <span class="comment">// 记录修改日志</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Counter c = <span class="keyword">new</span>();</span><br><span class="line">    c<span class="variable">.put_count</span>(<span class="number">10</span>); <span class="comment">// 合法赋值，日志：[LOG] put_count: 10</span></span><br><span class="line">    c<span class="variable">.put_count</span>(-<span class="number">5</span>); <span class="comment">// 非法赋值，报错：[ERROR] Invalid count: -5...</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Current count: %0d&quot;</span>, c<span class="variable">.get_count</span>()); <span class="comment">// 日志：[LOG] get_count: 10，输出：10</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="方法-v2">方法</h2><h3 id="对象句柄">对象句柄</h3><ul><li>句柄本质是对象的引用，存储的是对象在内存中的地址<ul><li>通过修改句柄的值，可以让同一各句柄在仿真过程中先后指向不用的对象示例</li><li>而在Verilog中名字和内存是静态捆绑在一起的</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Transaction t1, t2; <span class="comment">// 声明两个句柄</span></span><br><span class="line">t1 = <span class="keyword">new</span>();         <span class="comment">// 构造第一个对象，并返回内存地址</span></span><br><span class="line">t2 = t1;            <span class="comment">// 复制内存地址，使t1和t2都指向第一个对象</span></span><br><span class="line">t1 = <span class="keyword">new</span>();         <span class="comment">// 构造第二个对象，并返回内存地址，此时t1指向第二个对象</span></span><br></pre></td></tr></table></figure><ul><li>当没有任何句柄指向一个对象时，SV会自动回收其内存，避免了忘记手动释放对象时可能发生的内存泄露<ul><li>若对象包含从一个<a href="../SV%E7%BA%BF%E7%A8%8B">线程</a>派生出的程序，只要线程仍在运行，对象的空间就不会释放</li><li>同样，被线程所使用的对象在该线程结束之前也不会解除分配</li></ul></li></ul><h3 id="静态句柄">静态句柄</h3><ul><li>当类中的变量声明和方法原型过多时，可以将类分成几个更小、相关的类</li><li>当类的每个实例都需要从同一个对象获取信息时，使用静态句柄可以避免内存的浪费<ul><li>注意使用类中类时，一定要先例化，否则其句柄是<code>null</code></li><li>若类中类在被包含类之后定义，需要使用<code>typedef</code>进行前向声明</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">class</span> Config;  <span class="comment">// 当Config在Transaction之后定义，需要前向声明</span></span><br><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">static</span> Config cfg; <span class="comment">// 使用静态存储的句柄，类中类</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Config;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">    </span><br><span class="line">Config cfg;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    cfg = <span class="keyword">new</span>(<span class="variable">.num_trans</span>(<span class="number">42</span>));     <span class="comment">// 例化对象，通过参数名传递初始值</span></span><br><span class="line">    Transaction::cfg = cfg;        <span class="comment">// 将已例化对象的句柄传递给类中类</span></span><br><span class="line">    <span class="comment">// 上述两行等同于Transaction::cfg = new(.(num_trans(42)));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="传递句柄">传递句柄</h3><ul><li>将句柄传递给方法，传递的是对象的句柄而非对象本身</li></ul><p><img src="/images/image-20250811144144482.png" alt="image-20250811144144482"></p><ul><li>被传递句柄的方法，可以修改共享对象，但不能修改原句柄的指向</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> transmit(<span class="keyword">input</span> Transaction t); <span class="comment">// 形参t是generator中的t的副本（按值传递）</span></span><br><span class="line">    t<span class="variable">.addr</span> = <span class="number">100</span>; <span class="comment">// 修改共享对象的addr，t.addr会变为100</span></span><br><span class="line">    t = <span class="keyword">new</span>();    <span class="comment">// 修改句柄t本身，让transmit中的t指向新对象，generator中的t仍指向原对象</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><ul><li>当所传递的句柄使用<code>ref</code>修饰时，被传递句柄的方法修改句柄，可以改变原句柄的指向<ul><li><code>ref</code>让形参与实参“绑定”为同一变量</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> create(<span class="keyword">ref</span> Transaction tr);</span><br><span class="line">    tr = <span class="keyword">new</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">Transaction t;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    create(t);           <span class="comment">// 在方法中创建一个transaction</span></span><br><span class="line">    <span class="built_in">$display</span>(t<span class="variable">.addr</span>);    <span class="comment">// 若无ref，则 t = null，未改变原句柄的指向</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="句柄数组">句柄数组</h3><ul><li>在搭建测试平台时，需要保存并引用许多对象，可以创建句柄数组，数组的每个元素指向一个对象</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> generator();</span><br><span class="line">    Transaction tarray[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (tarray[i]) <span class="keyword">begin</span></span><br><span class="line">        tarray[i] = <span class="keyword">new</span>();    <span class="comment">// 创建每个对象</span></span><br><span class="line">        transmit(tarray[i]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><h2 id="复制">复制</h2><ul><li>复制一个对象，以防止被传递句柄的方法修改原始对象的值</li></ul><h3 id="浅层复制">浅层复制</h3><ul><li>使用<code>new</code>操作符复制一个对象<ul><li>创建一个新的对象，并且复制现有对象的所有变量</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;In %m&quot;</span>);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction src, dst;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    src = <span class="keyword">new</span>();   <span class="comment">// 创建第一个对象</span></span><br><span class="line">    dst = <span class="keyword">new</span> src; <span class="comment">// 使用new操作符进行复制</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>使用<code>new</code>进行复制时，若类中包含一个指向另一个类的句柄，则只会复制句柄的值<ul><li>若对复制后的对象中的句柄进行操作，也会影响原型对象中的句柄所指向的对象</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Statistics;</span><br><span class="line">    <span class="keyword">time</span> startT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> start();</span><br><span class="line">        starrT = <span class="built_in">$time</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Statistics stats;              <span class="comment">// 指向另一个对象的句柄</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();                <span class="comment">// new复制时，构造不会再次执行，见下图中的id</span></span><br><span class="line">        stats = <span class="keyword">new</span>();             <span class="comment">// 构造一个新的Statistics对象</span></span><br><span class="line">        id = count++;              <span class="comment">// 每构造一个对象都有一个唯一的id</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction src, dst;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    src = <span class="keyword">new</span>();</span><br><span class="line">    src<span class="variable">.stats</span><span class="variable">.startT</span> = <span class="number">42</span>;</span><br><span class="line">    dst = <span class="keyword">new</span> src;                    <span class="comment">// 复制类中另一个对象句柄的值</span></span><br><span class="line">    dst<span class="variable">.stats</span><span class="variable">.startT</span> = <span class="number">96</span>;            <span class="comment">// 由于复制了同一个句柄的值，会同时改变dst和src中的stats</span></span><br><span class="line">    <span class="built_in">$display</span>(src<span class="variable">.stats</span><span class="variable">.startT</span>);       <span class="comment">// &quot;96&quot;而非&quot;42&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="/images/image-20250811170922501.png" alt="image-20250811170922501"></p><ul><li>若要复制一个不包含另一个对象句柄的简单类，编写简单的自定义<code>copy()</code>函数也能起到和使用<code>new</code>一样的效果</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];  <span class="comment">// 不包含指向另一个对象的句柄</span></span><br><span class="line">    <span class="keyword">function</span> Transaction copy();    <span class="comment">// 创建独立的对象那个副本</span></span><br><span class="line">        copy = <span class="keyword">new</span>();               <span class="comment">// 每次调用copy()时构造目标对象</span></span><br><span class="line">        copy<span class="variable">.addr</span> = addr;           <span class="comment">// 填入自定义数值</span></span><br><span class="line">        copy<span class="variable">.csm</span> = csm;</span><br><span class="line">        copy<span class="variable">.data</span> = data;           <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction src, dst;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    src = <span class="keyword">new</span>();</span><br><span class="line">    dst = src<span class="variable">.copy</span>();</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="深层复制">深层复制</h3><ul><li>对于并非简单的类，需要进行深层复制<ul><li>通过调用类所包含的所有对象的<code>copy</code>函数</li><li>在<code>copy()</code>函数中构造目标对象，避免出现只复制句柄值得情况</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Statistics;</span><br><span class="line">    <span class="keyword">time</span> startT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> start();</span><br><span class="line">        starrT = <span class="built_in">$time</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> Statistics copy();</span><br><span class="line">        copy = <span class="keyword">new</span>();             <span class="comment">// 每次调用copy()时构造目标对象</span></span><br><span class="line">        copy<span class="variable">.startT</span> = startT;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Statistics stats;              <span class="comment">// 指向另一个对象的句柄</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        stats = <span class="keyword">new</span>();</span><br><span class="line">        id = count++;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> Transaction copy();    <span class="comment">// 创建独立的对象那个副本</span></span><br><span class="line">        copy = <span class="keyword">new</span>();               <span class="comment">// 创建目标对象</span></span><br><span class="line">        copy<span class="variable">.addr</span> = addr;           <span class="comment">// 填入自定义数值</span></span><br><span class="line">        copy<span class="variable">.csm</span> = csm;</span><br><span class="line">        copy<span class="variable">.data</span> = data;</span><br><span class="line">        copy<span class="variable">.stats</span> = stats<span class="variable">.copy</span>();  <span class="comment">// 调用Statics::copy函数</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction src, dst;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    src = <span class="keyword">new</span>();</span><br><span class="line">    src<span class="variable">.stats</span><span class="variable">.startT</span> = <span class="number">42</span>;</span><br><span class="line">    dst = src<span class="variable">.copy</span>();                 <span class="comment">// 深层复制src</span></span><br><span class="line">    dst<span class="variable">.stats</span><span class="variable">.startT</span> = <span class="number">96</span>;            <span class="comment">// 仅改变dst的stats值</span></span><br><span class="line">    <span class="built_in">$display</span>(src<span class="variable">.stats</span><span class="variable">.startT</span>);       <span class="comment">// &quot;42&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p><img src="/images/image-20250811173731432.png" alt="image-20250811173731432"></p><blockquote><p>UVM数据宏会自动创建复制函数，无需手动编写它们。手动创建这些函数在添加变量时非常出错</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
            <tag> OOP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Eclipse指南</title>
      <link href="/Eclipse%E6%8C%87%E5%8D%97/"/>
      <url>/Eclipse%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="准备">准备</h1><h2 id="JDK安装">JDK安装</h2><ul><li><a href="https://adoptium.net/zh-CN">JDK</a>（Java Development Kit，Java开发工具包）是Java开发的核心基础，是支持Java程序开发、编译、调试和运行的完整工具集</li></ul><h2 id="Eclipse安装">Eclipse安装</h2><ul><li><a href="https://www.eclipse.org/downloads/">Eclipse</a>是一个开源的、用Java语言开发的可扩展IDE（Integrated Development Environment，集成开发工具），利用Eclipse可以方便地进行Java项目的开发</li></ul><h2 id="Inno-Setup安装">Inno Setup安装</h2><ul><li><a href="https://jrsoftware.org/isinfo.php">Inno Setup</a>是免费工具，可将JAR、JRE、工具链打包为自解压安装程序或单一EXE，运行时自动解压到临时目录并执行</li></ul><h1 id="入门">入门</h1><h2 id="新建项目">新建项目</h2><ul><li>点击顶部菜单栏 <code>File</code>-&gt;<code>New</code>-&gt;<code>Java Project</code></li><li>填入项目名，可包含数字、字母和下划线</li><li>选择JRE（Java运行环境），包含在JDK中</li><li>创建模块信息<code>module-info.java</code>，用来管理代码依赖关系</li></ul><p><img src="/images/image-20250806155331591.png" alt="image-20250806155331591"></p><h2 id="新建类">新建类</h2><ul><li>在左侧项目列表中展开<code>HelloGUI</code>，右键<code>src</code>-&gt;<code>New</code>-&gt;<code>Class</code></li><li>同时创建包名<code>first_gui</code>和类名<code>FirstWindow</code>，后续创建的所有类必须放在具体的包中</li><li>勾选<code>public static void main(String[] args)</code>，自动在类中生成<code>main</code>方法</li></ul><p><img src="/images/image-20250806160037458.png" alt="image-20250806160037458"></p><h2 id="管理依赖">管理依赖</h2><ul><li>编辑<code>module-info.jave</code>，声明依赖模块，使得类中能够使用<code>swing</code>组件用于开发</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> hello_gui &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.desktop; <span class="comment">// 允许本模块访问Swing组件所在的模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单窗口">简单窗口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> first_gui;                                      <span class="comment">// 声明包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;                             <span class="comment">// 导入Swing中的按键模板（基类）</span></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;                              <span class="comment">// 窗口模板</span></span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;                              <span class="comment">// 标签模板</span></span><br><span class="line"><span class="keyword">import</span> java.awt.FlowLayout;                             <span class="comment">// 布局模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstWindow</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;               <span class="comment">// 定义窗口类，继承JFrame</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">123</span>;   <span class="comment">// 版本号管理，符合Java规范</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FirstWindow</span><span class="params">()</span> &#123;                              <span class="comment">// 构造方法：初始化窗口</span></span><br><span class="line">        setTitle(<span class="string">&quot;First Window&quot;</span>);                       <span class="comment">// 设置窗口标题</span></span><br><span class="line">        setSize(<span class="number">400</span>, <span class="number">300</span>);                              <span class="comment">// 设置窗口宽400ppi，高300ppi）</span></span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); <span class="comment">// 设置关闭规则</span></span><br><span class="line">        setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());                    <span class="comment">// 设置布局，零件自动从左到右排列</span></span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Hello GUI！&quot;</span>);        <span class="comment">// 实例化标签</span></span><br><span class="line">        add(label);                                      <span class="comment">// 将零件1放到窗口中</span></span><br><span class="line"></span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;First Button&quot;</span>);    <span class="comment">// 实例化按键</span></span><br><span class="line">        add(button);                                     <span class="comment">// 将零件2放到窗口中</span></span><br><span class="line"></span><br><span class="line">        setVisible(<span class="literal">true</span>);                                <span class="comment">// 显示窗口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;             <span class="comment">// 程序入口</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FirstWindow</span>();                               <span class="comment">// 分配内存，执行构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行程序">运行程序</h2><ul><li>点击菜单栏绿色<code>Run</code>按键，或编辑区右键<code>Run As</code>-&gt;<code>Java Application</code></li></ul><p><img src="/images/image-20250806164356813.png" alt="image-20250806164356813"></p><h2 id="打包">打包</h2><ul><li>将Java GUI程序导出为<code>Runnable JAR</code></li><li>右键项目-&gt;<code>Export</code>-&gt;搜索并选择<code>Runnable JAR file</code></li><li>选择主类入口<code>FirstWindw - hello_gui</code>-&gt;选择保存路径</li><li>提取依赖库到JAR中<code>Extract required libraries into generated JAR</code></li></ul><p><img src="/images/image-20250807161959015.png" alt="image-20250807161959015"></p><h1 id="可视化">可视化</h1><h2 id="插件安装">插件安装</h2><ul><li>GUI操作<code>Help</code>-&gt;<code>Ecipse Marketplace</code>，搜索并安装<code>windowbuilder</code></li></ul><p><img src="/images/image-20250806135754663.png" alt="image-20250806135754663"></p><h2 id="操作">操作</h2><ul><li>GUI操作<code>File</code>-&gt;<code>New</code>-&gt;<code>Project...</code>，找到<code>WindowBuilder</code>-&gt;<code>SWT Designer</code>-&gt;<code>SWT/JFace Java Project</code>，填入项目名即可</li></ul><p><img src="/images/image-20250806143112247.png" alt="image-20250806143112247"></p><ul><li>创建后，右键<code>src</code>-&gt;<code>new</code>-&gt;<code>other</code>，找到<code>WindowBuilder</code>-&gt;<code>SWT Designer</code>-&gt;<code>SWT</code>-&gt;<code>Application Window</code>，填入文件名</li><li>点击编辑区底部的<code>Design</code>即可进行可视化编程</li></ul><p><img src="/images/image-20250806165258861.png" alt="image-20250806165258861"></p><h1 id="实践">实践</h1><ul><li><a href="../RISC-V-GCC-GUI">RISC-V GCC GUI</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Eclipse </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SV线程</title>
      <link href="/SV%E7%BA%BF%E7%A8%8B/"/>
      <url>/SV%E7%BA%BF%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="线程的使用">线程的使用</h1><h2 id="定义特性">定义特性</h2><ul><li>线程是独立运行的程序单元，线程（thread）与进程（process）经常互换使用</li><li>每个<code>initial</code>或<code>always</code>过程块均派生一个独立线程，仿真0时刻开始执行<ul><li><code>initial</code>及显式线程可主动结束</li><li><code>always</code>线程持续监控信号</li></ul></li><li>父线程可衍生多个子线程，如<code>fork</code>内嵌多个子块<ul><li><code>fork-join</code>结构可显式创建并行子线程，但必须等所有子线程执行完后才可进行后续的处理</li><li><code>begin-end</code>结构以顺序结构执行，可以用于过程块<code>initial</code>中，或用作<code>fork-join</code>中的一个顺序子线程</li></ul></li></ul><h2 id="并行线程">并行线程</h2><p><img src="/images/image-20250728173027785.png" alt="image-20250728173027785"></p><ul><li><code>fork-join</code>：所有子线程结束才继续后续代码<ul><li>标准Verilog语句，适用于需要等待所有并发任务完成的场景</li></ul></li><li><code>fork-join_any</code>：任一子线程结束即可继续后续代码<ul><li>SV引入的创建线程新方法，适用于等待首个任务响应，如超时控制等</li></ul></li><li><code>fork-join_none</code>：立即继续主线程，子线程后台并行<ul><li>SV引入的创建线程新方法，适用于启动异步任务，如监测信号等</li></ul></li><li><code>wait fork;</code>语句放在<code>fork-join</code>及其变体后，用于等待所有子线程结束</li></ul><h2 id="动态线程">动态线程</h2><ul><li>动态线程是在<strong>运行时</strong>通过显示语法（<code>fork-join</code>及其变体）创建的子线程，而<strong>非静态编译时</strong>定义的线程（<code>always</code>、<code>initial</code>、<code>fork-join</code>）<ul><li>允许类、任务或函数内部生成子线程，实现子线程与父线程并发运行</li><li>若线程使用<code>automatic</code>存储类，变量在每次调用时独立分配内存，避免多线竞争</li><li>子线程在启动后独立运行，可自动结束或通过同步机制（事件<code>event</code>、旗语<code>semaphore</code>、信箱<code>mailbox</code>）控制终止</li><li>常用于测试平台的事务处理、验证场景的并行激励生成等</li></ul></li><li>下例中，测试平台产生随机事务并发送到被测设计中，在等待被测设计回复的过程中，同时也不停止随机数据的产生</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test (bus_ifc<span class="variable">.TB</span> bus);</span><br><span class="line">    <span class="comment">//省略接口代码</span></span><br><span class="line">    <span class="comment">//当check_trans被调用时，将产生一个线程用来检测总线来获取匹配的事务数据</span></span><br><span class="line">    <span class="keyword">task</span> check_trans(<span class="keyword">input</span> Transaction tr);</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">wait</span> (bus<span class="variable">.cb</span><span class="variable">.data</span> == tr<span class="variable">.data</span>);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;@%0t: data match %d&quot;</span>, <span class="built_in">$time</span>, tr<span class="variable">.data</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join_none</span>             <span class="comment">//不阻塞的并发线程</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    </span><br><span class="line">    Transaction tr;           <span class="comment">// 声明事务类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">repeat</span> (<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">            tr = <span class="keyword">new</span>();       <span class="comment">//创建一个随机事务</span></span><br><span class="line">            `SV_RAND_CHECK(tr<span class="variable">.randomize</span>());</span><br><span class="line">            transmit(tr);     <span class="comment">//把事务发送到被测设计中</span></span><br><span class="line">            check_trans(tr);  <span class="comment">//并行等待被测设计回复</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure><h2 id="类的线程">类的线程</h2><ul><li>在类中创建线程，要求线程控制权与任务逻辑分离<ul><li>类内线程不应该在父类中启动，而是在任务<code>run</code>里产生，受到到子类控制</li><li>构造函数<code>new()</code>只用来对数值进行初始化，不启动任何线程</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Gen_drive;             <span class="comment">//带任务run的发生器/驱动器</span></span><br><span class="line">    <span class="keyword">task</span> run (<span class="keyword">input</span> <span class="keyword">int</span> n);  <span class="comment">//N个数据包的事务处理器</span></span><br><span class="line">        Packet p;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">repeat</span> (n) <span class="keyword">begin</span> <span class="comment">//顺序重复n次代码块</span></span><br><span class="line">                `SV_RAND_CHECK(p<span class="variable">.randomize</span>());</span><br><span class="line">                transmit(p);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join_none</span>            <span class="comment">//使用fork-join_none避免repeat(n)阻塞run()</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">task</span> transmit(<span class="keyword">input</span> Packet p);</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Gen_drive gen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    gen = <span class="keyword">new</span>();               <span class="comment">//调用构造函数，完成初始化</span></span><br><span class="line">    gen<span class="variable">.run</span>(<span class="number">10</span>);               <span class="comment">//启动类内线程</span></span><br><span class="line">    ...                        <span class="comment">//启动检验、监测和其他线程</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="线程的停止">线程的停止</h1><ul><li>在SV中，停止线程主要通过<code>disable</code>语句实现，避免使用暴力终止，如使用过时的<code>stop()</code></li></ul><h2 id="停止内部线程">停止内部线程</h2><ul><li>在<code>fork-join</code>块内使用<code>disable fork;</code>停止所有子进程<ul><li>使用<code>fork-join</code>把目标代码包围起来以限制<code>disable fork</code>语句的作用范围</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    check_trans(tr0);             <span class="comment">// 线程0，使用了动态线程中定义的一个任务</span></span><br><span class="line">    <span class="keyword">fork</span>                          <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            check_trans(tr1);     <span class="comment">// 线程1.1，父线程为线程1</span></span><br><span class="line">            check_trans(tr2);     <span class="comment">// 线程1.2</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">123</span> <span class="keyword">disable</span> <span class="keyword">fork</span>;        <span class="comment">// 除线程0外其余线程全部停止</span></span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="停止指定线程">停止指定线程</h2><ul><li>为线程指定标签，使用带标签的<code>disable</code>语句</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    check_trans(tr0);             <span class="comment">// 线程0</span></span><br><span class="line">    <span class="keyword">fork</span>                          <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">begin</span> : thread1</span><br><span class="line">            check_trans(tr1);     <span class="comment">// 线程1.1</span></span><br><span class="line">            check_trans(tr2);     <span class="comment">// 线程1.2</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">123</span> <span class="keyword">disable</span> thread1;     <span class="comment">// 保留线程0</span></span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>停止指定<code>fork-join</code>块中所有线程<ul><li>在下例中，如果正确的总线来得足够早，则等<code>wait</code>结构先完成，<code>fork-join_any</code>得以执行，之后的<code>disable</code>结束剩余的线程</li><li>如果正确的总线在<code>TIME_OUT</code>时延完成时没有到来，则会打印错误警告的信息，<code>fork-join_any</code>被执行，之后<code>disalbe</code>结束<code>wait</code>线程</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">parameter</span> TIME_OUT = <span class="number">1000</span>ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> check_trans(<span class="keyword">input</span> Transaction tr);</span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">fork</span> : timeout_block</span><br><span class="line">                <span class="keyword">begin</span>                             <span class="comment">// thread1 in timeout_block</span></span><br><span class="line">                    <span class="keyword">wait</span> (bus<span class="variable">.cb</span><span class="variable">.data</span> == tr<span class="variable">.data</span>);</span><br><span class="line">                    <span class="built_in">$display</span>(<span class="string">&quot;@%0t: data match %d&quot;</span>, <span class="built_in">$time</span>, tr<span class="variable">.data</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                #TIME_OUT <span class="built_in">$display</span>(<span class="string">&quot;@%0t: Error: timeout&quot;</span>, <span class="built_in">$time</span>); <span class="comment">// thread2</span></span><br><span class="line">            <span class="keyword">join_any</span></span><br><span class="line">            <span class="keyword">disable</span> timeout_block;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join_none</span>   <span class="comment">// 产生非阻塞的线程</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><h2 id="停止任务线程">停止任务线程</h2><ul><li>当从任务块内部停止该块时，将会停止所有由该任务启动的线程<ul><li>使用<code>disable</code>标签语句将停止所有所有使用这段代码的线程，不仅仅是当前线程</li></ul></li><li>在下例中，任务<code>wait_for_time_out</code>被调用三次，从而产生了三个线程<ul><li>线程0在<code>#2ns</code>延时后禁止了该任务，三个线程都启动了，但最终都停止了</li><li>如果这个任务位于多次实例化的驱动器类中，则其中的<code>disable</code>标签语句将停止所有块</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> wait_for_time_out (<span class="keyword">input</span> <span class="keyword">int</span> id);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                #<span class="number">2</span>ns;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;@%0t: disable wait_for_time_out&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">                disabel wait_for_time_out;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fork</span> : just_a_little</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;@%0t: %m: %0d entering thread&quot;</span>, <span class="built_in">$time</span>, id);</span><br><span class="line">            #TIME_OUT;</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;@%0t: %m: %0d done&quot;</span>, <span class="built_in">$time</span>, id); <span class="comment">// %m表示输出调用此语句的模块的层次路径</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><h1 id="线程间通信">线程间通信</h1><h2 id="IPC概念">IPC概念</h2><ul><li>每个线程都会和相邻的线程通信<ul><li>环境类需要知道发生器什么时候完成任务，以便及时终止测试平台还在运行的线程</li><li>如下图测试平台环境中的发生器把激励传递给代理</li></ul></li></ul><p><img src="/images/image-20250724095858230.png" alt="image-20250724095858230"></p><ul><li>所有数据交换和控制的同步被称为线程间的通信（Inter-Process Communication, IPC），本章介绍以下三种<ul><li>事件：用于控制多线程间的同步</li><li>旗语：用于控制多线程对共享资源的访问</li><li>信箱：用于控制多线程间的信息传递或者线程间通信</li></ul></li></ul><h2 id="事件">事件</h2><h3 id="事件操作">事件操作</h3><ul><li>触发事件（Trigger）：通过<code>-&gt;</code>操作符通知事件发生</li><li>等待事件（Wait）：通过阻塞线程知道事件被触发<ul><li>边沿敏感型：<code>@</code>，检测事件的上升沿，从无触发到触发</li><li>电平敏感型：SV引入<code>wait(event_example.triggered)</code>，检测事件是否已经被触发过</li></ul></li></ul><h3 id="事件竞争">事件竞争</h3><ul><li>在同一仿真时间步内，多个线程因时间等待与触发顺序不确定而发生的竞争状态，导致在不同的仿真器中运行的结果可能不同<ul><li>下例中，先执行B？A永远阻塞</li><li>先执行A？A需要捕获事件才继续</li><li>同时执行？取决于仿真器</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> my_event;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>         <span class="comment">// 进程A</span></span><br><span class="line">  @my_event;          <span class="comment">// 事件等待</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Process A activated&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>          <span class="comment">// 进程B</span></span><br><span class="line">  -&gt; my_event;         <span class="comment">// 事件触发</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Process B triggered&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>若在循环中使用<code>wait(handshake.triggered)</code>，需确保在<strong>下次等待所处的仿真时间步不能与本次等待的相同</strong>，否则代码进入一个零时延循环<ul><li>若时间步不变，<code>.triggered</code>不会重置，<code>wait</code>再次立即通过，形成无线循环</li><li>可以使用边沿敏感型等待事件，避免<code>.triggered</code>不重置的问题</li><li>或使用<code>#0</code>使进程挂起指导指定延时结束，当恢复执行，时间已推进</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">forever</span> <span class="keyword">begin</span> <span class="comment">// 这是一个零时延循环，造成仿真的不确定</span></span><br><span class="line">    <span class="keyword">wait</span>(handshake<span class="variable">.triggered</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Received next event&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">forever</span> <span class="keyword">begin</span> <span class="comment">// 使用边沿敏感或时延+电平敏感避免零时延循环</span></span><br><span class="line">    @handshake;</span><br><span class="line">    <span class="comment">// #0 wait(handshake.triggered);</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Received next event&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="事件传递">事件传递</h3><ul><li>在SV中，事件作为同步对象的句柄，可以传递给子程序<ul><li>允许在对象间共享事件，不用把事件定义成全局的，最常见的方式是把事件传递到一个对象的构造器中</li><li>下例中，一个事件被事务处理器用来作为其执行完毕的标志信号</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line">    <span class="keyword">class</span> generator;</span><br><span class="line">        <span class="keyword">event</span> done;</span><br><span class="line">        <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">input</span> <span class="keyword">event</span> done);   <span class="comment">// 从测试平台传来事件</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.done</span> = done;              <span class="comment">// 同步句柄：测试平台中的gen_done与类中的done同步</span></span><br><span class="line">        <span class="keyword">endfunction</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">task</span> run();</span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    ...                     <span class="comment">// 创建事务</span></span><br><span class="line">                    -&gt; done;                <span class="comment">// 告知测试程序任务已完成</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">join_none</span></span><br><span class="line">        <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">event</span> gen_done;</span><br><span class="line">    generator gen;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        gen = <span class="keyword">new</span>(gen_done);                 <span class="comment">// 测试程序实例化</span></span><br><span class="line">        gen<span class="variable">.run</span>();                           <span class="comment">// 运行事务处理器</span></span><br><span class="line">        <span class="keyword">wait</span>(gen_done<span class="variable">.triggered</span>);            <span class="comment">// 等待任务结束</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure><h3 id="多事件等待">多事件等待</h3><ul><li>上例中只有单个发生器释放单个时间，如果测试环境类有N个发生器，必须等待多个子线程完成</li><li>传递事件句柄等待多事件<ul><li>使用<code>wait fork</code>来等待所有子线程约束</li><li>也可以使用<code>wait_order(event1, event2)</code>来等待指定顺序的事件</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> done[N_GENERATORS];         <span class="comment">// 定义N个发生器的阻塞事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (gen[i]) <span class="keyword">begin</span></span><br><span class="line">        gen[i] = <span class="keyword">new</span>(done[i]);    <span class="comment">// 创建N个发生器</span></span><br><span class="line">        gen[i]<span class="variable">.run</span>();             <span class="comment">// 发生器开始运行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (gen[i])</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">automatic</span> <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="keyword">wait</span> (done[k]<span class="variable">.trriggered</span>);</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wait</span> <span class="keyword">fork</span>;                     <span class="comment">// 等待所有触发事件完成</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>通过对触发事件进行计数来等待多个线程</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">event</span> done[N_GENERATORS];</span><br><span class="line"><span class="keyword">int</span> done_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (gen[i]) <span class="keyword">begin</span></span><br><span class="line">        gen[i] = <span class="keyword">new</span>(done[i]);       <span class="comment">// 创建N个发生器</span></span><br><span class="line">        gen[i]<span class="variable">.run</span>();                <span class="comment">// 发生器开始运行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (gen[i])</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">automatic</span> <span class="keyword">int</span> k = i;</span><br><span class="line">            done_count++;</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wait</span> (done_count == N_GENERATORS); <span class="comment">// 等待触发</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>使用线程计数来等待多个线程<ul><li>使用类作用域分辨操作符<code>::</code>：用于明确指定访问某个类作用域内的成员</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Generator;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> thread_count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">task</span> run();</span><br><span class="line">        thread_count++;         <span class="comment">// 启动另一个线程</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                ...             <span class="comment">// 实际事务代码</span></span><br><span class="line">                thread_count--;   <span class="comment">// 事务完成时，线程数目减一</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Generator gen[N_GENERATORS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (gen[i])</span><br><span class="line">        gen[i] = <span class="keyword">new</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (gen[i])</span><br><span class="line">        gen[i]<span class="variable">.run</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wait</span> (Generator::thead_count == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="旗语">旗语</h2><h3 id="基本特性">基本特性</h3><ul><li>作用：一种同步机制，用于控制多线程对共享资源的访问</li><li>类型：旗语<code>semaphore</code>是SV内置类，维护一个可用资源数量计数器</li></ul><h3 id="操作方法">操作方法</h3><ul><li>创建旗语：<code>semaphore sem = new(1);</code><ul><li>包含两步操作：声明旗语变量<code>semaphore sem;</code>，创建旗语并初始化计数器为1<code>sem = new(1);</code></li></ul></li><li>获取钥匙：<code>sem.get(1);</code><ul><li>进程访问共享资源前，通过<code>get()</code>获取钥匙，减少计数器，若钥匙不足则阻塞等待</li><li>多个阻塞线程以先进先出（FIFO）的方式排队</li></ul></li><li>归还钥匙：<code>sem.put(1);</code><ul><li>访问完成后，通过<code>put()</code>归还钥匙，增加计数器，允许其他进程获取</li><li>注意归还的钥匙可以比取出来的多</li></ul></li><li>尝试获取：<code>sem.try_get(1);</code><ul><li>尝试获取一把钥匙，成功返回<code>1</code>，失败返回<code>0</code>，非阻塞</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">semaphore sem = <span class="keyword">new</span>(<span class="number">1</span>); <span class="comment">// 创建含1把钥匙的信号量</span></span><br><span class="line">process_A: <span class="keyword">begin</span></span><br><span class="line">    sem<span class="variable">.get</span>(<span class="number">1</span>);         <span class="comment">// 获取钥匙</span></span><br><span class="line">    shared_var = ...;   <span class="comment">// 安全访问共享变量</span></span><br><span class="line">    sem<span class="variable">.put</span>(<span class="number">1</span>);         <span class="comment">// 归还钥匙</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">process_B: <span class="keyword">begin</span></span><br><span class="line">    sem<span class="variable">.get</span>(<span class="number">1</span>);         <span class="comment">// 若钥匙被占用，则阻塞等待</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="信箱">信箱</h2><p><img src="/images/image-20250804105625565.png" alt="image-20250804105625565"></p><h3 id="基本特性-v2">基本特性</h3><ul><li>作用：用于并发线程间的数据交换</li><li>类型：信箱<code>mailbox</code>是SV内置类，维护一个有界或无界的消息队列<ul><li>有界：固定容量，满时阻塞；无界，理论上无限容量</li></ul></li></ul><h3 id="操作方法-v2">操作方法</h3><ul><li>创建信箱<ul><li>声明参数化信箱，可以强制邮箱使用一种数据类型</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mailbox mbx;   <span class="comment">// 声明信箱变量</span></span><br><span class="line">mbx = <span class="keyword">new</span>();   <span class="comment">// 创建无界信箱</span></span><br><span class="line">mbc = <span class="keyword">new</span>(<span class="number">10</span>); <span class="comment">// 创建有界信箱，容量为10</span></span><br><span class="line"></span><br><span class="line">mailbox <span class="variable">#(int) int_mbx = new()</span>;    <span class="comment">// 只能存放int类型的信箱</span></span><br><span class="line">mailbox <span class="variable">#(string) str_mbx = new()</span>; <span class="comment">// 只能存放string类型的信箱</span></span><br><span class="line">int_mbx<span class="variable">.put</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// int_mbx.put(&quot;hello&quot;);           // 编译错误，类型不匹配</span></span><br></pre></td></tr></table></figure><ul><li>放入数据：<code>mbx.put(data)</code><ul><li>生产方将<code>data</code>放入信箱，若信箱满则阻塞</li><li>数据可以是整数、任意宽度<code>logic</code>或句柄</li></ul></li><li>获取数据：<code>mbx.get(data)</code><ul><li>消费方从信箱获取数据到<code>data</code>变量，同时在信箱中移除，若信箱空则阻塞</li></ul></li><li>尝试放入：<code>mbx.try_put(data)</code><ul><li>尝试放入数据，成功返回1，信箱满返回0，非阻塞</li></ul></li><li>尝试获取：<code>mbx.try_get(data)</code><ul><li>尝试获取数据，成功返回1，信箱空返回0，非阻塞</li></ul></li><li>探视数据：<code>mbx.peek(data)</code><ul><li>探视信箱里的数据但不将其移除</li><li>允许接收方检查数据内容后再决定是否处理</li><li>允许同一数据可以被多个线程查看</li></ul></li><li>获取数量：<code>mbx.num()</code><ul><li>返回信箱中当前消息的数量</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">mailbox <span class="variable">#(int) mbx = new(5)</span>;    <span class="comment">// 容量为5的有界参数化信箱，指定存储整型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) <span class="keyword">begin</span></span><br><span class="line">    mbx<span class="variable">.put</span>(i);          <span class="comment">// 放入数据</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Produced: %0d&quot;</span>, i);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">int</span> received;</span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">    mbx<span class="variable">.get</span>(received);   <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Consumed: %0d&quot;</span>, received);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Next配置</title>
      <link href="/Next%E9%85%8D%E7%BD%AE/"/>
      <url>/Next%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Next部署">Next部署</h1><h2 id="安装更新">安装更新</h2><ul><li>在站点根目录下安装<a href="https://github.com/next-theme/hexo-theme-next?tab=readme-ov-file">NEXT_8.x仓库</a><ul><li>首次安装：<code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></li><li>后续更新：<code>git -C themes/next pull</code></li></ul></li><li>安装完成后，更改站点配置文件<code>theme: next</code></li></ul><h2 id="备用配置">备用配置</h2><ul><li>传统配置NEXT主题的方式是直接编辑主题配置文件（<code>themes/next/_config.yml</code>），然而在升级主题时配置文件会被覆盖，因此使用备用主题配置的方法</li><li>在站点根目录中创建备用主题配置文件<code>cp themes/next/_config.yml _config.next.yml</code><ul><li>或者只将修改的部分放到<code>_config.next.yml</code>中，默认的部分不放入</li></ul></li></ul><h1 id="主题设置">主题设置</h1><ul><li>Next 8.x支持原生黑夜主题，主要在主题配置文件<code>_config.next.yml</code>中配置<code>darkmode: true</code><ul><li>此后根据系统偏好自动决定是否启用黑夜主题</li></ul></li><li>上述方法缺少主动切换网页端主动切换的按键，可以通过插件解决<ul><li>关闭原生黑夜主题<code>darkmode: false</code></li><li>安装插件<code>npm install hexo-next-darkmode --save</code></li><li>在主题配置文件中添加如下内容</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Darkmode JS</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/rqh656418510/hexo-next-darkmode, https://github.com/sandoche/Darkmode.js</span></span><br><span class="line"><span class="attr">darkmode_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="string">&#x27;64px&#x27;</span> <span class="comment"># default: &#x27;32px&#x27;</span></span><br><span class="line">  <span class="attr">right:</span> <span class="string">&#x27;32px&#x27;</span> <span class="comment"># default: &#x27;32px&#x27;</span></span><br><span class="line">  <span class="attr">left:</span> <span class="string">&#x27;unset&#x27;</span> <span class="comment"># default: &#x27;unset&#x27;</span></span><br><span class="line">  <span class="attr">time:</span> <span class="string">&#x27;0.5s&#x27;</span> <span class="comment"># default: &#x27;0.3s&#x27;</span></span><br><span class="line">  <span class="attr">mixColor:</span> <span class="string">&#x27;transparent&#x27;</span> <span class="comment"># default: &#x27;#fff&#x27;</span></span><br><span class="line">  <span class="attr">backgroundColor:</span> <span class="string">&#x27;transparent&#x27;</span> <span class="comment"># default: &#x27;#fff&#x27;</span></span><br><span class="line">  <span class="attr">buttonColorDark:</span> <span class="string">&#x27;#100f2c&#x27;</span> <span class="comment"># default: &#x27;#100f2c&#x27;</span></span><br><span class="line">  <span class="attr">buttonColorLight:</span> <span class="string">&#x27;#fff&#x27;</span> <span class="comment"># default: &#x27;#fff&#x27;</span></span><br><span class="line">  <span class="attr">isActivated:</span> <span class="literal">false</span> <span class="comment"># default false</span></span><br><span class="line">  <span class="attr">saveInCookies:</span> <span class="literal">true</span> <span class="comment"># default: true</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">&#x27;🌓&#x27;</span> <span class="comment"># default: &#x27;&#x27;</span></span><br><span class="line">  <span class="attr">autoMatchOsTheme:</span> <span class="literal">true</span> <span class="comment"># default: true</span></span><br><span class="line">  <span class="attr">libUrl:</span> <span class="comment"># Set custom library cdn url for Darkmode.js</span></span><br></pre></td></tr></table></figure><h1 id="信息设置">信息设置</h1><h2 id="图标">图标</h2><ul><li>搜索favicon设置图标，<a href="https://www.iconfont.cn/">图标素材网站</a></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-A.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-A.png</span></span><br><span class="line">  <span class="attr">large:</span> <span class="string">/images/favicon-48x48-A.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/favicon-A.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure><h2 id="版权说明">版权说明</h2><ul><li>使用<code>by-nc-sa</code>协议，显示版权说明</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="菜单设置">菜单设置</h1><ul><li>打开themes/next目录下的主题配置文_config.yml，查找menu</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="comment"># tags: /tags/ || fa fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure><ul><li>根目录下使用命令在source中建立文件夹<ul><li><code>hexo new page &quot;categories&quot;</code></li><li><code>hexo new page &quot;tags&quot;</code></li></ul></li><li>修改所生成文件夹中的index.md文件自定义标题</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2025-07-09 11:44:14</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure><h1 id="侧边栏设置">侧边栏设置</h1><h2 id="头像">头像</h2><ul><li>自定义头像、设置头像圆形显示并随鼠标旋转</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/A.png</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="目录">目录</h2><ul><li>开启标题自动编号、禁止目录自动换行、启用默认展开所有目录</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span>      <span class="comment">#目录项前显示数字序号</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span>       <span class="comment">#文章过长时是否自动换行</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span>  <span class="comment">#是否默认展开所有层级目录</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span>      <span class="comment">#生成目录的最大标题深度</span></span><br></pre></td></tr></table></figure><h1 id="页脚设置">页脚设置</h1><ul><li>启用图标动态化、关闭<code>Powered by</code>显示</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#ff0000&quot;</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h1 id="正文设置">正文设置</h1><h2 id="标签图标">标签图标</h2><ul><li>设置文末的标签使用图标代替<code>#</code>符号</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="其他设置">其他设置</h1><h2 id="正文对齐">正文对齐</h2><ul><li>左右对齐更改为根据左对齐，以适配窄屏设备</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">text_align:</span></span><br><span class="line">  <span class="comment"># Available values: start | end | left | right | center | justify | justify-all | match-parent</span></span><br><span class="line">  <span class="attr">desktop:</span> <span class="string">start</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="string">start</span></span><br></pre></td></tr></table></figure><h2 id="代码块渲染">代码块渲染</h2><ul><li>设置代码框为MAC样式，开启复制按键，并设置代码块自动折叠</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br><span class="line">  <span class="attr">fold:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure><h2 id="浏览进度">浏览进度</h2><ul><li>在返回顶部按键中显示当前阅读进度</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="外部库">外部库</h1><h2 id="预加载">预加载</h2><ul><li>启用<code>pjax</code>进行预加载</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Easily enable fast Ajax navigation on your website.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/next-theme/pjax</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="图片放大">图片放大</h2><ul><li>图片视频放大浏览</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.</span></span><br><span class="line"><span class="comment"># For more information: https://fancyapps.com/fancybox/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="中英文显示">中英文显示</h2><ul><li>自动在页面上所有的汉字和英文数字符号之间插入一个空格</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatically insert whitespace between CJK and half-width characters.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/vinta/pangu.js</span></span><br><span class="line"><span class="comment"># Server-side plugin: https://github.com/next-theme/hexo-pangu</span></span><br><span class="line"><span class="attr">pangu:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="快速链接">快速链接</h2><ul><li>在空闲时间预加载页面链接，来加快后续页面的加载速度</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">quicklink:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">home:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archive:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">delay:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h1 id="搜索服务">搜索服务</h1><ul><li>开启本地搜索服务</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span>     <span class="comment">#每篇文章显示的结果数</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span>          <span class="comment">#是否转义HTML特殊字符</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span>           <span class="comment">#是否预加载搜索结果</span></span><br></pre></td></tr></table></figure><h1 id="自定义文件"><a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html#Examples-of-Modifying-Layout">自定义文件</a></h1><ul><li>将自定义文件与主题文件分开，避免因<code>git merge</code>（<code>git pull</code>包含拉取更新和合并分支两个操作）而产生的冲突</li><li>将自定义文件添加到<code>hexo-site/source/_data</code>，随后取消备用主题配置文件中对应的注释即可</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyStart: source/_data/post-body-start.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment">#style: source/_data/styles.styl</span></span><br></pre></td></tr></table></figure><h2 id="标题编号">标题编号</h2><ul><li>对于Hexo-NEXT渲染的html文件，默认为TOC自动添加编号，但是缺少对正文标题编号的自动添加</li><li>首先在<code>hexo-site/source./_data</code>中新建<code>styles.styl</code>文件，取消<code>_config.next.yml</code>中的注释</li><li>往<code>hexo-site/source./_data/styles.styl</code>中添加如下代码</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.post-block</span> &#123;</span><br><span class="line">  <span class="selector-class">.post-body</span> &#123;<span class="attribute">counter-reset</span>: h1&#125;</span><br><span class="line">          <span class="selector-tag">h1</span> &#123;<span class="attribute">counter-reset</span>: h2&#125;</span><br><span class="line">          <span class="selector-tag">h2</span> &#123;<span class="attribute">counter-reset</span>: h3&#125;</span><br><span class="line">          <span class="selector-tag">h3</span> &#123;<span class="attribute">counter-reset</span>: h4&#125;</span><br><span class="line">          <span class="selector-tag">h4</span> &#123;<span class="attribute">counter-reset</span>: h5&#125;</span><br><span class="line">          <span class="selector-tag">h5</span> &#123;<span class="attribute">counter-reset</span>: h6&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-body</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h1; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h2; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h3</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h3; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h4</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h4; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h5</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h5; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h6</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h6; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h6) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="页脚自定义">页脚自定义</h2><ul><li>在<code>hexo-site/source./_data</code>中新建<code>footer.njk</code>文件，取消<code>_config.next.yml</code>中的注释</li><li>往<code>hexo-site/source./_data/footer.njk</code>中添加如下代码</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;custom-<span class="selector-tag">footer</span>&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">p</span>&gt;自定义文字&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure><h1 id="修改源码">修改源码</h1><ul><li>对于<code>8.23.2</code>版本的Next，无法在只修改自定义文件的前提下实现以下功能，注意做好版本更新时的迁移</li><li>虽然实测可行，但出于更新风险的考虑，以下所有功能已弃用，源码恢复原样</li></ul><h2 id="球形标签云">球形标签云</h2><ul><li>右键另存<a href="https://www.goat1000.com/tagcanvas.js">tagcanvas.js</a>入<code>next-site/source/js</code>路径下</li><li>在<code>next-site/source/js</code>路径下创建文件<code>tagcloud.js</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title class_">TagCanvas</span>.<span class="title class_">Start</span>(<span class="string">&#x27;my3DTags&#x27;</span>, <span class="string">&#x27;tags&#x27;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">textFont</span>: <span class="string">&#x27;Georgia,Optima&#x27;</span>,</span><br><span class="line">                <span class="attr">textColour</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">outlineColour</span>: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">                <span class="attr">weight</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">reverse</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">depth</span>: <span class="number">0.8</span>,</span><br><span class="line">                <span class="attr">maxSpeed</span>: <span class="number">0.05</span>,</span><br><span class="line">                <span class="attr">bgRadius</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">freezeDecel</span>: <span class="literal">true</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">document</span></span><br><span class="line">            .<span class="title function_">getElementById</span>(<span class="string">&#x27;myTags&#x27;</span>)</span><br><span class="line">            .<span class="property">style</span></span><br><span class="line">            .<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>如下修改<code>next-site/layout/_partials/pages/tags.njk</code></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;tag-cloud&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tag-cloud-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; _p(&#x27;counter.tag_cloud&#x27;, site.tags.length) &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tag-cloud-tags&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; tagcloud(&#123;</span></span><br><span class="line"><span class="language-xml">      min_font: theme.tagcloud.min,</span></span><br><span class="line"><span class="language-xml">      max_font: theme.tagcloud.max,</span></span><br><span class="line"><span class="language-xml">      amount  : theme.tagcloud.amount,</span></span><br><span class="line"><span class="language-xml">      orderby : theme.tagcloud.orderby,</span></span><br><span class="line"><span class="language-xml">      order   : theme.tagcloud.order,</span></span><br><span class="line"><span class="language-xml">      class   : &#x27;tag-cloud&#x27;</span></span><br><span class="line"><span class="language-xml">      &#125;)</span></span><br><span class="line"><span class="language-xml">    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#123;# 球形云标签 #&#125;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;tags&quot;</span> id=<span class="string">&quot;myTags&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;720&quot;</span> <span class="attr">height</span>=<span class="string">&quot;720&quot;</span> <span class="attr">id</span>=<span class="string">&quot;my3DTags&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: block;margin: 0 auto;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tags&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; tagcloud(&#123;</span></span><br><span class="line"><span class="language-xml">          min_font   : 16,</span></span><br><span class="line"><span class="language-xml">          max_font   : 35,</span></span><br><span class="line"><span class="language-xml">          amount     : 999,</span></span><br><span class="line"><span class="language-xml">          color      : false,</span></span><br><span class="line"><span class="language-xml">          start_color: &#x27;black&#x27;,</span></span><br><span class="line"><span class="language-xml">          end_color  : &#x27;green&#x27;</span></span><br><span class="line"><span class="language-xml">        &#125;)</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcloud.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &#123;# 球形云标签 #&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><ul><li>在站点配置文件中添加如下开关</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">crashcheat:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tagcanvas:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Next </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SV过程与子程序</title>
      <link href="/SV%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/"/>
      <url>/SV%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="过程语句">过程语句</h1><h2 id="概念">概念</h2><ul><li><code>initial</code>语句<ul><li>用于初始化行为建模，仅在仿真开始时执行一次</li></ul></li><li><code>always</code>语句<ul><li>用于持续执行的行为建模，仿真过程中重复执行</li><li>需要明确列出敏感事件列表</li></ul></li><li>SV扩展了<code>always</code>块<ul><li><code>always_comb</code>：自动推断组合逻辑敏感列表，避免遗漏信号</li><li><code>always_ff</code>：明确用于时序逻辑，需指定时钟和复位条件</li><li><code>always_latch</code>：专为锁存器设计，明确设计意图，提高可维护性</li></ul></li></ul><h2 id="赋值规则">赋值规则</h2><ul><li>阻塞赋值<code>=</code><ul><li>按代码顺序立即执行，适用于组合逻辑建模</li><li>执行时后续语句需等待当前赋值完成</li></ul></li><li>非阻塞赋值<code>&lt;=</code><ul><li>赋值操作并行执行，适用于时序逻辑</li><li>在时钟边沿捕获当前值，结束后统一更新结果，避免竞争风险</li></ul></li><li>限制<ul><li>过程赋值的被赋值变量必须是寄存器类型（<code>reg</code>或<code>logic</code>），并且只能在过程块中使用</li><li>区别于连续赋值<code>assign</code>只能驱动线网类型</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> xor_comb(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> a, b,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        out = a ^ b;  <span class="comment">// 阻塞赋值，组合逻辑</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> d_latch(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> enable, d,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> q</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_latch</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (enable) <span class="keyword">begin</span></span><br><span class="line">            q = d;  <span class="comment">// 当enable为高时，q锁存d的值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> d_flipflop(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, d,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> q</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            q &lt;= <span class="number">0</span>;  <span class="comment">// 复位时q置0</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            q &lt;= d;  <span class="comment">// 时钟上升沿时q更新为d</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h1 id="子程序">子程序</h1><h2 id="任务与函数">任务与函数</h2><ul><li>任务用于封装可包含时序控制的行为代码块<ul><li>延时<code>#</code>、事件触发<code>@</code>、等待<code>wait</code></li></ul></li><li>无返回值，支持<code>input</code>、<code>output</code>、<code>inout</code>参数<ul><li>无输入输出时空括号可省略</li><li>只有输入时，<code>input</code>可省略</li></ul></li><li><code>begin ... end</code>不再是必需的，但必须使用通用的输入类型<code>logic</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">task</span> send_data(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data, <span class="keyword">output</span> <span class="keyword">bit</span> ack);</span><br><span class="line">   #<span class="number">10</span>;          <span class="comment">// 延时10个时间单位</span></span><br><span class="line">   ack = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure><ul><li>函数用于纯计算或组合逻辑，无任何时序控制，执行时间为0</li><li>必须至少有一个输入参数，通过函数名返回单一值</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add(<span class="keyword">input</span> <span class="keyword">int</span> a, b);</span><br><span class="line">   <span class="keyword">return</span> a + b;  <span class="comment">// 直接返回计算结果</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><h2 id="子程序参数">子程序参数</h2><h3 id="引用传参">引用传参</h3><ul><li>在SV中，参数的传递除了可以使用<code>input</code>、<code>output</code>、<code>inout</code>进行复制外，还可以使用引用的方式传参</li><li>核心：使用<code>ref</code>实现对变量的直接引用（类似指针）<ul><li>避免大型数据（如结构体、数组）的复制开销，提升性能</li><li>子程序内部对ref参数的修改立即可见于外部调用者</li></ul></li><li>使用规则<ul><li>只使用于变量，不支持线网类型</li><li>多个并发子程序通过<code>ref</code>访问同一变量时，可能导致数据竞争<ul><li>为避免竞争，可以使用<a href="../SV%E7%BA%BF%E7%A8%8B">旗语或信箱</a>等方式进行同步或传递副本</li></ul></li><li>与<code>const</code>联合使用，声明可强制引用为只读，防止意外修改</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> print_sum(<span class="keyword">const</span> <span class="keyword">ref</span> <span class="keyword">int</span> arr[]);</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">foreach</span>(arr[i]) sum += arr[i];</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Sum: %0d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><h3 id="参数的缺省值">参数的缺省值</h3><ul><li>在声明函数时为部分或全部参数预设缺省值（默认值），当调用函数时，若未显示传入，则使用缺省值<ul><li>使用-1或其他任何越界值作为缺省值，便于获知调用时是否有指定值</li></ul></li><li>显示指定参数名<code>.parameter_name(value)</code><ul><li>使用名字进行传参，允许直接关联参数名与值，而不依赖参数在模块定义中的声明顺序</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">void</span> print_csm(<span class="keyword">const</span> <span class="keyword">ref</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] a[],</span><br><span class="line">                                  <span class="keyword">input</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] low = <span class="number">0</span>,</span><br><span class="line">                                  <span class="keyword">input</span> <span class="keyword">int</span> high = -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] checksum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (high == -<span class="number">1</span> || hign &gt;= a<span class="variable">.size</span>())</span><br><span class="line">        high = a<span class="variable">.size</span>()-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++)</span><br><span class="line">        checksum ^= a[i];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;The array checksum is %h&quot;</span>, checksum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">print_csm(a);        <span class="comment">//check a[0:size()-1]</span></span><br><span class="line">print_csm(a, <span class="number">2</span>, <span class="number">4</span>);  <span class="comment">//check a[2:4]</span></span><br><span class="line">print_csm(a, <span class="number">1</span>);     <span class="comment">//check a[1:size()-1]</span></span><br><span class="line">print_csm(a,, <span class="number">2</span>);    <span class="comment">//check a[0:2]</span></span><br><span class="line">print_csm();         <span class="comment">//编译错误，a无缺省值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示指定参数名，若low &gt; high or a.size()，for循环不执行 </span></span><br><span class="line">print_csm(a, <span class="variable">.c</span>(<span class="number">3</span>)); <span class="comment">//check a[3:size()-1]</span></span><br></pre></td></tr></table></figure><h2 id="子程序的返回">子程序的返回</h2><h3 id="显式返回">显式返回</h3><ul><li><code>void</code>函数无返回值，非<code>void</code>函数必须提供返回值<ul><li><code>return</code>关键词适用于单个返回值的函数</li><li>多返回值需用<code>output</code>或结构体</li></ul></li><li>在任何函数中，<code>return</code>语句都可用于发现错误提前终止退出<ul><li>SV支持<code>return</code>关键词灵活退出，而Verilog仅能在<code>endfunciton</code>处返回</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示返回</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">  <span class="keyword">return</span> a + b; <span class="comment">// 必须显式返回</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="comment">//提前退出</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> check(<span class="keyword">int</span> a);</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 提前退出</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Valid value&quot;</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure><h3 id="隐式返回">隐式返回</h3><ul><li>当函数名被赋值时，函数名即返回变量，无需显示<code>return</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> array_t [<span class="number">5</span>];  <span class="comment">//自定义数组类型</span></span><br><span class="line">array_t at;</span><br><span class="line"><span class="keyword">function</span> array_t init(<span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (init[i])</span><br><span class="line">        init[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    at = init(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (at[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;at[%0d] = %0d&quot;</span>, i ,at[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h3 id="数组的返回">数组的返回</h3><ul><li>上述数组或结构体的返回除上面的例子外，还可以用引用参数实现</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">void</span> init (<span class="keyword">ref</span> <span class="keyword">int</span> f[<span class="number">5</span>], <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (f[i])</span><br><span class="line">        f[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    init(fa, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (fa[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;fa[%0d] = %0d&quot;</span>, i, fa[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>也可以将数组包装到一个<a href="../SV%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1">类</a>中，然后返回对象的句柄</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ArrayWrapper;</span><br><span class="line">  <span class="keyword">int</span> data[];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">input</span> <span class="keyword">int</span> size, <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    data = <span class="keyword">new</span>[size];</span><br><span class="line">    <span class="keyword">foreach</span>(data[i]) data[i] = i + start;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> ArrayWrapper create_wrapped_array(<span class="keyword">input</span> <span class="keyword">int</span> size, <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span>(size, start);  <span class="comment">// 返回新对象句柄</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  ArrayWrapper obj;</span><br><span class="line">  obj = create_wrapped_array(<span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 初始化数组 [3,4,5,6,7]</span></span><br><span class="line">  <span class="keyword">foreach</span>(obj<span class="variable">.data</span>[i]) </span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;obj.data[%0d] = %0d&quot;</span>, i, obj<span class="variable">.data</span>[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SV数组队列</title>
      <link href="/SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97/"/>
      <url>/SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<h1 id="定宽数组">定宽数组</h1><ul><li>定宽数组（Fixed-Size Arrays）是SV中用于存储固定数量元素的静态数据结构</li><li>编译时确定大小，运行时不改变容量，在内存中连续存储，支持高效索引访问</li></ul><h2 id="特性与声明">特性与声明</h2><ul><li>基础格式：<code>&lt;数据类型&gt; &lt;数组名&gt;[&lt;维度1&gt;][&lt;维度2&gt;]...;</code><ul><li>紧凑声明：SV允许只声明数组宽带，使用0作为索引下界</li><li>格式化描述符：可使用<code>%p</code>打印数组、结构、类等</li><li>SV仿真器存放数组元素时使用字边界</li></ul></li></ul><p><img src="/images/image-20250715152350189.png" alt="image-20250715152350189"></p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array1[<span class="number">0</span>:<span class="number">7</span>];                <span class="comment">// 1x8，完整声明，索引下界0、上界7</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] arry2[<span class="number">0</span>:<span class="number">3</span>][<span class="number">0</span>:<span class="number">2</span>];   <span class="comment">// 4*3</span></span><br><span class="line"><span class="keyword">int</span> array1[<span class="number">8</span>];                  <span class="comment">// 紧凑声明</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] arry2[<span class="number">4</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li>常量数组初始化<ul><li>使用一个单引号加大括号来初始化数组，为部分或所有元素赋值</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b[<span class="number">4</span>] = &#x27;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">// 显式声明静态变量，并同时赋值</span></span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    a = &#x27;&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;                   <span class="comment">// 为全部元素赋值</span></span><br><span class="line">    a = &#x27;&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;                       <span class="comment">// 为前3个元素赋值</span></span><br><span class="line">    b = &#x27;&#123;<span class="number">4</span>&#123;<span class="number">8</span>&#125;&#125;;                        <span class="comment">// 全赋值8</span></span><br><span class="line">    b = &#x27;&#123;<span class="keyword">default</span>:<span class="number">42</span>&#125;;                  <span class="comment">// 全赋值42</span></span><br><span class="line">    c = &#x27;&#123;&#x27;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#x27;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;           <span class="comment">// 为全部元素赋值</span></span><br><span class="line">    c[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1</span>;                        <span class="comment">// 为最后一个元素赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="foreach循环">foreach循环</h2><ul><li>索引变量自动声明，只在循环内有效</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src[<span class="number">5</span>], dst[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> rev[<span class="number">6</span>:<span class="number">2</span>];                       <span class="comment">// 索引从6开始，递减索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="built_in">$size</span>(src); i++)</span><br><span class="line">        src[i] = i;</span><br><span class="line">    <span class="keyword">foreach</span> (dst[j])                    <span class="comment">// 等同于for(int j=0; j&lt;=4; j++)</span></span><br><span class="line">        dst[j] = src[j] * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (rev[k])                    <span class="comment">// 等同于for(int k=6; j&gt;=2; k--)</span></span><br><span class="line">        rev[k] = k;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>多维数组使用foreach，用逗号将下标隔开后放在同一个方括号中</li><li>若不需要遍历所有维度，可以在方括号中忽略掉它们</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> md[<span class="number">2</span>][<span class="number">3</span>] = &#x27;&#123;&#x27;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#x27;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (md[i,j])                               <span class="comment">// 遍历所有维度，i++(j++)</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;md[%d][%d] = %d&quot;</span>, i, j, md[i][j]);</span><br><span class="line">    <span class="keyword">foreach</span> (md[i]) <span class="keyword">begin</span>                           <span class="comment">// 分维度遍历，与上面等效</span></span><br><span class="line">        <span class="built_in">$write</span>(<span class="string">&quot;%2d:&quot;</span>, i);                          <span class="comment">// $write输出后不换行</span></span><br><span class="line">        <span class="keyword">foreach</span> (md[,j])</span><br><span class="line">            <span class="built_in">$write</span>(<span class="string">&quot;md[%d][%d] = %d&quot;</span>, i, j, md[i][j]);</span><br><span class="line">        <span class="built_in">$display</span>;                                   <span class="comment">// $display输出后换行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="比较和复制">比较和复制</h2><ul><li>可以不使用循环而对数组进行聚合比较和复制，聚合操作适用于整个数组而不是单个元素</li><li>对于数组的加、减法等算术运算不能使用聚合操作，应该使用foreach循环</li><li>对于异或等逻辑运算，应该使用循环或合并数组</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src[<span class="number">5</span>] = &#x27;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, dst[<span class="number">5</span>] = &#x27;&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;src %s dst&quot;</span>, (src == dst) ? <span class="string">&quot;==&quot;</span> : <span class="string">&quot;!=&quot;</span>);         <span class="comment">// 所有元素值是否相等</span></span><br><span class="line">    dst = src                                                   <span class="comment">// 复制src元素到dst</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;src[1:4] %s dst[1:4]&quot;</span>,</span><br><span class="line">             (src[<span class="number">1</span>:<span class="number">4</span>] == dst[<span class="number">1</span>:<span class="number">4</span>]) ? <span class="string">&quot;==&quot;</span> : <span class="string">&quot;!=&quot;</span>);             <span class="comment">// 比较第1~4个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时使用数组下标和位下标打印</span></span><br><span class="line">    <span class="built_in">$displayb</span>(<span class="string">&quot;dst[0][2:1]&quot;</span>);                                   <span class="comment">// &#x27;b10，dst[0]是4</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="合并数组">合并数组</h1><h2 id="特性与声明-v2">特性与声明</h2><ul><li>合并数组是一种特殊的多维数组，其所有维度在内存中连续存储<ul><li>区别于普通向量，合并数组适合处理具有自然分层的结构（如网络包、图像数据）</li><li>区别于普通数组使用字边界的存放方式，使得合并数组支持直接的位级操作（如异或运算）</li></ul></li><li>声明合并数组时，数组大小和合并位宽必须在变量名前指定<ul><li>数组大小格式必须是<code>[msb:lsb]</code>，而不是<code>[size]</code></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] A;       <span class="comment">// 简单的logic变量，存储32bit，访问bit片段需要使用切片</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] B[<span class="number">8</span>];     <span class="comment">// 非合并数组，使用字边界，bit不连续</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] [<span class="number">7</span>:<span class="number">0</span>] C;  <span class="comment">// 4x8合并数组，连续存储，数组大小是4，合并8位</span></span><br><span class="line"><span class="keyword">int</span> [<span class="number">1</span>:<span class="number">0</span>] D;          <span class="comment">// 2x32合并数组，数组大小是2，int合并32位</span></span><br><span class="line"><span class="comment">// 合并数组C的内存布局与向量A相同，但索引方式不同，下图为内存布局图示</span></span><br><span class="line"><span class="comment">//         合并数组 C[3:0][7:0]               普通向量 A[31:0]</span></span><br><span class="line"><span class="comment">//       ┌───────────────────────┐          ┌───────────────────────┐</span></span><br><span class="line"><span class="comment">//字节3   │       C[3][7:0]       │ 31-24    │ A[31:24]              │</span></span><br><span class="line"><span class="comment">//       ├───────────────────────┤          ├───────────────────────┤</span></span><br><span class="line"><span class="comment">//字节2   │       C[2][7:0]       │ 23-16    │ A[23:16]              │</span></span><br><span class="line"><span class="comment">//       ├───────────────────────┤          ├───────────────────────┤</span></span><br><span class="line"><span class="comment">//字节1   │       C[1][7:0]       │ 15-8     │ A[15:8]               │</span></span><br><span class="line"><span class="comment">//       ├───────────────────────┤          ├───────────────────────┤</span></span><br><span class="line"><span class="comment">//字节0   │       C[0][7:0]       │ 7-0      │ A[7:0]                │</span></span><br><span class="line"><span class="comment">//       └───────────────────────┘          └───────────────────────┘</span></span><br></pre></td></tr></table></figure><h2 id="混合使用">混合使用</h2><ul><li>合并数组（Packed Array）和非合并数组（Unpacked Array）可以混合使用<ul><li>合并数组作为非合并数组的元素类型</li><li>支持更复杂的硬件建模需求，如数据包、寄存器组</li><li>优化内存布局：合并部分连续、非合并灵活分散</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// barray是一个有5个合并数据作为元素的非合并数组</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] [<span class="number">7</span>:<span class="number">0</span>] barray [<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] oneword = <span class="number">32&#x27;h012345678</span>;</span><br><span class="line">barray[<span class="number">0</span>] = oneword;</span><br><span class="line"><span class="comment">// barray[0][3] = 8&#x27;h01;</span></span><br><span class="line"><span class="comment">// barray[0][1][6] = 1&#x27;b1;</span></span><br></pre></td></tr></table></figure><img src="/images/image-20250718164324555.png" alt="image-20250718164324555" style="zoom: 33%;" /><h1 id="动态数组">动态数组</h1><h2 id="特性与声明-v3">特性与声明</h2><ul><li>动态数组在声明时使用空的下标<code>[]</code>，表示数组尺寸在编译时未指定</li><li>仿真运行时通过<code>new[]</code>操作符显式地预分配内存大小</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> dyn[],d2[];                  <span class="comment">// 声明动态数组</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">5</span>];                <span class="comment">// 分配5个元素空间</span></span><br><span class="line">    <span class="keyword">foreach</span> (dyn[j]) dyn[j] = j; <span class="comment">// 初始化元素（例如：dyn[0]=0, dyn[1]=1...）</span></span><br><span class="line">    d2 = dyn;                    <span class="comment">// 复制一个动态数组</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">20</span>](dyn);          <span class="comment">// 重新分配20个整数并进行复制</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">100</span>];              <span class="comment">// 重新分配100个整数，舍弃旧值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><ul><li>基本数据类型（如<code>int</code>）相同，定宽数组和动态数据之间可以相互赋值<ul><li>当把一个定宽数组复制给一个动态数组时，会自动分配空间</li><li>适用于想声明一个常数数组但又不想统计元素的个数</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] mask[] = `&#123;<span class="number">2&#x27;b00</span>, <span class="number">2&#x27;b01</span>, <span class="number">2&#x27;b10</span>, <span class="number">2&#x27;b11</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>声明多维动态数组时，需按照从左到右的维度构造</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[][];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    d = <span class="keyword">new</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (d[i]) d[i] = <span class="keyword">new</span>[i+<span class="number">123</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (d[i,j]) d[i][j] = i + j;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="常用内建方法">常用内建方法</h2><ul><li>长度操作：<code>array.size()</code>获取数组当前元素个数，等同于<code>$size(array)</code></li><li>删除内存：<code>array.delete()</code>释放数组内存</li><li>插入元素：<code>array.insert(index, value)</code>在指定索引位置插入元素，数组大小自动增加</li><li>删除元素：<code>array.delete(index)</code>删除指定索引处的元素，数组大小减1</li></ul><blockquote><p>动态数据使用上述内建函数消耗性能，更多内建方法见最后一章</p></blockquote><h1 id="队列">队列</h1><h2 id="特性与声明-v4">特性与声明</h2><ul><li>队列 (queues) 特性<ul><li>动态：队列长度在仿真期间自动伸缩，无需预分配大小</li><li>同质：队列中所有元素的类型必须相同</li><li>有序：队列中的元素是有序的，能够通过索引访问</li><li>高效操作：SV提供内置的方法高效地在队列的任意位置删减元素</li></ul></li><li>队列声明<ul><li>声明队列的语法与数组类似，但需使用<code>$</code></li><li>队列的常量初始化不再需要使用<code>'</code></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> my_int_q[$];              <span class="comment">// 声明一个整数队列</span></span><br><span class="line">my_class_type my_object_q[$]; <span class="comment">// 声明一个自定义类对象句柄队列</span></span><br><span class="line">my_int_q[$] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure><ul><li>打包与解包</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] pk_addr, pk_csm, pk_data[<span class="number">8</span>];     <span class="comment">// pack</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] upk_addr, upk_csm, upk_data[<span class="number">8</span>];  <span class="comment">// unpack</span></span><br><span class="line"><span class="keyword">byte</span> bytes[$];</span><br><span class="line">bytes = &#123; &gt;&gt; &#123;pk_addr, pk_csm, pk_data&#125;&#125;;</span><br><span class="line">&#123; &gt;&gt; &#123;upk_addr, upk_csm, upk_data&#125;&#125; = bytes;</span><br></pre></td></tr></table></figure><h2 id="常用内建方法-v2">常用内建方法</h2><ul><li>长度操作：<code>q.size()</code>返回队列中元素的当前数量，等同于<code>$size(q)</code></li><li>删除内存：<code>array.delete()</code>释放数组内存</li><li>删除元素：<code>q.delete(index)</code>删除指定索引处的元素</li><li>插入元素：<code>q.insert(index, item)</code>在指定索引处插入一个元素</li><li>头部插入：<code>q.push_front(item)</code>在队列的头部插入一个元素</li><li>尾部插入：<code>q.push_back(item)</code>在队列的尾部插入一个元素</li><li>头部发送：<code>q.pop_front()</code>移除并返回队列头部的元素</li><li>尾部发送：<code>q.pop_back()</code>移除并返回队列尾部的元素</li><li>移除重复：<code>q.unique()</code>移除队列中的重复元素</li></ul><h1 id="关联数组">关联数组</h1><h2 id="特性与声明-v5">特性与声明</h2><ul><li>关联数组（Associative Arrays）允许使用任意类型（如整型、字符串等）作为索引（键Key），快速存取对应的值，原理示例<code>Key: “apple” -&gt; 哈希表 -&gt; 索引值 -&gt; 定位存储位置（通）-&gt; 返回值</code><ul><li>动态：内存仅在写入元素时分配，无需预分配</li><li>无序：存储非连续索引的数据（如大范围地址的稀疏数据），避免内存浪费</li><li>灵活：索引可以为任意类型</li></ul></li></ul><img src="/images/image-20250721163601864.png" alt="image-20250721163601864" style="zoom:50%;" /><ul><li>声明格式：<code>data_type array_name [index_type];</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//声明及初始化</span></span><br><span class="line"><span class="keyword">int</span> fruit_prices[<span class="keyword">string</span>] = &#x27;&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;orange&quot;</span>: <span class="number">4</span>&#125;;</span><br><span class="line">fruit_prices[<span class="string">&quot;grape&quot;</span>] = <span class="number">6</span>; <span class="comment">// 动态赋值</span></span><br><span class="line"><span class="comment">// foreach循环遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (fruit_prices[i]) <span class="keyword">begin</span>  </span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;fruit_prices[%s] = %0d&quot;</span>, i, fruit_prices[i]);  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// first/next循环遍历</span></span><br><span class="line"><span class="keyword">string</span> key;</span><br><span class="line"><span class="keyword">if</span> (my_array<span class="variable">.first</span>(key)) <span class="keyword">begin</span>  <span class="comment">// 获取第一个键存入字符串变量key</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;my_array[%s] = %0d&quot;</span>, key, my_array[key]); <span class="comment">// 打印键值</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span> (my_array<span class="variable">.next</span>(key));  <span class="comment">// 获取下一个键，直到返回0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="常用内建方法-v3">常用内建方法</h2><ul><li>删除内存：<code>array.delete()</code></li><li>删除键值对：<code>array.delete(key)</code></li><li>检查键存在：<code>array.exitsts(key)</code>检查指定键是否存在，若存在返回布尔值1</li><li>数量查询：<code>array.nun()</code>查询数组中键值对的总数量</li><li>获取首键：<code>array.first(ref)</code>获取第一个键赋值给参数ref</li><li>获取未键：<code>array.last(ref)</code>获取最后一个键赋值给参数ref</li><li>获取下一键：<code>array.next(ref)</code>获取下一个键赋值给参数ref</li><li>获取上一键：<code>array.prev(ref)</code>获取上一个键赋值给参数ref</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> memory_model;  </span><br><span class="line">  <span class="comment">// 假设这是一个简单的内存模型，用于存储和检索数据  </span></span><br><span class="line">  <span class="keyword">byte</span> memory[<span class="keyword">int</span>];  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> write(<span class="keyword">int</span> addr, <span class="keyword">byte</span> data);  </span><br><span class="line">    memory[addr] = data;  </span><br><span class="line">  <span class="keyword">endfunction</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">byte</span> read(<span class="keyword">int</span> addr);  </span><br><span class="line">    <span class="keyword">if</span> (memory<span class="variable">.exists</span>(addr)) <span class="keyword">return</span> memory[addr];  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 假设如果地址不存在，则返回0  </span></span><br><span class="line">  <span class="keyword">endfunction</span>  </span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure><h1 id="数组的方法">数组的方法</h1><ul><li>数组内建方法汇总，使用于任何非合并的数组类型，包括定宽数组、动态数组、队列和关联数组</li></ul><h2 id="缩减">缩减</h2><ul><li>数组的缩减方法是指将数组缩减成一个值，结果和元素的位宽一致</li><li>缩减方法可以用来计算数组中所有元素的和、积或逻辑运算<ul><li>和积：<code>array.sum()</code>、<code>array.product()</code></li><li>与或：<code>array.and()</code>、<code>array.or()</code></li><li>异或：<code>array.xor()</code></li></ul></li><li>SV并没有内建从数组中随机选取一个元素的方法，但可以生成一个随机索引</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">4</span>] = &#x27;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> random_index, selected_element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机索引（0 到 3）</span></span><br><span class="line">random_index = $urandom_range(my_array<span class="variable">.size</span>() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选取元素</span></span><br><span class="line">selected_element = my_array[random_index];</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;随机选取的元素: %d&quot;</span>, selected_element);</span><br></pre></td></tr></table></figure><h2 id="定位-条件">定位/条件</h2><ul><li>用于查找数组中所有满足指定条件的元素，并将结果以队列形式（无<code>'</code>）返回</li><li>数组定位方法：min、max、unique<ul><li><code>array.min()</code>和<code>array.max()</code>返回数组的最值队列</li><li><code>array.unique()</code>返回数组中唯一值的队列</li></ul></li><li>数组定位方法：find<ul><li><code>array.find() with (condition)</code>强制使用<code>with</code>语句查找指定条件，并以队列形式返回<ul><li>无匹配时返回空队列<code>&#123;&#125;</code>，需在代码中检查结果中是否有效</li><li><code>with</code>支持复杂逻辑，如<code>item &gt; 2 &amp;&amp; intem &lt; 8</code></li></ul></li><li><code>array.find_first() with (conditon)</code>以队列形式返回首个满足条件的元素</li><li><code>array.find_last() with (conditon)</code>以队列形式返回最后一个满足条件的元素</li><li><code>array.find_index() with (conditon)</code>以队列形式返回首个满足条件的元素的索引<ul><li>对于<code>find_index</code>方法，返回的队列类型是双状态<code>int</code>而不是四状态<code>integer</code></li></ul></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#x27;&#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> found_queue[$] = arr<span class="variable">.find</span>() <span class="keyword">with</span> (item &gt; <span class="number">5</span>);   <span class="comment">// found_queue = &#123;7, 9&#125;</span></span><br><span class="line"><span class="comment">// found_queue.delete();</span></span><br><span class="line">found_queue = arr<span class="variable">.find_first</span>() <span class="keyword">with</span> (item % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 首个偶数：&#123;2&#125;</span></span><br><span class="line">found_queue = arr<span class="variable">.find_last</span>() <span class="keyword">with</span> (item &lt; <span class="number">6</span>); <span class="comment">// 最后一个小于6的数：&#123;5&#125;</span></span><br><span class="line"><span class="keyword">int</span> index_queue[$] = arr<span class="variable">.find_index</span>() <span class="keyword">with</span> (item == <span class="number">9</span>); <span class="comment">// 索引：&#123;3&#125;</span></span><br></pre></td></tr></table></figure><ul><li>在条件语句<code>with</code>中，<code>item</code>被称为重复参数，是一个缺省的名字，也可以指定其他名字，以下四个语句是等同的</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">found_queue = arr<span class="variable">.find</span>() <span class="keyword">with</span> (item == <span class="number">3</span>);</span><br><span class="line">found_queue = arr<span class="variable">.find</span> <span class="keyword">with</span> (item == <span class="number">3</span>);</span><br><span class="line">found_queue = arr<span class="variable">.find</span>(item) <span class="keyword">with</span> (item == <span class="number">3</span>);</span><br><span class="line">found_queue = arr<span class="variable">.find</span>(x) <span class="keyword">with</span> (x == <span class="number">3</span>);</span><br></pre></td></tr></table></figure><ul><li>当把数组缩减方法<code>sum()</code>与条件语句<code>with</code>结合使用时，可以检测表达式为真的次数</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> count, total, d[] = `&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">count = d<span class="variable">.sum</span>(x) <span class="keyword">with</span> (x &gt; <span class="number">7</span>);        <span class="comment">// 2 = sum&#123;1,0,1,0,0,0&#125;</span></span><br><span class="line">total = d<span class="variable">.sum</span>(x) <span class="keyword">with</span> ((x &gt; <span class="number">7</span>) * x)   <span class="comment">// 17 = sum&#123;9,0,8,0,0,0&#125;</span></span><br><span class="line">total = d<span class="variable">.sum</span>(x) <span class="keyword">with</span> (x &lt; <span class="number">8</span> ? x : <span class="number">0</span>) <span class="comment">// 12 = sum&#123;0,1,0,3,4,4&#125;</span></span><br></pre></td></tr></table></figure><ul><li>下面介绍了一种使用数组定位方法建立记分板的方法，使用<code>typedef</code>创建包结构（对于包信息的存储，更好的方法是使用类）<ul><li>例子中<code>check_addr()</code>函数在计分板中寻找和参数匹配的地址</li><li><code>find_index()</code>方法返回一个<code>int</code>队列</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] pr;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; Packet;</span><br><span class="line"></span><br><span class="line">Packet scb[$];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> check_addr(<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr);</span><br><span class="line">    <span class="keyword">int</span> intq[$];</span><br><span class="line">    </span><br><span class="line">    intq = scb<span class="variable">.find_index</span>() <span class="keyword">with</span> (item<span class="variable">.addr</span> == addr);</span><br><span class="line">    <span class="keyword">case</span>(intq<span class="variable">.size</span>())</span><br><span class="line">        <span class="number">0</span>: <span class="built_in">$display</span>(<span class="string">&quot;Addr %h not found in scoreboard&quot;</span>, addr);</span><br><span class="line">        <span class="number">1</span>: scb<span class="variable">.delete</span>(intq[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">$display</span>(<span class="string">&quot;ERROR: Multiple hits for addr %h&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endfunction</span> : check_addr</span><br></pre></td></tr></table></figure><h2 id="排序">排序</h2><ul><li>只有定宽数组、动态数组、队列可以排序、反转、打乱次序，关联数组不能重新排序</li><li>排序方法改变了原始数组，而定位方法是新建一个队列来保存结果<ul><li><code>array.sort()</code>按照元素大小进行升序排序</li><li><code>array.rsort()</code>按照元素大小进行降序排序</li><li><code>array.reverse()</code>反转数组中元素的顺序</li><li><code>array.shuffle()</code>打乱数组中元素的顺序</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> d[] = &#x27;&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">d<span class="variable">.sort</span>();    <span class="comment">//&#x27;&#123;1,3,4,4,8,9&#125;</span></span><br><span class="line">d<span class="variable">.rsort</span>();   <span class="comment">//&#x27;&#123;9,8,4,4,3,1&#125;</span></span><br><span class="line">d<span class="variable">.reverse</span>(); <span class="comment">//&#x27;&#123;4,4,3,8,1,9&#125;</span></span><br><span class="line">d<span class="variable">.shuffle</span>(); <span class="comment">//&#x27;&#123;9,4,3,8,1,4&#125;</span></span><br></pre></td></tr></table></figure><ul><li>使用子域对一个结构数组进行排序时，<code>reverse</code>和<code>shuffle</code>方法不能带<code>with</code>语句</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> &#123; <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] red, green, blue&#125; color[];</span><br><span class="line">color = &#x27;&#123;&#x27;&#123;red:<span class="number">7</span>, grean:<span class="number">4</span>, blue:<span class="number">9</span>&#125;, &#x27;&#123;red:<span class="number">3</span>, grean:<span class="number">2</span>, blue:<span class="number">9</span>&#125;, &#x27;&#123;red:<span class="number">5</span>, grean:<span class="number">2</span>, blue:<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">color<span class="variable">.sort</span> <span class="keyword">with</span> (item<span class="variable">.red</span>);           <span class="comment">//只对红色像素进行重新排序</span></span><br><span class="line"><span class="comment">//&#x27;&#123;&#x27;&#123;red:3, grean:2, blue:9&#125;, &#x27;&#123;red:5, grean:2, blue:1&#125;, &#x27;&#123;red:7, grean:4, blue:9&#125;&#125;</span></span><br><span class="line">color<span class="variable">.sort</span>(x) <span class="keyword">with</span> (x<span class="variable">.green</span>, x<span class="variable">.blue</span>)  <span class="comment">//先对绿色再对蓝色进行重新排序</span></span><br></pre></td></tr></table></figure><h1 id="选择数据结构">选择数据结构</h1><blockquote><p>本章介绍一些如何正确选择存储类型（数据结构）的经验法则</p></blockquote><ul><li>网络数据包建模<ul><li>特点：长度固定、顺序读取</li><li>针对长度固定或可变的数据可分别采用定宽数组或动态数组</li></ul></li><li>保存期望值的记分板<ul><li>特点：仿真前长度位置，按值存取，长度经常变化</li><li>一般情况下可使用队列，方便在仿真期间连续增加和删除元素</li><li>如果记分板由数百个元素，而且需要经常对元素进行增删操作，则使用关联数组在速度上可能更快</li><li>如果将事务建模成对象，那么记分板可以是句柄的队列</li><li>如果不用记分板进行搜索，那么只需要把预期的数值存入信箱（mailbox）</li></ul></li><li>有序结构<ul><li>如果数据按照可预见的顺序输出，可以使用队列</li><li>如果输出顺序不确定，则使用关联数组</li></ul></li><li>对特大容量存储器建模<ul><li>如果不需要用到所有存储空间，可以使用关联数组实现稀疏存储</li><li>确保使用的是双状态类型的32比特合并数据，以节约仿真器使用的内存</li></ul></li><li>文件中的命令名或操作码<ul><li>特点：把字符串转换成固定值</li><li>从文件中读出字符串，然后使用命令作为字符串索引在关联数组中查找命令名或操作码</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SV数据类型</title>
      <link href="/SV%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/SV%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="四状态类型">四状态类型</h1><h2 id="逻辑类型">逻辑类型</h2><ul><li><p><code>logic</code>：推荐替代<code>wire</code>和<code>reg</code>的类型</p><ul><li><code>reg</code>：Verilog遗留类型，过程赋值中存储值</li><li><code>wire</code>：Verilog遗留类型，连续赋值或端口连接</li></ul></li><li><p>可表示四种状态：0、1、X（未知）、Z（高阻）</p></li><li><p>可用于线网连接，也可用于过程赋值，编译器根据上下文自行判断</p></li><li><p>只能有一个驱动，否则编译报错</p><ul><li>如双向总线<code>inout</code>应该使用线网类型<code>wire</code>或<code>tri</code></li></ul></li></ul><h2 id="整数类型">整数类型</h2><ul><li><code>integer</code>：带符号的四值整数，不指定明确位宽<ul><li>位宽由实现定义，通常是32位</li><li>主要用于循环控制、通用计算，不用于硬件建模</li></ul></li><li><code>time t</code>：存储仿真时间值的无符号四值整数，不指定明确位宽<ul><li><code>timeunit 1ns;</code>用于指定仿真中<code>#</code>延迟</li><li><code>timeprecision 1ps;</code> 用于指定<code>$time</code>单位</li></ul></li></ul><h1 id="双状态类型">双状态类型</h1><blockquote><p>相比于四值类型，引入双值类型有利于提高仿真器性能并减少内存的使用量</p></blockquote><h2 id="整数类型-v2">整数类型</h2><ul><li><code>bit</code>：最常用的二值类型，无符号整数</li><li><code>bit [31:0]</code>：32比特无符号整数</li><li><code>unsigned int</code>：32比特无符号整数</li><li><code>int</code>：32比特有符号整数，范围是 (-128, 127)</li><li><code>byte</code> ：8比特有符号整数</li><li><code>shortint</code>：16比特有符号整数</li><li><code>longint</code>：64比特有符号整数</li></ul><blockquote><p>注意：当把双状态变量连接到被测设计输出时，若输出X或Z态会被转换成双状态值而测试代码无法察觉。使用<code>$isunknown</code>操作符，在表达式任意位出现X或Z态时返回1</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">$isunknown</span>(iport) == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;@%t: 4-state value detected on iport %b&quot;</span>, <span class="built_in">$time</span>, iport);</span><br></pre></td></tr></table></figure><h1 id="类型转换">类型转换</h1><h2 id="静态转换">静态转换</h2><ul><li>语法：<code>目标类型'(表达式)</code></li><li>强制改变表达式类型，不进行越界检查</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">int</span>&#x27;(<span class="number">10</span><span class="variable">.0</span> - <span class="number">0</span><span class="variable">.1</span>);           <span class="comment">// 浮点转整型（截断小数）</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] byte_val = <span class="keyword">unsigned</span>&#x27;(-<span class="number">1</span>); <span class="comment">// 有符号转无符号（结果为255）</span></span><br><span class="line"><span class="keyword">void</span>&#x27;(function_call());             <span class="comment">// 忽略函数返回值  </span></span><br></pre></td></tr></table></figure><h2 id="动态转换">动态转换</h2><ul><li>语法：<code>$cast(目标变量, 源表达式)</code></li><li>返回值：1表示转换成功，0表示转换失败</li><li>应用场景<ul><li>非枚举值赋给枚举变量时需显式检查，避免引入非法值</li><li>当父类句柄指向子类对象时，将父类句柄转换为子类句柄</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 枚举转换</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, BLUE&#125; color_e;    <span class="comment">// RED=0, BLUE=1</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">color_e color;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">$cast</span>(color, c)) <span class="built_in">$error</span>(<span class="string">&quot;越界&quot;</span>); <span class="comment">// c=2超出枚举范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类向下转型</span></span><br><span class="line"><span class="keyword">class</span> Parent; <span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent; <span class="keyword">endclass</span></span><br><span class="line">Parent p = <span class="keyword">new</span> Child();</span><br><span class="line">Child c;</span><br><span class="line"><span class="built_in">$cast</span>(c, p);  <span class="comment">// 合法向下转型</span></span><br></pre></td></tr></table></figure><h2 id="隐式转换">隐式转换</h2><ul><li>由编译器自动完成，无需额外语法<ul><li>不同位宽/符号类型：自动扩展/截断、补零或符号扩展</li><li>可能引入风险</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] x_vec = <span class="number">&#x27;b11x0</span>; </span><br><span class="line"><span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] b_vec = x_vec; <span class="comment">// 风险：b_vec=&#x27;b010（x被转为0），四值-&gt;二值，可能隐蔽错误</span></span><br></pre></td></tr></table></figure><h1 id="特殊类型">特殊类型</h1><ul><li>浮点数类型<ul><li><code>real</code>：双精度浮点数，等效于IEEE 754标准的64位浮点</li><li><code>shortreal</code>：单精度浮点数，32位</li></ul></li><li>空类型<ul><li><code>void</code>声明无返回值的函数或任务</li></ul></li><li>句柄类型<ul><li><code>chandle</code>存储由C/C++通过DPI传递的指针</li></ul></li><li>事件类型<ul><li><code>event</code>用于声明同步时间，无数据，仅作为同步信号标识</li><li>通过操作符<code>-&gt;</code>触发事件，<code>@</code>或<code>wait()</code>等待事件</li></ul></li><li>字符串<ul><li>用于存储动态文本字符串，本质是字符队列</li></ul></li></ul><h1 id="字符串">字符串</h1><h2 id="特性">特性</h2><ul><li>动态长度：运行时自动调整长度，无需预定义大小</li><li>ASCII存储：每个字符以字节形式存储 (ASCII 编码)</li><li>空终止符：自动维护结尾的<code>\0</code>字符，与C语言兼容</li><li>索引访问：支持<code>str[i]</code>访问字符</li><li>支持转移序列：<code>\n</code> <code>\t</code> <code>\\</code> <code>\&quot;</code> <code>\0</code> <code>\xHH</code> (十六进制)</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> msg = <span class="string">&quot;Hello SV!&quot;</span>;         <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">string</span> empty_str;                 <span class="comment">// 默认值 &quot;&quot; </span></span><br><span class="line"><span class="keyword">string</span> path = <span class="string">&quot;dir/file.txt&quot;</span>;     <span class="comment">// 路径字符串</span></span><br><span class="line"><span class="keyword">string</span> hex_str = <span class="string">&quot;A\x42C&quot;</span>;        <span class="comment">// 包含十六进制字符 (ABC)</span></span><br></pre></td></tr></table></figure><h2 id="内建方法">内建方法</h2><h3 id="长度操作">长度操作</h3><ul><li><code>len()</code>或<code>length()</code>：返回字符串长度</li><li><code>putc(int i, byte c)</code>：替换位置<code>i</code>的的字符为<code>c</code>，索引从0开始</li><li><code>getc(int i)</code>：获取位置<code>i</code>的字符</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> word = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> length = word<span class="variable">.len</span>();       <span class="comment">// length = 4</span></span><br><span class="line">word<span class="variable">.putc</span>(length-<span class="number">1</span>, &#x27;!&#x27;);      <span class="comment">// 修改为 &quot;tes!&quot;</span></span><br><span class="line"><span class="keyword">byte</span> last_char = word<span class="variable">.getc</span>(<span class="number">3</span>); <span class="comment">// 返回 &#x27;!&#x27; (ASCII 33)</span></span><br></pre></td></tr></table></figure><h3 id="大小写转换">大小写转换</h3><ul><li><code>toupper()</code>：转为全大写</li><li><code>tolower()</code>：转为全小写</li></ul><blockquote><p>大写：Uppercase Letter；小写：Lowercase Letter</p></blockquote><h3 id="子串操作">子串操作</h3><ul><li><code>substr(int s, int e)</code>：提取子串<code>[s,e]</code></li><li><code>delete(int s, int e)</code>：删除子串</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> full = <span class="string">&quot;SystemVerilog&quot;</span>;</span><br><span class="line"><span class="keyword">string</span> sub = full<span class="variable">.substr</span>(<span class="number">6</span>, <span class="number">8</span>);  <span class="comment">// &quot;Ver&quot;</span></span><br></pre></td></tr></table></figure><h3 id="比较与搜索">比较与搜索</h3><ul><li><code>compare(string s)</code>：区分大小写比较，相等时返回0，大于时返回1，小于时返回-1</li><li><code>icompare(string s)</code>：不区分大小写比较</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> a = <span class="string">&quot;apple&quot;</span>, b = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> cmp1 = a<span class="variable">.compare</span>(b);     <span class="comment">// 非零值 (区分大小写)</span></span><br><span class="line"><span class="keyword">int</span> cmp2 = a<span class="variable">.icompare</span>(b);    <span class="comment">// 0 (不区分大小写)</span></span><br></pre></td></tr></table></figure><ul><li><code>find(string substr)</code>：正向（从左往右）查找字符串位置<ul><li>大小写敏感</li><li>返回子串第一次出现的起始索引或-1</li><li>用于提取前缀、解析命令</li></ul></li><li><code>rfind(string substr)</code>：反向（从右往左）查找子串位置<ul><li>大小写敏感</li><li>返回子串最后一次出现的起始索引或-1</li><li>用于提取后缀、处理文件扩展名或路径</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">string</span> s = <span class="string">&quot;apple,orange,apple&quot;</span>;</span><br><span class="line"><span class="keyword">string</span> file_path = <span class="string">&quot;/home/user/report_2023.pdf&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> pos1 = s<span class="variable">.find</span>(<span class="string">&quot;apple&quot;</span>);    <span class="comment">// 返回 0 (第一个&quot;apple&quot;)</span></span><br><span class="line"><span class="keyword">int</span> pos2 = s<span class="variable">.rfind</span>(<span class="string">&quot;apple&quot;</span>);   <span class="comment">// 返回 13 (最后一个&quot;apple&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dot_pos = file_path<span class="variable">.rfind</span>(<span class="string">&quot;.&quot;</span>);      <span class="comment">// 查找最后一个点号的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dot_pos != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">string</span> extension = file_path<span class="variable">.substr</span>(dot_pos, file_path<span class="variable">.len</span>()-<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Extension: %s&quot;</span>, extension); <span class="comment">// 输出 &quot;.pdf&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="类型转换-v2">类型转换</h3><ul><li><code>atoi()</code>：字符串-&gt;十进制整数</li><li><code>atohex()</code>：字符串-&gt;十六进制整数</li><li><code>atobin()</code>：字符串-&gt;二进制整数</li><li><code>atoreal()</code>：字符串-&gt;实数</li><li><code>hextoa(int i)</code>：十六进制整数-&gt;字符串<ul><li>SV不直接提供<code>itoa()</code>，需先使用<code>$sformatf</code></li></ul></li><li><code>bintoa(int i)</code>：二进制整数-&gt;字符串<ul><li>需先使用<code>$sformatf</code></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="string">&quot;7F&quot;</span><span class="variable">.atohex</span>();  <span class="comment">// 十六进制转整数 → 127</span></span><br><span class="line"><span class="keyword">real</span> pi = <span class="string">&quot;3.1416&quot;</span><span class="variable">.atoreal</span>(); <span class="comment">// 字符串转实数</span></span><br></pre></td></tr></table></figure><h3 id="格式化">格式化</h3><ul><li><code>$sformatf</code>：格式化字符串生成器<ul><li>优先使用此函数代替拼接</li><li>SV不直接提供<code>itoa()</code>，需使用<code>$sformatf</code></li><li>尽管大多数仿真支持<code>$psprintf</code>函数，功能也和<code>$sformatf</code>相同，但并不是SV的原生函数</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">string</span> hex_str = <span class="built_in">$sformatf</span>(<span class="string">&quot;%h&quot;</span>, data);     <span class="comment">// 默认格式 → &quot;ff&quot;</span></span><br><span class="line"><span class="keyword">string</span> hex_fmt = <span class="built_in">$sformatf</span>(<span class="string">&quot;0x%h&quot;</span>, data);    <span class="comment">// 带前缀 → &quot;0xff&quot;</span></span><br><span class="line"><span class="keyword">string</span> hex_auto = <span class="built_in">$sformatf</span>(<span class="string">&quot;%0h&quot;</span>, data);    <span class="comment">// &quot;ff&quot; (推荐)</span></span><br><span class="line"><span class="keyword">string</span> hex_4bit = <span class="built_in">$sformatf</span>(<span class="string">&quot;%4h&quot;</span>, value);   <span class="comment">// &quot;  ff&quot; (空格填充)</span></span><br><span class="line"><span class="keyword">string</span> hex_04bit = <span class="built_in">$sformatf</span>(<span class="string">&quot;%04h&quot;</span>, value); <span class="comment">// &quot;00ff&quot; (零填充)</span></span><br></pre></td></tr></table></figure><h1 id="结构体">结构体</h1><h2 id="类型重命名">类型重命名</h2><ul><li><code>typedef</code>语句为现有的数据类型创建新名称（别名）<ul><li>提高代码的可读性、复用性和可维护性</li><li>约定俗成：一般所有用户自定义类型都带后缀<code>_t</code></li><li><code>typedef</code>定义的类型与原始类型完全等效</li></ul></li><li>定义数组类型的语法：<code>typedef &lt;元素类型&gt; &lt;新类型&gt; [&lt;维度&gt;];</code></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Verilog风格</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> OPSIZE 8</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> OPREG reg [`OPSIZE-1:0]</span></span><br><span class="line">`OPREG op_a, op_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SystemVerilog风格</span></span><br><span class="line"><span class="keyword">parameter</span> OPSIZE = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">reg</span> [OPSIZE-<span class="number">1</span>:<span class="number">0</span>] opreg_t;</span><br><span class="line">opreg_t op_a op_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数组类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] byte_array [<span class="number">64</span>];</span><br><span class="line">byte_array buffer;</span><br></pre></td></tr></table></figure><h2 id="包">包</h2><ul><li>可以把<code>parameter</code>和<code>typedef</code>语句放到一个程序包（package）里，使之能被整个设计和测试平台使用<ul><li>包允许在模块、包、程序和接口间共享声明</li></ul></li><li>使用<code>import</code>语句从包里导入符号<ul><li>引用的模块优先使用自己索引路径中的符号，若没有才去包里寻找</li><li>使用范围操作符<code>::</code>导入指定的符号</li></ul></li><li>包是完全独立的，可以被放到任何需要的地方<ul><li>包只能看到包内部定义的符号，或者包自己导入的包</li><li>不能层次化引用来自包外部的符号</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ABC总线的包</span></span><br><span class="line"><span class="keyword">package</span> ABC;</span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">int</span> abc_data_width = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">logic</span> [abc_data_width-<span class="number">1</span>:<span class="number">0</span>] abc_data_t;</span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">time</span> timeout = <span class="number">100</span>ns;</span><br><span class="line">    <span class="keyword">string</span> message = <span class="string">&quot;ABC done&quot;</span>;</span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">    <span class="keyword">import</span> ABC::*;                        <span class="comment">// 导入包中所有符号</span></span><br><span class="line">    </span><br><span class="line">    abc_data_t data;                    <span class="comment">// 来自包ABC的符号</span></span><br><span class="line">    <span class="keyword">string</span> message = <span class="string">&quot;Test timed out&quot;</span>;  <span class="comment">// 本地的message隐藏了包里的message符号</span></span><br><span class="line">    <span class="comment">//若确实需要使用ABC中的messge，则使用ABC::message指定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="variable">#(timeout)</span>;                     <span class="comment">// 来自包ABC的符号</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Timeout - %s&quot;</span>, message);</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="创建结构体">创建结构体</h2><ul><li><code>struct</code>语句把若干变量组合到一个结构中<ul><li>封装数据，便于模块间传递（可综合）</li><li>约定俗成：一般用户自定义类型带后缀<code>_s</code></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;          <span class="comment">// 8位红、绿、蓝通道</span></span><br><span class="line">&#125; pixel_s;                      <span class="comment">// 定义结构体类型 pixel_s</span></span><br><span class="line"></span><br><span class="line">pixel_s my_pixel;               <span class="comment">// 声明变量</span></span><br><span class="line">my_pixel = &#x27;&#123;<span class="number">&#x27;h10</span>, <span class="number">&#x27;h20</span>, <span class="number">&#x27;h30</span>&#125;; <span class="comment">// 结构体赋值</span></span><br></pre></td></tr></table></figure><ul><li><code>packed</code>关键字将结构体中的数据合并到尽可能小的空间中<ul><li>若需经常对整个结构体进行复制，使用合并结构效率更高</li><li>若需经常对结构内的个体进行操作，使用非合并结构效率更高</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上例中的pixel_s占用了三个长字的存储空间，即使实际只需三个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;         <span class="comment">// 使用packed进行压缩</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;          <span class="comment">// 8位红、绿、蓝通道</span></span><br><span class="line">&#125; pixel_s_p;</span><br></pre></td></tr></table></figure><h2 id="流操作符">流操作符</h2><ul><li>流操作符用于数据打包和解包，简化数据的序列化操作<ul><li><code>&gt;&gt;</code>（从左至右打包或解包）：将数据打包成比特流，或从比特流中解包提取数据</li><li><code>&lt;&lt;</code>（从右至左打包或解包）：反序打包数据，或反序解包比特流</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打包（Pack）：将多个变量组合成比特流，如总线数据传输</span></span><br><span class="line">type_packed = &#123; &gt;&gt; &#123;var1, var2, ...&#125; &#125;;  <span class="comment">// 从左至右打包</span></span><br><span class="line">type_packed = &#123; &lt;&lt; &#123;var1, var2, ...&#125; &#125;;  <span class="comment">// 从右至左打包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解包（Unpack）：从比特流中提取数据，如DUT输出数据的解析</span></span><br><span class="line">&#123; &gt;&gt; &#123;var1, var2, ...&#125; &#125; = type_packed;  <span class="comment">// 从左至右解包</span></span><br><span class="line">&#123; &lt;&lt; &#123;var1, var2, ...&#125; &#125; = type_packed;  <span class="comment">// 从右至左解包</span></span><br></pre></td></tr></table></figure><ul><li>支持数据结构，使用与结构体、数组等复杂类型</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; packet_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包：将结构体打包成比特流</span></span><br><span class="line">packet_t tx_packet;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">39</span>:<span class="number">0</span>] packed_stream; <span class="comment">// 总宽度：8-bit + 32-bit = 40-bit</span></span><br><span class="line">tx_packet<span class="variable">.addr</span> = <span class="number">8&#x27;hA5</span>;</span><br><span class="line">tx_packet<span class="variable">.data</span> = <span class="number">32&#x27;h1234_5678</span>;</span><br><span class="line">packed_stream = &#123; &gt;&gt; &#123;tx_packet<span class="variable">.addr</span>, tx_packet<span class="variable">.data</span>&#125; &#125;;</span><br><span class="line"><span class="comment">// 从左至右打包：addr在前，data在后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解包：从比特流中提取数据</span></span><br><span class="line">packet_t rx_packet;</span><br><span class="line">&#123; &gt;&gt; &#123;rx_packet<span class="variable">.addr</span>, rx_packet<span class="variable">.data</span>&#125; &#125; = packed_stream;</span><br><span class="line"><span class="comment">// 解包后：rx_packet.addr = 8&#x27;hA5, rx_packet.data = 32&#x27;h1234_5678</span></span><br></pre></td></tr></table></figure><ul><li>可指定片段宽度，再将数据按照指定宽度分段后再打包或解包</li><li>比特流结果不能直接赋值给<a href="../SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97">非合并数组</a><ul><li>这是因为非合并数组相邻元素间可能存在间隙，如定宽数组使用字边界</li><li>需在赋值表达式的左边使用流操作符把比特流拆分到非合并数组中</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] stream = <span class="number">32&#x27;hA5A5_A5A5</span>;</span><br><span class="line"><span class="keyword">int</span> arr [<span class="number">0</span>:<span class="number">3</span>]; <span class="comment">// 非合并数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值违反语言规则</span></span><br><span class="line">arr = stream; <span class="comment">// 编译报错</span></span><br><span class="line"><span class="comment">// 正确：左侧流操作符拆分比特流</span></span><br><span class="line">&#123; &gt;&gt; &#123;arr&#125; &#125; = stream;      <span class="comment">// 等价于按32比特分段，未被赋值的部分自动填充默认值0</span></span><br><span class="line">&#123; &gt;&gt; <span class="keyword">byte</span> &#123;arr&#125; &#125; = stream; <span class="comment">// 按照指定片段宽度解包</span></span><br></pre></td></tr></table></figure><h1 id="枚举类型">枚举类型</h1><h2 id="定义与特性">定义与特性</h2><ul><li><p>定义</p><ul><li>枚举类型<code>enum</code>定义一组命名常量集合</li><li>增强可读性和安全性，避免手动赋值繁琐易出错</li></ul></li><li><p>特性</p><ul><li><p>默认首标签为0，后续标签自动递增</p><ul><li>也可以显式指定任意数值，未赋值的标签继承上一个标签值+1</li></ul></li><li><p>默认基类为<code>int</code>，支持自定义基类，需显式声明宽度</p><ul><li>例如<code>enum bit &#123;TRUE=1, FALSE=0&#125; Boolean;</code></li></ul></li><li><p>标签值在同一枚举类型中必须唯一</p></li><li><p>标签名在同一模块中必须唯一，并且不能以数字开头</p></li><li><p>支持范围语法批量生成标签</p></li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;RED, YELLOW, GREEN&#125; light;  <span class="comment">// 默认标签：RED=0, YELLOW=1, GREEN=2</span></span><br><span class="line"><span class="keyword">enum</span> &#123;R, Y, G&#125; color;             <span class="comment">// 默认标签：R=0, Y=1, G=2</span></span><br><span class="line"><span class="comment">//标签值重复：虽然RED和R默认都为0，但属于两个不同的枚举类型，相互独立并不冲突</span></span><br><span class="line"><span class="comment">//也可使用显示赋值，避免打印时混淆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标签名称重复：同一模块内不同枚举类型的标签名称重复会导致编译错误，哪怕值不同</span></span><br><span class="line"><span class="keyword">enum</span> &#123;R = <span class="number">10</span>, Y, G&#125; color_e;      <span class="comment">// 默认标签：R=10, Y=11, G=12</span></span><br><span class="line"><span class="comment">//应对方法：使用唯一的标签名；在不同的模块中使用</span></span><br><span class="line"><span class="comment">//或使用typedef定义枚举类型，为每个枚举类型创建独立类型，减少名称污染风险</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;RESET, S[<span class="number">5</span>], W[<span class="number">6</span>:<span class="number">9</span>]&#125; state; <span class="comment">// 生成 RESET, S0-S4, W6-W9</span></span><br></pre></td></tr></table></figure><h2 id="自定义枚举类型">自定义枚举类型</h2><ul><li>使用<code>typedef</code>定义可复用的枚举类型<ul><li>支持包导入，需显式导入包<code>import ABC::*;</code>，<code>*</code>也可以是指定的枚举类型</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;INIT, DECODE, IDLE&#125; fsm_state_e; <span class="comment">//使用后缀_e表示枚举类型</span></span><br><span class="line">fsm_state_e st, nst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (st)</span><br><span class="line">        IDLE: nst = INIT;</span><br><span class="line">        INIT: nst = DECODE;</span><br><span class="line">        <span class="keyword">default</span>: nst = IDLE;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Next state is %s&quot;</span>, nst<span class="variable">.name</span>());</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="枚举类型子程序">枚举类型子程序</h2><ul><li><code>first()</code>或<code>first</code>返回第一个枚举常量</li><li><code>last()</code>返回最后一个枚举常量</li><li><code>next()</code>返回下一个枚举常量</li><li><code>next(N)</code>返回第N个枚举常量</li><li><code>prev()</code>返回前一个枚举常量</li><li><code>prev(N)</code>返回前第N个枚举常量</li></ul><blockquote><p>当到达枚举常量列表的头或尾时，函数<code>next</code>和<code>prev</code>会自动以环形方式绕回</p></blockquote><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历所有枚举成员</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, BLUE, GREEN&#125; color_e;</span><br><span class="line">color_e color;</span><br><span class="line">color = color<span class="variable">.first</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Color = %0d/%s&quot;</span>, color, color<span class="variable">.name</span>());</span><br><span class="line">        color = color<span class="variable">.next</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">while</span> (color != color<span class="variable">.first</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SV常量变量</title>
      <link href="/SV%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F/"/>
      <url>/SV%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="常量">常量</h1><h2 id="全局">全局</h2><ul><li><code>define</code>定义宏常量<ul><li>全局跨文件文本常量替换</li></ul></li></ul><h2 id="模块级">模块级</h2><ul><li><code>parameter</code>定义可重写模块级常量<ul><li>编译时常量，实例化时可被覆盖</li><li>支持表达式计算</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> RAM #(</span><br><span class="line">    <span class="keyword">parameter</span> DEPTH = <span class="number">1024</span>,                      <span class="comment">// 简单常量</span></span><br><span class="line">    <span class="keyword">parameter</span> ADDR_WIDTH = <span class="built_in">$clog2</span>(DEPTH),        <span class="comment">// 表达式计算</span></span><br><span class="line">    <span class="keyword">parameter</span> [<span class="number">7</span>:<span class="number">0</span>] INIT_VALUE = <span class="number">8&#x27;hA5</span>           <span class="comment">// 带类型声明</span></span><br><span class="line">) (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>] addrs</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">localparam</span> HIGH_BIT = ADDR_WIDTH - <span class="number">1</span>;        <span class="comment">// 派生常量</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化时覆盖参数</span></span><br><span class="line">RAM <span class="variable">#(.DEPTH(2048), .INIT_VALUE(8&#x27;hFF)) ram_inst()</span>;</span><br></pre></td></tr></table></figure><ul><li><code>localparam</code>定义不可重写模块级常量<ul><li>模块内部专用常量</li><li>不能被外部覆盖，常用于派生参数</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] a, b</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">localparam</span> OP_ADD = <span class="number">2&#x27;b00</span>;            <span class="comment">// 操作码常量</span></span><br><span class="line">    <span class="keyword">localparam</span> OP_SUB = <span class="number">2&#x27;b01</span>;</span><br><span class="line">    <span class="keyword">localparam</span> OP_AND = <span class="number">2&#x27;b10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">localparam</span> RESULT_WIDTH = <span class="number">9</span>;          <span class="comment">// 内部计算结果位宽</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure><h2 id="块、类级">块、类级</h2><ul><li><code>const</code>定义运行时可初始化的常量<ul><li>可在类、函数、initial块中使用</li><li>需要显示初始化，初始化后不可变</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE;     <span class="comment">// 声明</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> size);</span><br><span class="line">        MAX_SIZE = size;    <span class="comment">// 在构造函数中初始化</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">real</span> PI = <span class="number">3</span><span class="variable">.1415926</span>;         <span class="comment">// initial块常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">byte</span> START_ADDR = <span class="number">8&#x27;h40</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h2 id="枚举常量">枚举常量</h2><ul><li><code>typedef enum</code>定义枚举常量<ul><li>用于定义状态机、命令码等有限值集合</li><li>自动或手动赋值，提高代码可读性</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;       <span class="comment">// 显式指定底层类型</span></span><br><span class="line">    IDLE  = <span class="number">3&#x27;b001</span>,              <span class="comment">// 手动赋值</span></span><br><span class="line">    START = <span class="number">3&#x27;b010</span>,</span><br><span class="line">    RUN   = <span class="number">3&#x27;b100</span>,</span><br><span class="line">    ERROR = <span class="number">3&#x27;b111</span></span><br><span class="line">&#125; state_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;                   <span class="comment">// 自动赋值</span></span><br><span class="line">    RED,    <span class="comment">// 0</span></span><br><span class="line">    GREEN,  <span class="comment">// 1</span></span><br><span class="line">    BLUE    <span class="comment">// 2</span></span><br><span class="line">&#125; color_t;</span><br></pre></td></tr></table></figure><h2 id="常量函数">常量函数</h2><ul><li>用于复杂计算生成常量值</li><li>在编译时求值，只能包含常量表达式</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> clog2(<span class="keyword">input</span> <span class="keyword">int</span> n);</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span> + clog2(n &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> MEM_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">localparam</span> ADDR_W = clog2(MEM_SIZE); <span class="comment">// 计算结果为常量</span></span><br></pre></td></tr></table></figure><h1 id="静态变量">静态变量</h1><h2 id="声明">声明</h2><ul><li>隐式静态变量：<code>module</code>、<code>program</code>中的<code>function</code>和<code>task</code>中声明的变量默认是静态的</li><li>显示静态变量：使用<code>static</code>关键词显式声明</li></ul><h2 id="特性">特性</h2><ul><li><p>存储在全局数据区，固定内存位置</p></li><li><p>同一个模块多次实例化时共享静态变量</p><ul><li>由于使用共享的静态存储区，这也可能导致不用线程之间窜用</li></ul></li><li><p>适用场景</p><ul><li>模块级配置参数</li><li>硬件寄存器建模</li><li>时序逻辑总是使用静态变量保持状态<ul><li>如跨多个时钟周期保持值的计数器</li></ul></li><li>跨时间控制语句的变量</li></ul></li></ul><h2 id="生命周期">生命周期</h2><ul><li>从仿真开始（时间0）持续到仿真结束</li><li>在多次触发的过程块中，只在仿真时间为0时进行一次初始化</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 仅仿真开始时初始化为0，声明并非执行语句，后续不再重复初始化</span></span><br><span class="line">    count &lt;= count + <span class="number">1</span>;    <span class="comment">// 每次触发递增</span></span><br><span class="line"><span class="keyword">end</span>                           <span class="comment">// 输出序列：1, 2, 3...（非0,1,2...）</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 等效硬件行为，更推荐</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] counter = <span class="number">0</span>;      <span class="comment">// 综合为带初始值的寄存器</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="自动变量">自动变量</h1><h2 id="声明-v2">声明</h2><ul><li>隐式自动变量：<code>class</code>内部的<code>fucntion</code>、<code>task</code>中声明的变量默认是自动的，<code>initial</code>和<code>always</code>中声明的变量默认也是自动的</li><li>显示自动变量：使用<code>automatic</code>关键词显示声明<ul><li>建议在需要动态存储时，显式声明<code>automatic</code>，而非依赖隐式规则，避免混淆</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//program块中显示指定自动存储方式</span></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test();</span><br><span class="line">    <span class="comment">//用检测数据何时被写入存储器任务</span></span><br><span class="line">    <span class="keyword">task</span> wait_for_bus(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr, expect_data,</span><br><span class="line">                      <span class="keyword">output</span> <span class="keyword">logic</span> success);</span><br><span class="line">        <span class="keyword">while</span> (bus_addr !== addr)</span><br><span class="line">            @(bus_addr);</span><br><span class="line">        sucess = (bus_data == expect_data);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure><h2 id="特性-v2">特性</h2><ul><li>存储在栈帧中，动态分配内存</li><li>多实例独立，每次调用创建独立副本</li><li>适用场景<ul><li>纯计算逻辑中使用自动变量</li><li>递归函数必须使用自动变量</li><li>不需要保持状态的中间变量</li><li>验证环境中的临时对象</li></ul></li></ul><h2 id="生命周期-v2">生命周期</h2><ul><li>仅在作用域激活期间存在</li><li>每次进入作用域时重新初始化</li><li>作用域结束时销毁</li><li><code>initial</code>中的自动变量可能在进程挂起后被回收，根据仿真器调度选项而定</li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;                 <span class="comment">// 错误：在always内部隐式声明自动变量</span></span><br><span class="line">    count &lt;= count + <span class="number">1</span>;            <span class="comment">// 永远输出1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> calculate();</span><br><span class="line">    <span class="keyword">automatic</span> <span class="keyword">int</span> temp = <span class="number">0</span>;      <span class="comment">// 每次调用时初始化为0</span></span><br><span class="line">    temp++;</span><br><span class="line">    <span class="built_in">$display</span>(temp);              <span class="comment">// 总是显示1</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">automatic</span> <span class="keyword">int</span> delay = <span class="number">10</span>;</span><br><span class="line">  #delay;                          <span class="comment">// 挂起delay个时间单位</span></span><br><span class="line">  <span class="comment">// 调度器计划在($time + &amp;delay)时唤醒这个进程</span></span><br><span class="line">  <span class="comment">// 这里&amp;delay为delay的内存位置，而非实际值</span></span><br><span class="line">  <span class="comment">// 如果delay已被回收，仿真器可能无法确定何时唤醒</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><h1 id="时间值">时间值</h1><h2 id="单位与精度">单位与精度</h2><ul><li>一种方法是使用编译指示语句``timescale`。确保时延有适宜的量程和精度<ul><li>当采用多种``timescale`时，可能会因编译次序导致问题</li><li>建议每个文件末尾都以``timescale`结束，将其恢复为公司规定的默认值</li></ul></li><li>另一种方式是使用<code>timeunit</code>和<code>timeprecision</code>声明语句为每个模块指明时间<ul><li>若使用上述语句替代``timescale`，要求把它们放入每个带时延的模块中</li></ul></li></ul><h2 id="时间参数">时间参数</h2><ul><li>控制时间显示格式：<code>$timeformat(四个参数)</code>，主要影响<code>$display</code>、<code>monitor</code>等任务中<code>%t</code>格式符的输出<ul><li>第一个参数：时间单位指数（必填），如-9对应1ns、-12对应1ps</li><li>第二个参数：小数点后保留位数（默认0）</li><li>第三个参数：时间值后的后缀（默认空字符串）</li><li>第四个参数：时间字符串的最小宽度（默认20），自动左侧补空格</li></ul></li><li><code>$time</code>的返回值是根据所在模块的时间精度要求进行舍入的整数，<code>$realtime</code>的返回值则是带小数部分的完整实数<ul><li>在计算时延时也可以使用<code>time t</code>或<code>realtime r</code>定义变量存储数据</li><li>如在``timescase 1ns/100ps<code>中，</code>time t = 800ps<code>以1ns存储，</code>realtime r = 800ps`以0.8ns存储</li></ul></li></ul><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> timing;</span><br><span class="line">    <span class="keyword">timeunit</span> <span class="number">1</span>ns;</span><br><span class="line">    <span class="keyword">timeprecision</span> <span class="number">1</span>ps;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$timeformat</span>(-<span class="number">9</span>, <span class="number">3</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        #<span class="number">1</span>     <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//1.000ns</span></span><br><span class="line">        #<span class="number">2</span>ns   <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//3.000ns</span></span><br><span class="line">        #<span class="number">0</span><span class="variable">.1ns</span> <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//3.100ns</span></span><br><span class="line">        #<span class="number">41</span>ps  <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//3.141ns</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数字前端 </category>
          
          <category> SystemVerilog </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SystemVerilog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MIPI框架</title>
      <link href="/MIPI%E6%A1%86%E6%9E%B6/"/>
      <url>/MIPI%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="MIPI概述">MIPI概述</h1><h2 id="MIPI简介">MIPI简介</h2><ul><li><p><a href="www.mipi.org">MIPI联盟</a>（Mobile Industry Processor Interface Alliance，移动产业处理器接口联盟）是2003年由ARM、Nokia、意法半导体（ST）、德州仪器（TI）等公司成立的一个联盟</p><ul><li>成员规模超350家，覆盖芯片厂商、终端品牌、汽车制造商、测试机构</li><li>99%的智能手机使用至少3项MIPI标准（CSI-2 + DSI + I3C）</li></ul></li><li><p>MIPI协议把移动设备内部的接口如摄像头、显示屏、基带、射频接口等标准化，以减少设计的复杂度、提高设备的性能、同时降低功耗和成本</p><ul><li>MIPI并非单一接口或协议，而是包含一套协议和标准，以满足各种子系统的要求<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li></ul></li></ul><h2 id="MIPI框架">MIPI框架</h2><p>MIPI框架主要包含四个方面的协议</p><ul><li>多媒体（Multimedia）：面向功能，每种多媒体协议栈通常又由三个层次构成<ul><li>应用层（Application Layer）：直接面向用户的顶层协议</li><li>协议层（Protocol/Link Layer）：定义数据包结构、流控、错误校验等逻辑传输机制</li><li>物理层（Multimedia-PHY Layer）：负责电气信号传输、时钟同步和物理连接</li></ul></li><li>控制与数据（Control &amp; Data）：功能使能层，构成控制网络，实现子系统协同<ul><li>纵向：提供从控制逻辑到物理层的控制链</li><li>横向：串联多媒体、存储、调试等子系统</li><li>效能：通过RFFE单线制、I3C多主控等专用优化，降低功耗/面积/延迟</li></ul></li><li>芯片间互联（Chip-to-Chip\IPC, Inter Process Communications）：通过高速、标准化、低延时实现异构芯片（如APU/GPU/Modem）的高效协同，同样分为几个层级<ul><li>物理层：使用更高速率的M-PHY，或抗干扰更强的A-PHY</li><li>协议层：UniPro，流控与错误恢复，类比TCP/IP的可靠性机制</li><li>接口抽象层：HCI，统一管理UniPro和M-PHY的软件API，配置链路状态、功耗模式</li><li>场景化应用协议：如AP-Modem专用低延迟通道LLI等，绕开协议栈开销</li></ul></li><li>调试与追踪（Debug &amp; Trace），提供全流程覆盖的协议支持，并且不干扰功能</li></ul><img src="/images/image-20250711094554653.png" alt="image-20250711094554653" style="zoom:50%;" /><blockquote><p>GNSS：Global Navigation Satellite System，全球导航卫星系统<br>Codec：Coder-Decoder，编解码器<br>FM Radio：Frequency Modulation Radio，调频广播<br>ETPS：Embedded Test and Programming Support<br>eTrak：实时调试与数据追踪<br>Cellular：蜂窝<br>LNA：Low Noise Amplifier，低噪声放大器<br>Antenna Tuner：天线调谐器</p></blockquote><h2 id="MIPI协议">MIPI协议</h2><h3 id="多媒体">多媒体</h3><img src="/images/image-20250711145624735.png" alt="image-20250711145624735" style="zoom:50%;" /><ul><li><p>CSI-2 (Camera Serial Interface 2): 高速摄像头串行接口，主流手机/车载摄像头传输协议</p></li><li><p>D-PHY: 差分串行物理层，CSI-2 和 DSI 常用的低成本物理层</p><ul><li>最低配置：1对数据线+1对时钟线</li><li>使用基于差分信号的NRZ编码</li></ul></li><li><p>C-PHY: C表示Clock-less，较D-PHY有更高带宽效率的物理层，常用于 CSI-2 和 DSI</p><ul><li>无需额外布置时钟线，3线制（Triplet）每通道</li><li>使用3-phase符号编码，嵌入时钟信息</li></ul></li><li><p>DSI (Display Serial Interface): 高速显示屏串行接口，用于手机/平板等屏幕驱动</p></li><li><p>CSI-3: 新一代摄像头接口，基于MIPI M-PHY或C-PHY，扩展性更强（如车用多摄像头）</p></li><li><p>SLIMbus (Serial Low-power Inter-chip Media Bus): 数字音频数据传输总线</p></li><li><p>SoundWire: 新一代数字音频接口，简化布线，替代SLIMbus</p></li></ul><blockquote><p>SLIMbus/SoundWire 是完整协议栈（含应用层+协议层+物理层），物理层非D/C-PHY</p></blockquote><h3 id="控制与数据">控制与数据</h3><img src="/images/image-20250711145606842.png" alt="image-20250711145606842" style="zoom:50%;" /><ul><li>I3C (Improved Inter-Integrated Circuit): 革命性传感器控制总线/改进型I2C，融合I2C/SPI/UART优点，高速、低功耗、多主控，用于陀螺仪/加速度计传感器控制、电源管理</li><li>I3C Basic: I3C 的子集，低成本、简化版传感器控制总线</li><li>RFFE (RF Front-End Control Interface): 射频前端控制接口，制手机天线开关、功率放大器</li><li>SPMI (System Power Management Interface): 处理器与外设间的电源管理通信协议</li><li>SSIC (SuperSpeed Inter-Chip): 基于USB 3.0的芯片间高速数据传输协议</li></ul><blockquote><p>I3C 因同时涵盖高效控制与简化调试，横跨 Control &amp; Data 和 Debug &amp; Trace 领域</p></blockquote><h3 id="芯片间互联">芯片间互联</h3><img src="/images/image-20250711150529204.png" alt="image-20250711150529204" style="zoom:50%;" /><ul><li>M-PHY: 高速、可扩展物理层，用于芯片间或板间互连（如UFS存储接口）</li><li>UniPro (Unified Protocol): 基于M-PHY的应用层协议，构建通用芯片互连（如UFS）</li><li>LLI (Low Latency Interface): 应用处理器与调制解调器间超低延迟通信接口</li><li>HCI (HYBRID Command Interface): 管理 UniPro 和 M-PHY 栈的通用接口</li><li>DigRF: （已被后续协议替代）早期基带与射频芯片间数字接口</li><li>A-PHY (Automotive SerDes PHY): 长距离、高抗扰车规级高速物理层（用于车载摄像头/显示屏互连）</li></ul><h3 id="控制与调试">控制与调试</h3><ul><li>SDBI (Serial Debug Bus Interface): 基于I3C的低引脚数调试接口</li><li>STP (System Trace Protocol): 跨多核系统的软件跟踪协议</li><li>TWP (Trace Wrapper Protocol): 封装不同跟踪源数据的协议</li><li>MTB (MIPI Trace Buffer): 低成本片上跟踪缓冲区规范</li><li>PTI (Parallel Trace Interface): 替代传统并行调试接口的标准</li><li>BIST (Built-In Self Test): 集成自测试框架（如CSI-2 TX/RX测试）</li><li>SYS-T (System Trace): 定义时间戳和系统事件格式的框架</li><li>NIDnT (Non-Intrusive Debug and Trace): 用于I3C的非侵入式调试规范</li></ul><h1 id="MIPI-CSI-2">MIPI CSI-2</h1><p><img src="/images/image-20250711114740490.png" alt="image-20250711114740490"></p><h2 id="协议概述">协议概述<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></h2><ul><li><p>CSI协议旨在为高清摄像头和应用处理器之间提供一个高速的串行接口</p></li><li><p>目前常见的摄像头接口协议有CSI-2、USB3.0、DVP，相比DVP接口和USB3.0接口，CSI-2接口在图像数据的传输性能上拥有明显的优势<br><img src="/images/image-20250711152614939.png" alt="image-20250711152614939"></p><ul><li><p>串行传输</p><ul><li>使用的数据线相对较少，并且CSI-2一般采用双线差分传输 （D-PHY）</li><li>噪声同时加载到并行传输的两条差分线可以相互抵消，具有更强的抗干扰能力</li></ul></li><li><p>校验编码</p><ul><li>ECC能够监测2bit以内的数据出错和纠正1bit的数据出错</li><li>CRC能够监测多bit的数据出错，使CSI-2接口对数据传输具备更高容错</li></ul></li><li><p>功耗与传输速率</p><ul><li><p>CSI-2接口支持高速(HS)与低功耗(LP)两种模式协同工作</p></li><li><p>高速模式下使用 0.2V 低压差分电压，用于传输图像数据，其传输速度范围在</p><p>80Mbps 至 1000Mbps</p></li><li><p>低功耗模式下使用 12V 差分电压，用于传输控制命令，最高传输速度为 10Mbps</p></li><li><p>接口在正常工作时，会在一次高速模式传输后插入低功耗模式，两种模式相互切换使得 CSI-2接口同时兼顾了低功耗需求</p></li></ul></li></ul></li></ul><h2 id="总体框架">总体框架</h2><p><img src="/images/image-20250711154506468.png" alt="image-20250711154506468"></p><ul><li>应用层：面向用户，可在应用层中实现对原始图像数据进行高级编码以及处理各种算法</li><li>协议层：由以下层级构成<ul><li>像素与字节的组包层：在发送端中，组包层负责将来自应用层的图片像素信息打包成为字节，然后输送至低级协议层中</li><li>解包层：在接收端中，解包层将来自低级协议层中的字节解压并还原，然后将数据流传输至接收端应用层</li><li>低级协议层：对起始指令SoT和终止指令SoT之间串行数据建立bit级和byte级同步，并将数据传输至下一层，包含对大小端的控制</li><li>通道管理层：数据通道的数量可以根据带宽需求进行选择，在发送端，接口将字节分发到一个或多个通道；在接收端，接口从通道中收集字节并将其合并重组，恢复出原始的数据流</li></ul></li><li>物理层：规范了传输媒介，电气特性，I/O电路以及bit级和byte级的同步机制，支持High-Speed模式和Low-Power模式，所有功能最终映射为：<ul><li>模拟电路：差分放大器、压控振荡器VCO、比较器</li><li>数字电路：移位寄存器、状态机、FIFO</li><li>无源器件：终端电阻、电容（AC耦合）</li></ul></li></ul><p><img src="/images/image-20250711171639524.png" alt="image-20250711171639524"></p><h2 id="数据包格式">数据包格式</h2><ul><li>用于CSI-2中D-PHY物理层的数据包可以分为长数据包和短数据包</li></ul><h3 id="长数据包">长数据包</h3><p><img src="/images/image-20250711161101845.png" alt="image-20250711161101845"></p><ul><li>长数据包格式如上图所示，由三个部分组成<ul><li>32bit数据包头（PH），并由以下部分构成<ul><li>8bit数据标识符号（DI, Data Identifier）：由bit7-6的虚拟通道和bit5-0的数据类型构成</li><li>16bit字计数值（WC, Word Count）：统计长数据包的字节数，在有需要的情况表示第几帧或是第几行</li><li>8bit VCX+ECC校验位：由bit7-6的虚拟通道扩展位和bit5-0的ECC校验位构成</li></ul></li><li>有效载荷：具有可变字节数量的专用数据</li><li>16bit数据包页脚（PF）：即16bit CRC校验位</li></ul></li></ul><h3 id="短数据包">短数据包</h3><p><img src="/images/image-20250711161111820.png" alt="image-20250711161111820"></p><ul><li>短数据包结构如上图所示，与长数据包结构相似，不同之处在于<ul><li>短数据包只包含有一个数据包头，数据包填充字段和数据包尾均不存在</li></ul></li></ul><h2 id="CCI接口">CCI接口</h2><h3 id="多速率模式">多速率模式</h3><ul><li>CCI，即摄像头控制接口，用于配置发送端口，使用两线接口（时钟线 SCL 和数据线 SDA），并具有半双工，串行的特点，兼容I2C协议，支持多速率模式<ul><li>传统I2C兼容模式（FM, Fast Mode）：400 Kbps<ul><li>开漏输出：只能依赖NMOS主动拉低电平，依赖外部上拉电阻Rp</li><li>数据采样点位于SCL高电平中点</li></ul></li><li>增强I2C模式（FM+, Fast Mode）：1 Mbps<ul><li>推挽输出（Push-Pull Output）：由PMOS上拉管 + NMOS下拉管组成互补输出级（Totem Pole，图腾柱），不再依赖Rp</li><li>上升速度更快（PMOS导通决定），抗干扰更强（主动驱动低阻），但功耗更高（开关瞬态功耗）</li></ul></li><li>单数据模式（SDR，I3C专用）12.5 Mbps<ul><li>单边沿触发器：SCL上升沿锁存SDA数据</li></ul></li><li>双数据模式（DDR，I3C专用）25 Mbps<ul><li>双边沿触发器：SCL上升沿/下降沿各锁存1 bit</li></ul></li></ul></li></ul><h3 id="数据结构">数据结构</h3><ul><li>CCI数据传输协议遵循I2C规范，其读写结构如下图所示</li></ul><p><img src="/images/image-20250711170045936.png" alt="image-20250711170045936"></p><p><img src="/images/image-20250711170100702.png" alt="image-20250711170100702"></p><h2 id="CSI-2接口模型">CSI-2接口模型</h2><ul><li>CSI-2规范定义了发送端和接收端的协议和控制接口CCI，可选择D-PHY或C-PHY物理层作为高速串行数据的传输接口选项</li><li>C-PHY和D-PHY在物理连接上存在多处不同，主从机必须使用同一种物理层<ul><li>C-PHY具备更高的传输速率，但只支持CSI-2</li><li>D-PHY同时支持CSI-2和DSI，具备更高兼容性</li></ul></li></ul><p><img src="/images/image-20250711170601360.png" alt="image-20250711170601360"></p><blockquote><p>一般情况下，对低于五百万像素的摄像头只需使用两对差分数据线，即两条数据通道</p></blockquote><h1 id="MIPI-DSI">MIPI DSI</h1><ul><li>DSI协议栈从框架上来看和CSI类似，并且能够实现摄像头-处理器-屏幕的功能组合</li></ul><img src="/images/1646035937837020.png" alt="img" style="zoom: 80%;" /><h2 id="协议概述-v2">协议概述<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></h2><p><img src="/images/image-20250711174305103.png" alt="image-20250711174305103"></p><ul><li>DSI 定义了主机处理器与显示外设之间传输图像和指令的接口协议</li><li>它采用了MIPI 联盟已有的 DPI-2、DBI-2 定义的像素格式，和 DCS 定义的命令集标准</li></ul><blockquote><ul><li>DPI-2 (Display Pixel Interface 2)<ul><li>显示控制器（Source）到显示面板（Sink）的并行像素流格式协议</li><li>用于直连型显示驱动，无需帧缓存，如MCU直接驱动LCD屏</li></ul></li><li>DBI-2 (Display Bus Interface 2)<ul><li>基于显示缓存的命令/数据总线协议，具备两种操作模式<ul><li>Command Mode：发送配置命令，如初始化序列</li><li>Video Mode：写入帧缓存数据，像素刷新</li></ul></li><li>面板内置帧存，如手机AMOLED屏</li></ul></li><li>DCS (Display Command Set)<ul><li>显示面板的初始化与控制指令集协议，适用于DBI-2/DSI接口</li><li>统一不同面板厂商的驱动代码</li></ul></li></ul></blockquote><h2 id="框架模型">框架模型</h2><ul><li>DSI的框架与CSI类似，同样分为了应用层、协议层和物理层</li></ul><p><img src="/images/image-20250711174126995.png" alt="image-20250711174126995"></p><h2 id="DCS命令集简介">DCS命令集简介</h2><ul><li>DCS是用于实现DSI和DBI-2协议的命令集<ul><li>主机处理器通过向显示模块发送命令，可以写入图像数据、配置显示模块工作状态或读取显示状态和数据</li><li>在显示端，显示控制器接收并解析命令，根据命令执行相应的操作</li></ul></li><li>DCS命令按照类型可以分短命令和长命令，前者不包含或只包含一个参数，后者包含多个参数</li><li>按照功能可分为制造商命令集和用户命令集<ul><li>制造商命令集是一种设备相关的协议，用于为出厂设备写入默认参数，设备配置完成出厂后，该命令集应被禁止，显示设备不再响应此命令集的命令</li><li>用户命令集是一种设备无关的协议，用于操作系统的硬件抽象层，下图位常用DCS用户命令集</li></ul></li></ul><p><img src="/images/image-20250711174737174.png" alt="image-20250711174737174"></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://github.com/DRubioG/MIPI_Specification#">MIPI Specs</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>陈锐弦.基于FPGA和MIPI CSI-2的双摄像头图像采集系统设计[D].西安电子科技大学,2021. <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p>张豪.基于FPGA的MIPI-DSI发送接口设计与实现[D].华中科技大学,2019. <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 知识储备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MIPI </tag>
            
            <tag> CSI-2 </tag>
            
            <tag> DSI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo部署</title>
      <link href="/Hexo%E9%83%A8%E7%BD%B2/"/>
      <url>/Hexo%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="工具安装">工具安装</h1><ul><li><p><a href="../Git%E6%8C%87%E5%8D%97">安装Git</a></p></li><li><p>安装<a href="https://nodejs.org/en/">node.js</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p><ul><li>Node.js 是一个开源的、跨平台的 <strong>JavaScript 运行时环境</strong>，用于在服务器端执行 JavaScript 代码</li></ul></li><li><p>安装Hexo</p><ul><li>在站点根目录打开Git Bash，安装Hexo<code>npm install -g hexo-cli</code><sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></li><li>Hexo 是一个基于 Node.js 的静态博客框架， 能够将Markdown 文档快速渲染成静态的 HTML 网页</li></ul></li></ul><h1 id="网页部署">网页部署</h1><h2 id="本地部署">本地部署</h2><ul><li>输入<code>hexo init</code>初始化博客（首次）</li><li>输入<code>hexo clean</code>清除旧渲染（渲染效果变更时）</li><li>输入<code>hexo g</code>静态部署（hexo generate）</li><li>输入<code>hexo s</code>本地预览（hexo server）</li></ul><p><img src="/images/image-20250709143108331.png" alt="image-20250709143108331"></p><ul><li>打开网页 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看，Git Bash中使用<code>ctrl</code>+<code>c</code>停止运行</li></ul><img src="/images/image-20250709143123112.png" alt="image-20250709143123112" style="zoom:50%;" /><h2 id="草稿发布">草稿发布</h2><ul><li>建立文章草稿<code>hexo new draft &lt;filename&gt;</code><ul><li>将新文章建立在source/_drafts目录，不影响服务器部署</li></ul></li><li>本机预览草稿<code>hexo s --draft</code><ul><li>不影响再次<code>hexo s</code>生成的预览内容</li></ul></li><li>草稿发表<code>hexo p &lt;filename&gt;</code><ul><li>将文章从source/draft移动到source/posts</li></ul></li></ul><h2 id="GitHub部署">GitHub部署</h2><blockquote><p><a href="../Git%E6%8C%87%E5%8D%97">Git指南</a></p></blockquote><ul><li>创建一个.github.io的仓库</li></ul><img src="/images/image-20250709143245133.png" alt="image-20250709143245133" style="zoom:50%;" /><ul><li>编辑Blog中的_config.yml文件，添加GitHub部署地址</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:arvinhwo/arvinhwo.github.io.git</span>  <span class="comment"># your url</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><ul><li>输入<code>npm install hexo -deployer-git --save</code>安装Git插件<ul><li>输入<code>hexo clean</code>清除缓存文件db.json和静态文件public</li><li>输入<code>hexo g</code>生成网站静态文文件</li><li>输入<code>hexo d</code>部署到指定仓库（hexo deploy）</li></ul></li><li>部署完成后，打开网页 <a href="https://arvinhwo.github.io/">https://arvinhwo.github.io/</a> 查看</li><li>大部分情况下无法上传，刷新DNS缓存即可<ul><li>Windows: <code>ipconfig /flushdns</code></li><li>Linux: <code>sudo systemctl restart systemd-resolved</code></li><li>macOS: <code>sudo killall -HUP mDNSResponder</code></li></ul></li></ul><h2 id="解析域名">解析域名</h2><ul><li>使用<code>ping your.github.io -4</code>获取GitHub服务器的IPV4地址</li></ul><img src="/images/image-20250709143406082.png" alt="image-20250709143406082" style="zoom:67%;" /><ul><li>在已购域名的控制台中添加github.io的解析记录</li></ul><img src="/images/image-20250709143416072.png" alt="image-20250709143416072" style="zoom: 67%;" /><ul><li><p>在Blog\source路径中添加CNAME文件，存入域名arvinhwo.com后，依次以下命令重新部署</p><ul><li><code>hexo clean</code></li><li><code>hexo g</code></li><li><code>hexo d</code></li></ul></li><li><p>打开GitHub检查CNAME是否被正确设置</p></li><li><p>浏览器输入域名 <a href="http://arvinhwo.com">arvinhwo.com</a> 进入</p></li></ul><h1 id="站点配置">站点配置</h1><blockquote><p>使用Typora作为文本编辑器，参见本站文章<a href="../Typora%E6%8A%80%E5%B7%A7">Typora技巧</a></p></blockquote><h2 id="引用文章">引用文章</h2><ul><li>在Hexo渲染出的网页中引用已发布的文章，首先修改站点配置文件_config.yml中的permalink</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://arvinhwo.com</span></span><br><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br></pre></td></tr></table></figure><ul><li>Typora引用使用<code>[titile](../filename_without.md)</code>的Markdown代码</li></ul><h2 id="引用图片">引用图片</h2><ul><li>在blog/source/路径下新建images文件夹，.md文件放入默认位置blog/source/_posts/</li><li>将Typora-格式-设置图片根目录设置为source，体现在文章的YAML中即为<code>typora-root-url: ./..</code></li><li>将Typora-偏好设置-图片设置如下</li></ul><img src="/images/image-20250709150435441.png" alt="image-20250709150435441" style="zoom: 33%;" /><ul><li>此后Typora中和Hexo渲染均可正确显示图片</li></ul><blockquote><p>由于Gitee不允许个人使用仓库当作图床使用，也可改用GitHub图床<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>，若使用GitHub作为图床同样需要CDN加速</p></blockquote><ul><li>由于不适用和文件同名的文件夹用于存储文件，可以关闭站点配置文件中的<code>post_asset_floder: false</code>，这样在使用<code>hexo new</code>、<code>hexo new draft</code>和<code>hexo p</code>命令时，不再自动生成同名文件夹</li></ul><h2 id="添加脚注">添加脚注</h2><ul><li>Hexo无法渲染Typora中的脚注，因此使用插件解决<ul><li>卸载原渲染插件<code>npm un hexo-renderer-marked --save</code></li><li>安装GitHub风格渲染插件<code>npm i hexo-renderer-markdown-it --save</code></li><li>修改站点配置文件_config.yml</li></ul></li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Markdown-it config</span></span><br><span class="line"><span class="comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="comment"># 渲染设置</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="comment"># 置为true时，html内容保持不变；置为false时，html内容将被转义成普通字符串</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否生成与XHTML完全兼容的标签（虽然我不懂是什么意思）</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 置为true时，每个换行符都被渲染成一个&lt;br&gt;（即Hexo的默认表现）；置为false时，只有空行才会被渲染为&lt;br&gt;（GFM的默认表现）</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别链接并把它渲染成链接</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别印刷格式（意思是把(c)渲染为©这样的）</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 如果typographer被设置为true，则该选项用于设置将dumb quotes（&quot;&quot;）自动替换为smart quotes</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="comment"># 设置所需插件</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">  <span class="comment"># 锚点设置</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;v&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br></pre></td></tr></table></figure><h2 id="任务列表">任务列表</h2><ul><li>安装GitHub风格渲染插件<code>npm install hexo-renderer-markdown-it --save</code></li><li>安装缺失依赖项<code>npm install markdown-it-task-lists --save</code></li><li>编辑站点配置配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-task-lists</span>  <span class="comment"># 启用任务列表插件</span></span><br></pre></td></tr></table></figure><h2 id="缩进替换">缩进替换</h2><ul><li>将<code>tab</code>替换为四个空格，编辑站点配置文件</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;    &#x27;</span> <span class="comment">#将\t替换为指定数量的空格</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://blog.csdn.net/antma/article/details/86104068">node.js安装步骤</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://hexo.io/docs/">Hexo使用文档</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/138012354">Blog使用GitHub图床</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora技巧</title>
      <link href="/Typora%E6%8A%80%E5%B7%A7/"/>
      <url>/Typora%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h1 id="Typora技巧">Typora技巧</h1><h2 id="编辑">编辑</h2><ul><li>撤销：<code>ctrl</code>+<code>z</code></li><li>取消撤销：<code>ctrl</code>+<code>y</code></li><li>跳转至光标位置：<code>ctrl</code>+<code>j</code></li><li>跳转至顶部：<code>ctrl</code>+<code>home</code></li><li>跳转至底部：<code>ctrl</code>+<code>end</code></li><li>替代：<code>ctrl</code>+<code>h</code></li><li>查找下一个：<code>enter</code></li><li>查找上一个：<code>shift</code>+<code>enter</code></li><li>选择词：<code>ctrl</code>+<code>d</code></li><li>删除词：<code>ctrl</code>+<code>shift</code>+<code>d</code></li><li>选择行(表格中)/句子(句号或回车)：<code>ctrl</code>+<code>l</code></li><li>删除行(表格中)：<code>ctrl</code>+<code>shift</code>+<code>backspace</code></li><li>选择表格中单元格/段落中同格式：<code>ctrl</code>+<code>e</code></li></ul><h2 id="格式">格式</h2><ul><li><strong>加粗</strong>：快捷键<code>ctrl</code>+<code>b</code><br>源代码：<code>**strong**</code></li><li><em>斜体</em>：快捷键<code>ctrl</code>+<code>i</code><br>源代码：<code>*emphasis*</code></li><li><u>下划线</u>：快捷键<code>ctrl</code>+<code>u</code></li><li><s>删除线</s>：快捷键<code>alt</code>+<code>shift</code>+<code>5</code></li><li><code>代码</code>：快捷键<code>ctrl</code>+<code>shift</code>+<code>反单引号</code><br>源代码：<code>反单引号 code 反单引号</code></li></ul><blockquote><p>以上格式均支持先快捷键后输入文本，及先输入文件后快捷键</p></blockquote><h2 id="标题">标题</h2><ul><li>设置标题：<code>ctrl</code>+<code>1~6</code><br>源代码：<code>#</code>+<code>Space</code>+Heading</li><li>标题升级：<code>ctrl</code>+<code>=</code></li><li>标题降级：<code>ctrl</code>+<code>-</code></li><li>取消标题：<code>ctrl</code>+<code>0</code></li></ul><h2 id="段落">段落</h2><ul><li>新段落：<code>enter</code></li><li>同段落新行：<code>shift</code>+<code>enter</code></li><li>缩进：<code>ctrl</code>+<code>[</code> 或 <code>tab</code></li><li>减少缩进：<code>ctrl</code>+<code>]</code> 或 <code>shift</code>+ <code>tab</code></li></ul><h2 id="列表">列表</h2><h3 id="无序列表">无序列表</h3><ul><li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>]</code><br>源代码：<code>*</code>/<code>+</code>/<code>-</code>+<code>Space </code>+ Paragraph</li><li>设置子列表等同缩进<br>取消子列表等同取消缩进</li></ul><blockquote><p>无序列表示例：</p><ul><li>段落1 (Enter)</li><li>段落2行1 (Shift+Enter)<br>段落2行2</li><li>段落3<ul><li>子列表段落1</li></ul></li></ul></blockquote><h3 id="有序列表">有序列表</h3><ul><li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>[</code><br>源代码：<code>1.</code> +<code>Space </code>+ Paragraph</li></ul><blockquote><p>有序列表示例：</p><ol><li>有序段落1<ol><li>有序段落1.1<ol><li>有序段落1.1.1</li></ol></li></ol></li></ol></blockquote><h3 id="任务列表">任务列表</h3><ul><li>任务列表：<code>ctrl</code>+<code>shift</code>+<code>x</code></li></ul><blockquote><p>任务列表示例：</p><ul class="contains-task-list"><li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 任务1</li><li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 任务2</li></ul></blockquote><h2 id="功能">功能</h2><h3 id="区块">区块</h3><ul><li>段落引用：<code>ctrl</code>+<code>shift</code>+<code>Q</code><br>源代码：<code>&gt;</code>+<code>Space</code></li><li>取消引用等同取消缩进</li></ul><blockquote><p>引用区块示例，用于进一步解释段落中的内容</p></blockquote><h3 id="链接">链接</h3><ul><li>将链接复制入剪切板后：<code>ctrl</code>+<code>k</code><br>源代码：<code>[titile](url)</code> or <code>[titile](#handing)</code></li></ul><blockquote><p>示例：<br>网页跳转：<a href="https://support.typora.io/Shortcut-Keys/#change-shortcut-keys">Typora快捷键</a><br>文内跳转：标题-<a href="#%E7%BC%96%E8%BE%91">编译</a><br>本地文件跳转同理</p></blockquote><ul><li>此外，提供另一种显示链接的方法，便于集中管理所有链接：<ul><li>源代码：<code>[titile][]</code></li><li>UI界面：段落-&gt;链接引用，再补全<code>[titile]:link url &quot;optional&quot;</code></li></ul></li></ul><blockquote><p><a href="https://blog.csdn.net/he_nan/article/details/105850141" title="网页名称可选">链接测试</a></p></blockquote><h3 id="脚注">脚注</h3><ul><li>脚标源代码：<code>[^1]</code></li><li>脚注代码：<code>[^1]:脚注</code><br>脚注UI：段落-&gt;脚注</li></ul><blockquote><p>示例：<br>使用脚注对于正文扩展进行说明<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><br>在Typora的编辑中，可将脚标与脚注放在一起<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p></blockquote><ul><li>自定义快捷键<ul><li>打开文件-偏好设置-通用-高级设置</li><li>配置conf.user.json文件，配置以下快捷键</li></ul></li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">&quot;keyBinding&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Footnotes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ctrl+Shift+P&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure><h3 id="代码">代码</h3><ul><li>段落内代码<br>快捷键：<code>ctrl</code>+<code>shift</code>+<code>反单引号</code><br>源代码：<code>反单引号 code 反单引号</code></li><li>代码块<br>快捷键：<code>ctrl</code>+<code>shift</code>+<code>k</code><br>源代码：<code>三反单引号 code block 三反单引号</code></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pyperclip</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageGrab</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image_to_base64</span>(<span class="params">image</span>):</span><br><span class="line">    buffered = io.BytesIO()</span><br><span class="line">    image.save(buffered, <span class="built_in">format</span>=<span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(buffered.getvalue()).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image = ImageGrab.grabclipboard()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(image, Image.Image):</span><br><span class="line">            base64_image = image_to_base64(image)</span><br><span class="line">            pyperclip.copy(<span class="string">f&quot;![image](data:image/png;base64,<span class="subst">&#123;base64_image&#125;</span>)\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;图像已转换为Base64并复制&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        raw_path = pyperclip.paste().strip(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">        file_path = os.path.normpath(raw_path)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(file_path):</span><br><span class="line">            <span class="keyword">with</span> Image.<span class="built_in">open</span>(file_path) <span class="keyword">as</span> img:</span><br><span class="line">                base64_image = image_to_base64(img)</span><br><span class="line">            pyperclip.copy(<span class="string">f&quot;![image](data:image/png;base64,<span class="subst">&#123;base64_image&#125;</span>)\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;文件图像已转换为Base64并复制&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;剪切板无有效图像或文件&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><h3 id="公式">公式</h3><ul><li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>m</code><br>源代码：<code>$$math bock$$</code></li></ul><p>公式示例-薛定谔方程（一维定态）</p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mo>−</mo><mfrac><msup><mi mathvariant="normal">ℏ</mi><mn>2</mn></msup><mrow><mn>2</mn><mi>m</mi></mrow></mfrac><mfrac><mrow><msup><mi>d</mi><mn>2</mn></msup><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><mrow><mi>d</mi><msup><mi>x</mi><mn>2</mn></msup></mrow></mfrac><mo>+</mo><mi>V</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mi>E</mi><mi>ψ</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">-\frac{\hbar^2}{2m}\frac{d^2\psi(x)}{dx^2} + V(x)\psi(x) = E\psi(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.1771em;vertical-align:-0.686em;"></span><span class="mord">−</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span><span class="mord mathnormal">m</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord">ℏ</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.7401em;"><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">E</span><span class="mord mathnormal" style="margin-right:0.03588em;">ψ</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span></span><h3 id="图片">图片</h3><ul><li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>i</code>或复制后直接<code>ctrl</code>+<code>v</code><br>源代码：<code>![titile](url/localpath)</code></li></ul><img src="/images/image-20250709141106758.png" alt="image-20250709141106758" style="zoom: 33%;" /><ul><li>设置本地图片副本存储位置</li><li>使用PicGo图床上传，在Gitee保存图片副本<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><ul><li>安装<a href="https://nodejs.org/en/">Node.js</a></li><li>注册<a href="https://gitee.com/">Gitee</a></li><li>新建开源Gitee<a href="https://gitee.com/arvinhwo/typoraimage">仓库</a></li><li>生成Gitee<a href="D:%5CDocument%5CPassword.txt">私人令牌</a></li><li>在Typora中下载<a href="C:%5CUsers%5Carvin%5CAppData%5CRoaming%5CTypora%5Cpicgo">PicGo-Core</a></li><li>打开配置文件</li><li>验证图片上传选项</li></ul></li><li>点击格式-图像-上传所有本地图片批量上传</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;gitee&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;仓库地址（不带gitee的域名）&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee 私人令牌 必填&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义存储路径，可以不填&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;域名，没有可以不填&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;分支名，默认是 master&quot;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDDHHmmss&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><img src="/images/image-20250709142115308.png" alt="image-20250709142115308" style="zoom:50%;" /><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>脚注可用于解释英文缩略词等 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p>脚注在导出HTML中会按顺序在文末 <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://juejin.cn/post/7089308017266524197">PicGo-Gitee参考教程</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 操作指南 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Typora </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
