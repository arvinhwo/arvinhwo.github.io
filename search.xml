<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo部署</title>
    <url>/Hexo%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="网页部署">网页部署</h1>
<h2 id="环境依赖">环境依赖</h2>
<ul>
<li>
<p>安装<a href="https://git-scm.com/install/">Git</a></p>
</li>
<li>
<p>安装<a href="https://nodejs.org/en/">node.js</a></p>
<ul>
<li>Node.js 是一个开源的、跨平台的 <strong>JavaScript 运行时环境</strong>，用于在服务器端执行 JavaScript 代码</li>
</ul>
</li>
<li>
<p>安装<a href="https://hexo.io/docs/">Hexo</a></p>
<ul>
<li>Hexo 是一个基于 Node.js 的静态博客框架， 能够将Markdown 文档快速渲染成静态的 HTML 网页</li>
<li>在站点根目录安装Hexo<code>npm install -g hexo-cli</code></li>
<li>输入<code>hexo -v</code>检查是否安装成功</li>
</ul>
</li>
</ul>
<h2 id="本地部署">本地部署</h2>
<ul>
<li>输入<code>hexo init</code>初始化博客（首次）</li>
<li>输入<code>hexo g</code>静态部署（hexo generate）</li>
<li>输入<code>hexo s</code>本地预览（hexo server）
<ul>
<li>可以打开网页 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看，Shell中使用<code>ctrl</code>+<code>c</code>停止运行</li>
</ul>
</li>
</ul>
<img src="/images/image-20251202152742433.png" alt="image-20251202152742433" style="zoom:33%;" />
<h2 id="草稿发布">草稿发布</h2>
<ul>
<li>建立文章草稿<code>hexo new draft &lt;filename&gt;</code>
<ul>
<li>将新文章建立在source/_drafts目录，不影响服务器部署</li>
</ul>
</li>
<li>本机预览草稿<code>hexo s --draft</code>
<ul>
<li>不影响再次<code>hexo s</code>生成的预览内容</li>
</ul>
</li>
<li>草稿发表<code>hexo p &lt;filename&gt;</code>
<ul>
<li>将文章从source/draft移动到source/posts</li>
</ul>
</li>
</ul>
<h2 id="GitHub部署">GitHub部署</h2>
<ul>
<li>Git命令行操作参见<a href="../Git%E6%8C%87%E5%8D%97">Git指南</a></li>
<li>创建一个.github.io的仓库</li>
</ul>
<img src="/images/image-20250709143245133.png" alt="image-20250709143245133" style="zoom:50%;" />
<ul>
<li>编辑Blog中的_config.yml文件，添加GitHub部署地址</li>
</ul>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repository:</span> <span class="string">git@github.com:arvinhwo/arvinhwo.github.io.git</span>  <span class="comment"># your url</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<ul>
<li>输入<code>npm install hexo-deployer-git --save</code>安装Git插件
<ul>
<li>输入<code>hexo clean</code>清除缓存文件db.json和静态文件public</li>
<li>输入<code>hexo g</code>生成网站静态文文件</li>
<li>输入<code>hexo d</code>部署到指定仓库（hexo deploy）</li>
</ul>
</li>
<li>部署完成后，打开网页 <a href="https://arvinhwo.github.io/">https://arvinhwo.github.io/</a> 查看</li>
<li>大部分情况下无法上传，刷新DNS缓存即可
<ul>
<li>Windows: <code>ipconfig /flushdns</code></li>
<li>Linux: <code>sudo systemctl restart systemd-resolved</code></li>
<li>macOS: <code>sudo killall -HUP mDNSResponder</code></li>
</ul>
</li>
</ul>
<h2 id="解析域名">解析域名</h2>
<ul>
<li>使用<code>ping your.github.io -4</code>获取GitHub服务器的IPV4地址</li>
</ul>
<img src="/images/image-20250709143406082.png" alt="image-20250709143406082" style="zoom:67%;" />
<ul>
<li>在已购域名的控制台中添加github.io的解析记录</li>
</ul>
<img src="/images/image-20250709143416072.png" alt="image-20250709143416072" style="zoom: 67%;" />
<ul>
<li>
<p>在Blog\source路径中添加CNAME文件，存入域名arvinhwo.com后，依次以下命令重新部署</p>
<ul>
<li><code>hexo clean</code></li>
<li><code>hexo g</code></li>
<li><code>hexo d</code></li>
</ul>
</li>
<li>
<p>打开GitHub检查CNAME是否被正确设置</p>
</li>
<li>
<p>浏览器输入域名 <a href="http://arvinhwo.com">arvinhwo.com</a> 进入</p>
</li>
</ul>
<h1 id="站点配置">站点配置</h1>
<blockquote>
<p>使用Typora作为文本编辑器，参见本站文章<a href="../Typora%E6%8A%80%E5%B7%A7">Typora技巧</a></p>
</blockquote>
<h2 id="引用文章">引用文章</h2>
<ul>
<li>在Hexo渲染出的网页中引用已发布的文章，首先修改站点配置文件_config.yml中的permalink</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># URL</span></span><br><span class="line"><span class="comment">## Set your site url here. For example, if you use GitHub Page, set url as &#x27;https://username.github.io/project&#x27;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">http://arvinhwo.com</span></span><br><span class="line"><span class="comment"># permalink: :year/:month/:day/:title/</span></span><br><span class="line"><span class="attr">permalink:</span> <span class="string">:title/</span></span><br></pre></td></tr></table></figure>
<ul>
<li>Typora引用使用<code>[titile](../filename_without.md)</code>的Markdown代码</li>
</ul>
<h2 id="引用图片">引用图片</h2>
<ul>
<li>在blog/source/路径下新建images文件夹，.md文件放入默认位置blog/source/_posts/</li>
<li>将Typora-格式-设置图片根目录设置为source，体现在文章的YAML中即为<code>typora-root-url: ./..</code></li>
<li>将Typora-偏好设置-图片设置如下</li>
</ul>
<img src="/images/image-20250709150435441.png" alt="image-20250709150435441" style="zoom: 33%;" />
<ul>
<li>此后Typora中和Hexo渲染均可正确显示图片</li>
</ul>
<blockquote>
<p>由于Gitee不允许个人使用仓库当作图床使用，也可改用GitHub图床<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，若使用GitHub作为图床同样需要CDN加速</p>
</blockquote>
<ul>
<li>由于不适用和文件同名的文件夹用于存储文件，可以关闭站点配置文件中的<code>post_asset_floder: false</code>，这样在使用<code>hexo new</code>、<code>hexo new draft</code>和<code>hexo p</code>命令时，不再自动生成同名文件夹</li>
</ul>
<h2 id="添加脚注">添加脚注</h2>
<ul>
<li>Hexo无法渲染Typora中的脚注，因此使用插件解决
<ul>
<li>卸载原渲染插件<code>npm un hexo-renderer-marked --save</code></li>
<li>安装GitHub风格渲染插件<code>npm i hexo-renderer-markdown-it --save</code></li>
<li>修改站点配置文件_config.yml</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Markdown-it config</span></span><br><span class="line"><span class="comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="comment"># 渲染设置</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="comment"># 置为true时，html内容保持不变；置为false时，html内容将被转义成普通字符串</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否生成与XHTML完全兼容的标签</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="comment"># 置为true时，每个换行符都被渲染成一个&lt;br&gt;（即Hexo的默认表现）；置为false时，只有空行才会被渲染为&lt;br&gt;（GFM的默认表现）</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别链接并把它渲染成链接</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 是否自动识别印刷格式（意思是把(c)渲染为©这样的）</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># 如果typographer被设置为true，则该选项用于设置将dumb quotes（&quot;&quot;）自动替换为smart quotes</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">&#x27;“”‘’&#x27;</span></span><br><span class="line">  <span class="comment"># 设置所需插件</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-abbr</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-footnote</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-ins</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sub</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-sup</span></span><br><span class="line">  <span class="comment"># 锚点设置</span></span><br><span class="line">  <span class="attr">anchors:</span></span><br><span class="line">    <span class="attr">level:</span> <span class="number">2</span></span><br><span class="line">    <span class="attr">collisionSuffix:</span> <span class="string">&#x27;v&#x27;</span></span><br><span class="line">    <span class="attr">permalink:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">permalinkClass:</span> <span class="string">header-anchor</span></span><br></pre></td></tr></table></figure>
<h2 id="任务列表">任务列表</h2>
<ul>
<li>安装GitHub风格渲染插件<code>npm install hexo-renderer-markdown-it --save</code></li>
<li>安装缺失依赖项<code>npm install markdown-it-task-lists --save</code></li>
<li>编辑站点配置配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">plugins:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">markdown-it-task-lists</span>  <span class="comment"># 启用任务列表插件</span></span><br></pre></td></tr></table></figure>
<h2 id="缩进替换">缩进替换</h2>
<ul>
<li>将<code>tab</code>替换为四个空格，编辑站点配置文件</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">highlight:</span></span><br><span class="line">  <span class="attr">line_number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">auto_detect:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">tab_replace:</span> <span class="string">&#x27;    &#x27;</span> <span class="comment">#将\t替换为指定数量的空格</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hljs:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://zhuanlan.zhihu.com/p/138012354">Blog使用GitHub图床</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>How-To</category>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>yml</tag>
        <tag>sh</tag>
      </tags>
  </entry>
  <entry>
    <title>Eclipse指南</title>
    <url>/Eclipse%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="准备">准备</h1>
<h2 id="JDK安装">JDK安装</h2>
<ul>
<li><a href="https://adoptium.net/zh-CN">JDK</a>（Java Development Kit，Java开发工具包）是Java开发的核心基础，是支持Java程序开发、编译、调试和运行的完整工具集</li>
</ul>
<h2 id="Eclipse安装">Eclipse安装</h2>
<ul>
<li><a href="https://www.eclipse.org/downloads/">Eclipse</a>是一个开源的、用Java语言开发的可扩展IDE（Integrated Development Environment，集成开发工具），利用Eclipse可以方便地进行Java项目的开发</li>
</ul>
<h2 id="Inno-Setup安装">Inno Setup安装</h2>
<ul>
<li><a href="https://jrsoftware.org/isinfo.php">Inno Setup</a>是免费工具，可将JAR、JRE、工具链打包为自解压安装程序或单一EXE，运行时自动解压到临时目录并执行</li>
</ul>
<h1 id="入门">入门</h1>
<h2 id="新建项目">新建项目</h2>
<ul>
<li>点击顶部菜单栏 <code>File</code>-&gt;<code>New</code>-&gt;<code>Java Project</code></li>
<li>填入项目名，可包含数字、字母和下划线</li>
<li>选择JRE（Java运行环境），包含在JDK中</li>
<li>创建模块信息<code>module-info.java</code>，用来管理代码依赖关系</li>
</ul>
<p><img src="/images/image-20250806155331591.png" alt="image-20250806155331591"></p>
<h2 id="新建类">新建类</h2>
<ul>
<li>在左侧项目列表中展开<code>HelloGUI</code>，右键<code>src</code>-&gt;<code>New</code>-&gt;<code>Class</code></li>
<li>同时创建包名<code>first_gui</code>和类名<code>FirstWindow</code>，后续创建的所有类必须放在具体的包中</li>
<li>勾选<code>public static void main(String[] args)</code>，自动在类中生成<code>main</code>方法</li>
</ul>
<p><img src="/images/image-20250806160037458.png" alt="image-20250806160037458"></p>
<h2 id="管理依赖">管理依赖</h2>
<ul>
<li>编辑<code>module-info.jave</code>，声明依赖模块，使得类中能够使用<code>swing</code>组件用于开发</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> hello_gui &#123;</span><br><span class="line">    <span class="keyword">requires</span> java.desktop; <span class="comment">// 允许本模块访问Swing组件所在的模块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="简单窗口">简单窗口</h2>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> first_gui;                                      <span class="comment">// 声明包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.swing.JButton;                             <span class="comment">// 导入Swing中的按键模板（基类）</span></span><br><span class="line"><span class="keyword">import</span> javax.swing.JFrame;                              <span class="comment">// 窗口模板</span></span><br><span class="line"><span class="keyword">import</span> javax.swing.JLabel;                              <span class="comment">// 标签模板</span></span><br><span class="line"><span class="keyword">import</span> java.awt.FlowLayout;                             <span class="comment">// 布局模板</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstWindow</span> <span class="keyword">extends</span> <span class="title class_">JFrame</span> &#123;               <span class="comment">// 定义窗口类，继承JFrame</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">123</span>;   <span class="comment">// 版本号管理，符合Java规范</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FirstWindow</span><span class="params">()</span> &#123;                              <span class="comment">// 构造方法：初始化窗口</span></span><br><span class="line">        setTitle(<span class="string">&quot;First Window&quot;</span>);                       <span class="comment">// 设置窗口标题</span></span><br><span class="line">        setSize(<span class="number">400</span>, <span class="number">300</span>);                              <span class="comment">// 设置窗口宽400ppi，高300ppi）</span></span><br><span class="line">        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); <span class="comment">// 设置关闭规则</span></span><br><span class="line">        setLayout(<span class="keyword">new</span> <span class="title class_">FlowLayout</span>());                    <span class="comment">// 设置布局，零件自动从左到右排列</span></span><br><span class="line"></span><br><span class="line">        <span class="type">JLabel</span> <span class="variable">label</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JLabel</span>(<span class="string">&quot;Hello GUI！&quot;</span>);        <span class="comment">// 实例化标签</span></span><br><span class="line">        add(label);                                      <span class="comment">// 将零件1放到窗口中</span></span><br><span class="line"></span><br><span class="line">        <span class="type">JButton</span> <span class="variable">button</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JButton</span>(<span class="string">&quot;First Button&quot;</span>);    <span class="comment">// 实例化按键</span></span><br><span class="line">        add(button);                                     <span class="comment">// 将零件2放到窗口中</span></span><br><span class="line"></span><br><span class="line">        setVisible(<span class="literal">true</span>);                                <span class="comment">// 显示窗口</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;             <span class="comment">// 程序入口</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">FirstWindow</span>();                               <span class="comment">// 分配内存，执行构造方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="运行程序">运行程序</h2>
<ul>
<li>点击菜单栏绿色<code>Run</code>按键，或编辑区右键<code>Run As</code>-&gt;<code>Java Application</code></li>
</ul>
<p><img src="/images/image-20250806164356813.png" alt="image-20250806164356813"></p>
<h2 id="打包">打包</h2>
<ul>
<li>将Java GUI程序导出为<code>Runnable JAR</code></li>
<li>右键项目-&gt;<code>Export</code>-&gt;搜索并选择<code>Runnable JAR file</code></li>
<li>选择主类入口<code>FirstWindw - hello_gui</code>-&gt;选择保存路径</li>
<li>提取依赖库到JAR中<code>Extract required libraries into generated JAR</code></li>
</ul>
<p><img src="/images/image-20250807161959015.png" alt="image-20250807161959015"></p>
<h1 id="可视化">可视化</h1>
<h2 id="插件安装">插件安装</h2>
<ul>
<li>GUI操作<code>Help</code>-&gt;<code>Ecipse Marketplace</code>，搜索并安装<code>windowbuilder</code></li>
</ul>
<p><img src="/images/image-20250806135754663.png" alt="image-20250806135754663"></p>
<h2 id="操作">操作</h2>
<ul>
<li>GUI操作<code>File</code>-&gt;<code>New</code>-&gt;<code>Project...</code>，找到<code>WindowBuilder</code>-&gt;<code>SWT Designer</code>-&gt;<code>SWT/JFace Java Project</code>，填入项目名即可</li>
</ul>
<p><img src="/images/image-20250806143112247.png" alt="image-20250806143112247"></p>
<ul>
<li>创建后，右键<code>src</code>-&gt;<code>new</code>-&gt;<code>other</code>，找到<code>WindowBuilder</code>-&gt;<code>SWT Designer</code>-&gt;<code>SWT</code>-&gt;<code>Application Window</code>，填入文件名</li>
<li>点击编辑区底部的<code>Design</code>即可进行可视化编程</li>
</ul>
<p><img src="/images/image-20250806165258861.png" alt="image-20250806165258861"></p>
<h1 id="实践">实践</h1>
<ul>
<li><a href="../RISC-V-GCC-GUI">RISC-V GCC GUI</a></li>
</ul>
]]></content>
      <categories>
        <category>How-To</category>
        <category>GUI</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>MIPI框架</title>
    <url>/MIPI%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<h1 id="MIPI概述">MIPI概述</h1>
<h2 id="MIPI简介">MIPI简介</h2>
<ul>
<li>
<p><a href="www.mipi.org">MIPI联盟</a>（Mobile Industry Processor Interface Alliance，移动产业处理器接口联盟）是2003年由ARM、Nokia、意法半导体（ST）、德州仪器（TI）等公司成立的一个联盟</p>
<ul>
<li>成员规模超350家，覆盖芯片厂商、终端品牌、汽车制造商、测试机构</li>
<li>99%的智能手机使用至少3项MIPI标准（CSI-2 + DSI + I3C）</li>
</ul>
</li>
<li>
<p>MIPI协议把移动设备内部的接口如摄像头、显示屏、基带、射频接口等标准化，以减少设计的复杂度、提高设备的性能、同时降低功耗和成本</p>
<ul>
<li>MIPI并非单一接口或协议，而是包含一套协议和标准，以满足各种子系统的要求<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></li>
</ul>
</li>
</ul>
<h2 id="MIPI框架">MIPI框架</h2>
<p>MIPI框架主要包含四个方面的协议</p>
<ul>
<li>多媒体（Multimedia）：面向功能，每种多媒体协议栈通常又由三个层次构成
<ul>
<li>应用层（Application Layer）：直接面向用户的顶层协议</li>
<li>协议层（Protocol/Link Layer）：定义数据包结构、流控、错误校验等逻辑传输机制</li>
<li>物理层（Multimedia-PHY Layer）：负责电气信号传输、时钟同步和物理连接</li>
</ul>
</li>
<li>控制与数据（Control &amp; Data）：功能使能层，构成控制网络，实现子系统协同
<ul>
<li>纵向：提供从控制逻辑到物理层的控制链</li>
<li>横向：串联多媒体、存储、调试等子系统</li>
<li>效能：通过RFFE单线制、I3C多主控等专用优化，降低功耗/面积/延迟</li>
</ul>
</li>
<li>芯片间互联（Chip-to-Chip\IPC, Inter Process Communications）：通过高速、标准化、低延时实现异构芯片（如APU/GPU/Modem）的高效协同，同样分为几个层级
<ul>
<li>物理层：使用更高速率的M-PHY，或抗干扰更强的A-PHY</li>
<li>协议层：UniPro，流控与错误恢复，类比TCP/IP的可靠性机制</li>
<li>接口抽象层：HCI，统一管理UniPro和M-PHY的软件API，配置链路状态、功耗模式</li>
<li>场景化应用协议：如AP-Modem专用低延迟通道LLI等，绕开协议栈开销</li>
</ul>
</li>
<li>调试与追踪（Debug &amp; Trace），提供全流程覆盖的协议支持，并且不干扰功能</li>
</ul>
<img src="/images/image-20250711094554653.png" alt="image-20250711094554653" style="zoom:50%;" />
<blockquote>
<p>GNSS：Global Navigation Satellite System，全球导航卫星系统<br>
Codec：Coder-Decoder，编解码器<br>
FM Radio：Frequency Modulation Radio，调频广播<br>
ETPS：Embedded Test and Programming Support<br>
eTrak：实时调试与数据追踪<br>
Cellular：蜂窝<br>
LNA：Low Noise Amplifier，低噪声放大器<br>
Antenna Tuner：天线调谐器</p>
</blockquote>
<h2 id="MIPI协议">MIPI协议</h2>
<h3 id="多媒体">多媒体</h3>
<img src="/images/image-20250711145624735.png" alt="image-20250711145624735" style="zoom:50%;" />
<ul>
<li>
<p>CSI-2 (Camera Serial Interface 2): 高速摄像头串行接口，主流手机/车载摄像头传输协议</p>
</li>
<li>
<p>D-PHY: 差分串行物理层，CSI-2 和 DSI 常用的低成本物理层</p>
<ul>
<li>最低配置：1对数据线+1对时钟线</li>
<li>使用基于差分信号的NRZ编码</li>
</ul>
</li>
<li>
<p>C-PHY: C表示Clock-less，较D-PHY有更高带宽效率的物理层，常用于 CSI-2 和 DSI</p>
<ul>
<li>无需额外布置时钟线，3线制（Triplet）每通道</li>
<li>使用3-phase符号编码，嵌入时钟信息</li>
</ul>
</li>
<li>
<p>DSI (Display Serial Interface): 高速显示屏串行接口，用于手机/平板等屏幕驱动</p>
</li>
<li>
<p>CSI-3: 新一代摄像头接口，基于MIPI M-PHY或C-PHY，扩展性更强（如车用多摄像头）</p>
</li>
<li>
<p>SLIMbus (Serial Low-power Inter-chip Media Bus): 数字音频数据传输总线</p>
</li>
<li>
<p>SoundWire: 新一代数字音频接口，简化布线，替代SLIMbus</p>
</li>
</ul>
<blockquote>
<p>SLIMbus/SoundWire 是完整协议栈（含应用层+协议层+物理层），物理层非D/C-PHY</p>
</blockquote>
<h3 id="控制与数据">控制与数据</h3>
<img src="/images/image-20250711145606842.png" alt="image-20250711145606842" style="zoom:50%;" />
<ul>
<li>I3C (Improved Inter-Integrated Circuit): 革命性传感器控制总线/改进型I2C，融合I2C/SPI/UART优点，高速、低功耗、多主控，用于陀螺仪/加速度计传感器控制、电源管理</li>
<li>I3C Basic: I3C 的子集，低成本、简化版传感器控制总线</li>
<li>RFFE (RF Front-End Control Interface): 射频前端控制接口，制手机天线开关、功率放大器</li>
<li>SPMI (System Power Management Interface): 处理器与外设间的电源管理通信协议</li>
<li>SSIC (SuperSpeed Inter-Chip): 基于USB 3.0的芯片间高速数据传输协议</li>
</ul>
<blockquote>
<p>I3C 因同时涵盖高效控制与简化调试，横跨 Control &amp; Data 和 Debug &amp; Trace 领域</p>
</blockquote>
<h3 id="芯片间互联">芯片间互联</h3>
<img src="/images/image-20250711150529204.png" alt="image-20250711150529204" style="zoom:50%;" />
<ul>
<li>M-PHY: 高速、可扩展物理层，用于芯片间或板间互连（如UFS存储接口）</li>
<li>UniPro (Unified Protocol): 基于M-PHY的应用层协议，构建通用芯片互连（如UFS）</li>
<li>LLI (Low Latency Interface): 应用处理器与调制解调器间超低延迟通信接口</li>
<li>HCI (HYBRID Command Interface): 管理 UniPro 和 M-PHY 栈的通用接口</li>
<li>DigRF: （已被后续协议替代）早期基带与射频芯片间数字接口</li>
<li>A-PHY (Automotive SerDes PHY): 长距离、高抗扰车规级高速物理层（用于车载摄像头/显示屏互连）</li>
</ul>
<h3 id="控制与调试">控制与调试</h3>
<ul>
<li>SDBI (Serial Debug Bus Interface): 基于I3C的低引脚数调试接口</li>
<li>STP (System Trace Protocol): 跨多核系统的软件跟踪协议</li>
<li>TWP (Trace Wrapper Protocol): 封装不同跟踪源数据的协议</li>
<li>MTB (MIPI Trace Buffer): 低成本片上跟踪缓冲区规范</li>
<li>PTI (Parallel Trace Interface): 替代传统并行调试接口的标准</li>
<li>BIST (Built-In Self Test): 集成自测试框架（如CSI-2 TX/RX测试）</li>
<li>SYS-T (System Trace): 定义时间戳和系统事件格式的框架</li>
<li>NIDnT (Non-Intrusive Debug and Trace): 用于I3C的非侵入式调试规范</li>
</ul>
<h1 id="MIPI-CSI-2">MIPI CSI-2</h1>
<p><img src="/images/image-20250711114740490.png" alt="image-20250711114740490"></p>
<h2 id="协议概述">协议概述<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></h2>
<ul>
<li>
<p>CSI协议旨在为高清摄像头和应用处理器之间提供一个高速的串行接口</p>
</li>
<li>
<p>目前常见的摄像头接口协议有CSI-2、USB3.0、DVP，相比DVP接口和USB3.0接口，CSI-2接口在图像数据的传输性能上拥有明显的优势<br>
<img src="/images/image-20250711152614939.png" alt="image-20250711152614939"></p>
<ul>
<li>
<p>串行传输</p>
<ul>
<li>使用的数据线相对较少，并且CSI-2一般采用双线差分传输 （D-PHY）</li>
<li>噪声同时加载到并行传输的两条差分线可以相互抵消，具有更强的抗干扰能力</li>
</ul>
</li>
<li>
<p>校验编码</p>
<ul>
<li>ECC能够监测2bit以内的数据出错和纠正1bit的数据出错</li>
<li>CRC能够监测多bit的数据出错，使CSI-2接口对数据传输具备更高容错</li>
</ul>
</li>
<li>
<p>功耗与传输速率</p>
<ul>
<li>
<p>CSI-2接口支持高速(HS)与低功耗(LP)两种模式协同工作</p>
</li>
<li>
<p>高速模式下使用 0.2V 低压差分电压，用于传输图像数据，其传输速度范围在</p>
<p>80Mbps 至 1000Mbps</p>
</li>
<li>
<p>低功耗模式下使用 12V 差分电压，用于传输控制命令，最高传输速度为 10Mbps</p>
</li>
<li>
<p>接口在正常工作时，会在一次高速模式传输后插入低功耗模式，两种模式相互切换使得 CSI-2接口同时兼顾了低功耗需求</p>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="总体框架">总体框架</h2>
<p><img src="/images/image-20250711154506468.png" alt="image-20250711154506468"></p>
<ul>
<li>应用层：面向用户，可在应用层中实现对原始图像数据进行高级编码以及处理各种算法</li>
<li>协议层：由以下层级构成
<ul>
<li>像素与字节的组包层：在发送端中，组包层负责将来自应用层的图片像素信息打包成为字节，然后输送至低级协议层中</li>
<li>解包层：在接收端中，解包层将来自低级协议层中的字节解压并还原，然后将数据流传输至接收端应用层</li>
<li>低级协议层：对起始指令SoT和终止指令SoT之间串行数据建立bit级和byte级同步，并将数据传输至下一层，包含对大小端的控制</li>
<li>通道管理层：数据通道的数量可以根据带宽需求进行选择，在发送端，接口将字节分发到一个或多个通道；在接收端，接口从通道中收集字节并将其合并重组，恢复出原始的数据流</li>
</ul>
</li>
<li>物理层：规范了传输媒介，电气特性，I/O电路以及bit级和byte级的同步机制，支持High-Speed模式和Low-Power模式，所有功能最终映射为：
<ul>
<li>模拟电路：差分放大器、压控振荡器VCO、比较器</li>
<li>数字电路：移位寄存器、状态机、FIFO</li>
<li>无源器件：终端电阻、电容（AC耦合）</li>
</ul>
</li>
</ul>
<p><img src="/images/image-20250711171639524.png" alt="image-20250711171639524"></p>
<h2 id="数据包格式">数据包格式</h2>
<ul>
<li>用于CSI-2中D-PHY物理层的数据包可以分为长数据包和短数据包</li>
</ul>
<h3 id="长数据包">长数据包</h3>
<p><img src="/images/image-20250711161101845.png" alt="image-20250711161101845"></p>
<ul>
<li>长数据包格式如上图所示，由三个部分组成
<ul>
<li>32bit数据包头（PH），并由以下部分构成
<ul>
<li>8bit数据标识符号（DI, Data Identifier）：由bit7-6的虚拟通道和bit5-0的数据类型构成</li>
<li>16bit字计数值（WC, Word Count）：统计长数据包的字节数，在有需要的情况表示第几帧或是第几行</li>
<li>8bit VCX+ECC校验位：由bit7-6的虚拟通道扩展位和bit5-0的ECC校验位构成</li>
</ul>
</li>
<li>有效载荷：具有可变字节数量的专用数据</li>
<li>16bit数据包页脚（PF）：即16bit CRC校验位</li>
</ul>
</li>
</ul>
<h3 id="短数据包">短数据包</h3>
<p><img src="/images/image-20250711161111820.png" alt="image-20250711161111820"></p>
<ul>
<li>短数据包结构如上图所示，与长数据包结构相似，不同之处在于
<ul>
<li>短数据包只包含有一个数据包头，数据包填充字段和数据包尾均不存在</li>
</ul>
</li>
</ul>
<h2 id="CCI接口">CCI接口</h2>
<h3 id="多速率模式">多速率模式</h3>
<ul>
<li>CCI，即摄像头控制接口，用于配置发送端口，使用两线接口（时钟线 SCL 和数据线 SDA），并具有半双工，串行的特点，兼容I2C协议，支持多速率模式
<ul>
<li>传统I2C兼容模式（FM, Fast Mode）：400 Kbps
<ul>
<li>开漏输出：只能依赖NMOS主动拉低电平，依赖外部上拉电阻Rp</li>
<li>数据采样点位于SCL高电平中点</li>
</ul>
</li>
<li>增强I2C模式（FM+, Fast Mode）：1 Mbps
<ul>
<li>推挽输出（Push-Pull Output）：由PMOS上拉管 + NMOS下拉管组成互补输出级（Totem Pole，图腾柱），不再依赖Rp</li>
<li>上升速度更快（PMOS导通决定），抗干扰更强（主动驱动低阻），但功耗更高（开关瞬态功耗）</li>
</ul>
</li>
<li>单数据模式（SDR，I3C专用）12.5 Mbps
<ul>
<li>单边沿触发器：SCL上升沿锁存SDA数据</li>
</ul>
</li>
<li>双数据模式（DDR，I3C专用）25 Mbps
<ul>
<li>双边沿触发器：SCL上升沿/下降沿各锁存1 bit</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据结构">数据结构</h3>
<ul>
<li>CCI数据传输协议遵循I2C规范，其读写结构如下图所示</li>
</ul>
<p><img src="/images/image-20250711170045936.png" alt="image-20250711170045936"></p>
<p><img src="/images/image-20250711170100702.png" alt="image-20250711170100702"></p>
<h2 id="CSI-2接口模型">CSI-2接口模型</h2>
<ul>
<li>CSI-2规范定义了发送端和接收端的协议和控制接口CCI，可选择D-PHY或C-PHY物理层作为高速串行数据的传输接口选项</li>
<li>C-PHY和D-PHY在物理连接上存在多处不同，主从机必须使用同一种物理层
<ul>
<li>C-PHY具备更高的传输速率，但只支持CSI-2</li>
<li>D-PHY同时支持CSI-2和DSI，具备更高兼容性</li>
</ul>
</li>
</ul>
<p><img src="/images/image-20250711170601360.png" alt="image-20250711170601360"></p>
<blockquote>
<p>一般情况下，对低于五百万像素的摄像头只需使用两对差分数据线，即两条数据通道</p>
</blockquote>
<h1 id="MIPI-DSI">MIPI DSI</h1>
<ul>
<li>DSI协议栈从框架上来看和CSI类似，并且能够实现摄像头-处理器-屏幕的功能组合</li>
</ul>
<img src="/images/1646035937837020.png" alt="img" style="zoom: 80%;" />
<h2 id="协议概述-v2">协议概述<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></h2>
<p><img src="/images/image-20250711174305103.png" alt="image-20250711174305103"></p>
<ul>
<li>DSI 定义了主机处理器与显示外设之间传输图像和指令的接口协议</li>
<li>它采用了MIPI 联盟已有的 DPI-2、DBI-2 定义的像素格式，和 DCS 定义的命令集标准</li>
</ul>
<blockquote>
<ul>
<li>DPI-2 (Display Pixel Interface 2)
<ul>
<li>显示控制器（Source）到显示面板（Sink）的并行像素流格式协议</li>
<li>用于直连型显示驱动，无需帧缓存，如MCU直接驱动LCD屏</li>
</ul>
</li>
<li>DBI-2 (Display Bus Interface 2)
<ul>
<li>基于显示缓存的命令/数据总线协议，具备两种操作模式
<ul>
<li>Command Mode：发送配置命令，如初始化序列</li>
<li>Video Mode：写入帧缓存数据，像素刷新</li>
</ul>
</li>
<li>面板内置帧存，如手机AMOLED屏</li>
</ul>
</li>
<li>DCS (Display Command Set)
<ul>
<li>显示面板的初始化与控制指令集协议，适用于DBI-2/DSI接口</li>
<li>统一不同面板厂商的驱动代码</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="框架模型">框架模型</h2>
<ul>
<li>DSI的框架与CSI类似，同样分为了应用层、协议层和物理层</li>
</ul>
<p><img src="/images/image-20250711174126995.png" alt="image-20250711174126995"></p>
<h2 id="DCS命令集简介">DCS命令集简介</h2>
<ul>
<li>DCS是用于实现DSI和DBI-2协议的命令集
<ul>
<li>主机处理器通过向显示模块发送命令，可以写入图像数据、配置显示模块工作状态或读取显示状态和数据</li>
<li>在显示端，显示控制器接收并解析命令，根据命令执行相应的操作</li>
</ul>
</li>
<li>DCS命令按照类型可以分短命令和长命令，前者不包含或只包含一个参数，后者包含多个参数</li>
<li>按照功能可分为制造商命令集和用户命令集
<ul>
<li>制造商命令集是一种设备相关的协议，用于为出厂设备写入默认参数，设备配置完成出厂后，该命令集应被禁止，显示设备不再响应此命令集的命令</li>
<li>用户命令集是一种设备无关的协议，用于操作系统的硬件抽象层，下图位常用DCS用户命令集</li>
</ul>
</li>
</ul>
<p><img src="/images/image-20250711174737174.png" alt="image-20250711174737174"></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://github.com/DRubioG/MIPI_Specification#">MIPI Specs</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>陈锐弦.基于FPGA和MIPI CSI-2的双摄像头图像采集系统设计[D].西安电子科技大学,2021. <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p>张豪.基于FPGA的MIPI-DSI发送接口设计与实现[D].华中科技大学,2019. <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>LNotes</category>
        <category>MIPI</category>
      </categories>
  </entry>
  <entry>
    <title>Git指南</title>
    <url>/Git%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="Git简介">Git简介</h1>
<ul>
<li>Git 是分布式版本控制工具，核心价值在于高效管理代码变更、支持离线协作与灵活分支策略</li>
<li>对比集中式系统（如 SVN），安全性更高（本地即备份）且协作更灵活</li>
<li><a href="https://www.runoob.com/git/git-install-setup.html">下载与安装</a></li>
</ul>
<p><img src="/images/0D32F290-80B0-4EA4-9836-CA58E22569B3.jpg" alt="img"></p>
<h1 id="GitHub绑定">GitHub绑定</h1>
<h2 id="SSH密钥"><a href="https://blog.csdn.net/qq_35246620/article/details/54317740">SSH</a>密钥</h2>
<ul>
<li>
<p>输入<code>ssh</code>查看本机是否安装SSH</p>
</li>
<li>
<p>输入<code>ssh-keygen -t rsa -C &quot;任意备注&quot;</code>生成<code>RSA</code>算法公钥和私钥并一直回车直至成功打印公钥指纹</p>
<ul>
<li><code>-C &quot;任意备注&quot;</code>便于在GitHub中更容易区分不同的SSH Key，也可省略</li>
</ul>
</li>
</ul>
<img src="/images/image-20251202113819435.png" alt="image-20251202113819435" style="zoom: 33%;" />
<h2 id="SSH绑定">SSH绑定</h2>
<ul>
<li>输入<code>cat ~/.ssh/id_rsa.pub</code>打印并复制公钥</li>
<li>登录 GitHub → Settings → <strong>SSH and GPG Keys</strong> → New SSH Key</li>
<li>输入<code>ssh -T git@github.com</code>，若打印信息<code>You've successfully authenticated</code>则绑定成功</li>
</ul>
<img src="/images/image-20251202114550549.png" alt="image-20251202114550549" style="zoom: 33%;" />
<h2 id="SSH地址">SSH地址</h2>
<ul>
<li>进入GitHub仓库复制HTTPS协议或SSH协议的下载链接</li>
</ul>
<img src="/images/image-20250709141636991.png" alt="image-20250709141636991" style="zoom: 33%;" />
<h1 id="Git命令操作">Git命令操作</h1>
<h2 id="全局设置">全局设置</h2>
<ul>
<li>
<p>首次提交需添加邮箱信息，后续修改也可使用以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.email <span class="string">&quot;your@email.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;your name&quot;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置在<code>git init</code>新仓库时，创建一个叫<code>main</code>的分支</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global init.defaultBranch main</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>设置默认push行为，推送当前峰值到对应远程同名分支，若分支不存在则报错</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global push.default simple</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>windows平台设置：在提交时，自动将CRLF换行符<code>\r\n</code>为转换为macOS和Linux的LF<code>\n</code>，保持仓库干净</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global core.autocrlf input</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>查看全局设置</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>
<img src="/images/image-20251202142137575.png" alt="image-20251202142137575" style="zoom: 50%;" />
</li>
</ul>
<h2 id="远程仓库">远程仓库</h2>
<h3 id="本地提交">本地提交</h3>
<p><img src="/images/1352126739_7909-1764741697681-1.jpg" alt="img"></p>
<ul>
<li>
<p>在工作区路径初始化<code>git init</code></p>
</li>
<li>
<p>完成编辑后，使用<code>git status</code>查看那些文件有变动<br>
<img src="/images/image-20251203143241648.png" alt="image-20251203143241648" style="zoom:33%;" /></p>
<ul>
<li>若存在无需提交的文件，将其加入工作区的<code>.gitignore</code>文件</li>
</ul>
</li>
<li>
<p>添加文件索引<code>git add .</code></p>
<ul>
<li>再次使用<code>git status</code>确认是否存在无需提交的文件</li>
<li>若有则重置索引区<code>git reset</code>，并将其加入<code>.gitignore</code>后，重新<code>git add .</code></li>
</ul>
</li>
<li>
<p>使用<code>git commit -m &quot;msg of update&quot;</code>将修改提交至Git版本库的默认分支（main/master或其他被选中的分支）</p>
<ul>
<li>此操作会更新版本库目录<code>.git</code>，可使用<code>git log</code>查看提交ID（SHA-1哈希值）和相关信息<br>
<img src="/images/image-20251203143717501.png" alt="image-20251203143717501" style="zoom:33%;" /></li>
</ul>
</li>
<li>
<p>使用<code>git show &gt;&gt; diff.txt</code>可以查看具体的文件变动</p>
</li>
<li>
<p>按照<code>.gitignore</code>规则从版本库中删除指定文件</p>
<ul>
<li>使用<code>git rm -r --cached &lt;file&gt;</code>删除指定文件或文件夹</li>
<li><code>--cached</code>：把文件及其索引从版本库中删除，同时保留本地文件，若不加则本地文件同时删除</li>
<li>重新创建索引<code>git add .</code>，提交更改<code>git commit -m &quot;delete some files from .git&quot;</code></li>
</ul>
</li>
</ul>
<h3 id="远程提交">远程提交</h3>
<ul>
<li>
<p>首次需关联远程仓库<code>git remote add origin git@github.com:username/repo.git</code></p>
<ul>
<li>验证远程仓库<code>git remote -v</code><br>
<img src="/images/image-20251203152327207.png" alt="image-20251203152327207" style="zoom:33%;" /></li>
<li>后续若需更改<code>git remote set-url origin git@github.com:username/repo.git</code>
<ul>
<li>在<code>set-url</code>后使用<code>--fetch</code>或<code>--push</code>可以单独设置拉取或提交地址</li>
</ul>
</li>
</ul>
</li>
<li>
<p>首次提交<code>git push -u origin main</code>，后续提交<code>git push</code></p>
<ul>
<li><code>-u</code>建立本地分支和远程分支的追踪关系（upstream）</li>
<li><code>--force</code>强制覆盖远程内容，适用于提交至GitHub新仓库（一般会自动创建README.md等多余文件），其余推送慎用<br>
<img src="/images/image-20251203151415590.png" alt="image-20251203151415590" style="zoom:33%;" /></li>
</ul>
</li>
<li>
<p>进行远程开发时，先<code>git pull origin main --rebase</code>，本地开发完成后<code>git push</code></p>
<ul>
<li><code>git pull --rebase</code>效果等同于<code>git fetch + git rebase</code></li>
<li>先拉取最新的远程提交，<code>git rebase</code>会把本地提交放到最新的远程提交后面</li>
<li>若不加<code>--rebase</code>则相当于<code>git fetch + git merge</code>，这样会制造多余的merge commit，污染提交历史</li>
</ul>
</li>
</ul>
<h3 id="工作流程">工作流程</h3>
<img src="/images/git-process.png" alt="img" style="zoom:80%;" />
<ul>
<li>
<p>输入<code>git clone git@github.com:username/repo.git</code>，可以直接获取远程仓库到本地仓库<br>
<img src="/images/image-20251203155453030.png" alt="image-20251203155453030" style="zoom:33%;" /></p>
</li>
<li>
<p>在<code>git clone &lt;url&gt;</code>中集成了多步操作</p>
<ul>
<li>本地新建远程仓库目录</li>
<li>初始化仓库：<code>git init</code></li>
<li>添加远程地址：<code>git remote add origin &lt;url&gt;</code></li>
<li>获取远程数据：<code>git fetch origin</code></li>
<li>自动检出默认分支：<code>git checkout main</code></li>
</ul>
</li>
<li>
<p>本地开发完成后，后续操作参考<a href="#%E6%9C%AC%E5%9C%B0%E6%8F%90%E4%BA%A4">本地提交</a>和<a href="#%E8%BF%9C%E7%A8%8B%E6%8F%90%E4%BA%A4">远程提交</a></p>
<ul>
<li>使用<code>git clone</code>下载的仓库，不需要再次关联远程仓库，远程提交时也不需要再次设置分支追踪（upstream）</li>
</ul>
</li>
</ul>
<h2 id="分支管理">分支管理</h2>
<ul>
<li>
<p>检出默认分支：clone时所有分支均会被下载，默认分支一般被命名为main；自动设置默认分支（Branch）为当前工作主线，其他分支隐藏</p>
</li>
<li>
<p>创建新分支并切换到该分支：<code>git checkout -b &lt;branchname&gt;</code></p>
</li>
<li>
<p>查看分支：<code>git branch</code>默认查看本地</p>
<ul>
<li>查看远程<code>-r</code>，查看远程和本地<code>-a</code></li>
</ul>
</li>
<li>
<p>合并分支：<code>git merge &lt;branchname&gt;</code>将其他分支合并到当前分支</p>
</li>
<li>
<p>删除本地分支：<code>git branch &lt;select&gt; &lt;branchname&gt;</code></p>
<ul>
<li>删除本地<code>-d</code>，删除未合并分支<code>-D</code></li>
</ul>
</li>
<li>
<p>删除远程分支<code>git push origin --delete &lt;branchname&gt;</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>How-To</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>sh</tag>
      </tags>
  </entry>
  <entry>
    <title>SV常量变量</title>
    <url>/SV%E5%B8%B8%E9%87%8F%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h1 id="常量">常量</h1>
<h2 id="全局">全局</h2>
<ul>
<li><code>define</code>定义宏常量
<ul>
<li>全局跨文件文本常量替换</li>
</ul>
</li>
</ul>
<h2 id="模块级">模块级</h2>
<ul>
<li><code>parameter</code>定义可重写模块级常量
<ul>
<li>编译时常量，实例化时可被覆盖</li>
<li>支持表达式计算</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> RAM #(</span><br><span class="line">    <span class="keyword">parameter</span> DEPTH = <span class="number">1024</span>,                      <span class="comment">// 简单常量</span></span><br><span class="line">    <span class="keyword">parameter</span> ADDR_WIDTH = <span class="built_in">$clog2</span>(DEPTH),        <span class="comment">// 表达式计算</span></span><br><span class="line">    <span class="keyword">parameter</span> [<span class="number">7</span>:<span class="number">0</span>] INIT_VALUE = <span class="number">8&#x27;hA5</span>           <span class="comment">// 带类型声明</span></span><br><span class="line">) (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [ADDR_WIDTH-<span class="number">1</span>:<span class="number">0</span>] addrs</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">localparam</span> HIGH_BIT = ADDR_WIDTH - <span class="number">1</span>;        <span class="comment">// 派生常量</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化时覆盖参数</span></span><br><span class="line">RAM <span class="variable">#(.DEPTH(2048), .INIT_VALUE(8&#x27;hFF)) ram_inst()</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>localparam</code>定义不可重写模块级常量
<ul>
<li>模块内部专用常量</li>
<li>不能被外部覆盖，常用于派生参数</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> ALU (</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] a, b</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">localparam</span> OP_ADD = <span class="number">2&#x27;b00</span>;            <span class="comment">// 操作码常量</span></span><br><span class="line">    <span class="keyword">localparam</span> OP_SUB = <span class="number">2&#x27;b01</span>;</span><br><span class="line">    <span class="keyword">localparam</span> OP_AND = <span class="number">2&#x27;b10</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">localparam</span> RESULT_WIDTH = <span class="number">9</span>;          <span class="comment">// 内部计算结果位宽</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="块、类级">块、类级</h2>
<ul>
<li><code>const</code>定义运行时可初始化的常量
<ul>
<li>可在类、函数、initial块中使用</li>
<li>需要显示初始化，初始化后不可变</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> MAX_SIZE;     <span class="comment">// 声明</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> size);</span><br><span class="line">        MAX_SIZE = size;    <span class="comment">// 在构造函数中初始化</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">real</span> PI = <span class="number">3</span><span class="variable">.1415926</span>;         <span class="comment">// initial块常量</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">byte</span> START_ADDR = <span class="number">8&#x27;h40</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举常量">枚举常量</h2>
<ul>
<li><code>typedef enum</code>定义枚举常量
<ul>
<li>用于定义状态机、命令码等有限值集合</li>
<li>自动或手动赋值，提高代码可读性</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> <span class="keyword">logic</span> [<span class="number">2</span>:<span class="number">0</span>] &#123;       <span class="comment">// 显式指定底层类型</span></span><br><span class="line">    IDLE  = <span class="number">3&#x27;b001</span>,              <span class="comment">// 手动赋值</span></span><br><span class="line">    START = <span class="number">3&#x27;b010</span>,</span><br><span class="line">    RUN   = <span class="number">3&#x27;b100</span>,</span><br><span class="line">    ERROR = <span class="number">3&#x27;b111</span></span><br><span class="line">&#125; state_t;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;                   <span class="comment">// 自动赋值</span></span><br><span class="line">    RED,    <span class="comment">// 0</span></span><br><span class="line">    GREEN,  <span class="comment">// 1</span></span><br><span class="line">    BLUE    <span class="comment">// 2</span></span><br><span class="line">&#125; color_t;</span><br></pre></td></tr></table></figure>
<h2 id="常量函数">常量函数</h2>
<ul>
<li>用于复杂计算生成常量值</li>
<li>在编译时求值，只能包含常量表达式</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">int</span> clog2(<span class="keyword">input</span> <span class="keyword">int</span> n);</span><br><span class="line">    <span class="keyword">return</span> (n &lt;= <span class="number">1</span>) ? <span class="number">0</span> : <span class="number">1</span> + clog2(n &gt;&gt; <span class="number">1</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">parameter</span> MEM_SIZE = <span class="number">4096</span>;</span><br><span class="line"><span class="keyword">localparam</span> ADDR_W = clog2(MEM_SIZE); <span class="comment">// 计算结果为常量</span></span><br></pre></td></tr></table></figure>
<h1 id="静态变量">静态变量</h1>
<h2 id="声明">声明</h2>
<ul>
<li>隐式静态变量：<code>module</code>、<code>program</code>中的<code>function</code>和<code>task</code>中声明的变量默认是静态的</li>
<li>显示静态变量：使用<code>static</code>关键词显式声明</li>
</ul>
<h2 id="特性">特性</h2>
<ul>
<li>
<p>存储在全局数据区，固定内存位置</p>
</li>
<li>
<p>同一个模块多次实例化时共享静态变量</p>
<ul>
<li>由于使用共享的静态存储区，这也可能导致不用线程之间窜用</li>
</ul>
</li>
<li>
<p>适用场景</p>
<ul>
<li>模块级配置参数</li>
<li>硬件寄存器建模</li>
<li>时序逻辑总是使用静态变量保持状态
<ul>
<li>如跨多个时钟周期保持值的计数器</li>
</ul>
</li>
<li>跨时间控制语句的变量</li>
</ul>
</li>
</ul>
<h2 id="生命周期">生命周期</h2>
<ul>
<li>从仿真开始（时间0）持续到仿真结束</li>
<li>在多次触发的过程块中，只在仿真时间为0时进行一次初始化</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span></span><br><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;  <span class="comment">// 仅仿真开始时初始化为0，声明并非执行语句，后续不再重复初始化</span></span><br><span class="line">    count &lt;= count + <span class="number">1</span>;    <span class="comment">// 每次触发递增</span></span><br><span class="line"><span class="keyword">end</span>                           <span class="comment">// 输出序列：1, 2, 3...（非0,1,2...）</span></span><br><span class="line">   </span><br><span class="line"><span class="comment">// 等效硬件行为，更推荐</span></span><br><span class="line"><span class="keyword">reg</span> [<span class="number">31</span>:<span class="number">0</span>] counter = <span class="number">0</span>;      <span class="comment">// 综合为带初始值的寄存器</span></span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">  counter &lt;= counter + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="自动变量">自动变量</h1>
<h2 id="声明-v2">声明</h2>
<ul>
<li>隐式自动变量：<code>class</code>内部的<code>fucntion</code>、<code>task</code>中声明的变量默认是自动的，<code>initial</code>和<code>always</code>中声明的变量默认也是自动的</li>
<li>显示自动变量：使用<code>automatic</code>关键词显示声明
<ul>
<li>建议在需要动态存储时，显式声明<code>automatic</code>，而非依赖隐式规则，避免混淆</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//program块中显示指定自动存储方式</span></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test();</span><br><span class="line">    <span class="comment">//用检测数据何时被写入存储器任务</span></span><br><span class="line">    <span class="keyword">task</span> wait_for_bus(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr, expect_data,</span><br><span class="line">                      <span class="keyword">output</span> <span class="keyword">logic</span> success);</span><br><span class="line">        <span class="keyword">while</span> (bus_addr !== addr)</span><br><span class="line">            @(bus_addr);</span><br><span class="line">        sucess = (bus_data == expect_data);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<h2 id="特性-v2">特性</h2>
<ul>
<li>存储在栈帧中，动态分配内存</li>
<li>多实例独立，每次调用创建独立副本</li>
<li>适用场景
<ul>
<li>纯计算逻辑中使用自动变量</li>
<li>递归函数必须使用自动变量</li>
<li>不需要保持状态的中间变量</li>
<li>验证环境中的临时对象</li>
</ul>
</li>
</ul>
<h2 id="生命周期-v2">生命周期</h2>
<ul>
<li>仅在作用域激活期间存在</li>
<li>每次进入作用域时重新初始化</li>
<li>作用域结束时销毁</li>
<li><code>initial</code>中的自动变量可能在进程挂起后被回收，根据仿真器调度选项而定</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;                 <span class="comment">// 错误：在always内部隐式声明自动变量</span></span><br><span class="line">    count &lt;= count + <span class="number">1</span>;            <span class="comment">// 永远输出1</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> calculate();</span><br><span class="line">    <span class="keyword">automatic</span> <span class="keyword">int</span> temp = <span class="number">0</span>;      <span class="comment">// 每次调用时初始化为0</span></span><br><span class="line">    temp++;</span><br><span class="line">    <span class="built_in">$display</span>(temp);              <span class="comment">// 总是显示1</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">automatic</span> <span class="keyword">int</span> delay = <span class="number">10</span>;</span><br><span class="line">  #delay;                          <span class="comment">// 挂起delay个时间单位</span></span><br><span class="line">  <span class="comment">// 调度器计划在($time + &amp;delay)时唤醒这个进程</span></span><br><span class="line">  <span class="comment">// 这里&amp;delay为delay的内存位置，而非实际值</span></span><br><span class="line">  <span class="comment">// 如果delay已被回收，仿真器可能无法确定何时唤醒</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="时间值">时间值</h1>
<h2 id="单位与精度">单位与精度</h2>
<ul>
<li>一种方法是使用编译指示语句``timescale`。确保时延有适宜的量程和精度
<ul>
<li>当采用多种``timescale`时，可能会因编译次序导致问题</li>
<li>建议每个文件末尾都以``timescale`结束，将其恢复为公司规定的默认值</li>
</ul>
</li>
<li>另一种方式是使用<code>timeunit</code>和<code>timeprecision</code>声明语句为每个模块指明时间
<ul>
<li>若使用上述语句替代``timescale`，要求把它们放入每个带时延的模块中</li>
</ul>
</li>
</ul>
<h2 id="时间参数">时间参数</h2>
<ul>
<li>控制时间显示格式：<code>$timeformat(四个参数)</code>，主要影响<code>$display</code>、<code>monitor</code>等任务中<code>%t</code>格式符的输出
<ul>
<li>第一个参数：时间单位指数（必填），如-9对应1ns、-12对应1ps</li>
<li>第二个参数：小数点后保留位数（默认0）</li>
<li>第三个参数：时间值后的后缀（默认空字符串）</li>
<li>第四个参数：时间字符串的最小宽度（默认20），自动左侧补空格</li>
</ul>
</li>
<li><code>$time</code>的返回值是根据所在模块的时间精度要求进行舍入的整数，<code>$realtime</code>的返回值则是带小数部分的完整实数
<ul>
<li>在计算时延时也可以使用<code>time t</code>或<code>realtime r</code>定义变量存储数据</li>
<li>如在``timescase 1ns/100ps<code>中，</code>time t = 800ps<code>以1ns存储，</code>realtime r = 800ps`以0.8ns存储</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> timing;</span><br><span class="line">    <span class="keyword">timeunit</span> <span class="number">1</span>ns;</span><br><span class="line">    <span class="keyword">timeprecision</span> <span class="number">1</span>ps;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$timeformat</span>(-<span class="number">9</span>, <span class="number">3</span>, <span class="string">&quot;ns&quot;</span>, <span class="number">8</span>);</span><br><span class="line">        #<span class="number">1</span>     <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//1.000ns</span></span><br><span class="line">        #<span class="number">2</span>ns   <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//3.000ns</span></span><br><span class="line">        #<span class="number">0</span><span class="variable">.1ns</span> <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//3.100ns</span></span><br><span class="line">        #<span class="number">41</span>ps  <span class="built_in">$display</span>(<span class="string">&quot;%t&quot;</span>, <span class="built_in">$realtime</span>); <span class="comment">//3.141ns</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LNotes</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>sv</tag>
      </tags>
  </entry>
  <entry>
    <title>RISC-V编译工具UI</title>
    <url>/RISC-V%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7UI/</url>
    <content><![CDATA[<h1 id="使用说明">使用说明</h1>
<h2 id="安装">安装</h2>
<ul>
<li>选择安装位置，默认安装于<code>C:\Program Files\RiscvCompiler</code></li>
</ul>
<p><img src="/images/image-20250808110732132.png" alt="image-20250808110732132"></p>
<ul>
<li>选择快捷方式存放位置，安装预计用时1分钟</li>
</ul>
<p><img src="/images/image-20250808110911551.png" alt="image-20250808110911551"></p>
<h2 id="使用">使用</h2>
<p><img src="/images/image-20250808111335704.png" alt="image-20250808111335704"></p>
<ul>
<li>指定项目目录：C语言主程序、启动文件、链接脚本</li>
<li>指定主程序文件名（不带文件类型后缀），指定链接脚本</li>
<li>GCC编译文件自动存入指定项目目录</li>
</ul>
<img src="/images/image-20250808110227069.png" alt="image-20250808110227069" style="zoom:80%;" />
<h1 id="PS脚本">PS脚本</h1>
<ul>
<li><a href="https://github.com/xpack-dev-tools/riscv-none-elf-gcc-xpack">riscv-none-elf-gcc-xpack</a> PowerShell编译脚本，是后续GUI开发的功能原型</li>
</ul>
<h2 id="工具链变量">工具链变量</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># TOOLCHAIN</span></span><br><span class="line"><span class="variable">$TOOLCHAIN_DIR</span> = <span class="string">&quot;C:\riscv\xpack-riscv-none-elf-gcc-14.2.0-3\bin&quot;</span></span><br><span class="line"><span class="variable">$RISCV_GCC</span> = <span class="string">&quot;<span class="variable">$TOOLCHAIN_DIR</span>\riscv-none-elf-gcc.exe&quot;</span></span><br><span class="line"><span class="variable">$OBJCOPY</span> = <span class="string">&quot;<span class="variable">$TOOLCHAIN_DIR</span>\riscv-none-elf-objcopy.exe&quot;</span></span><br><span class="line"><span class="variable">$OBJDUMP</span> = <span class="string">&quot;<span class="variable">$TOOLCHAIN_DIR</span>\riscv-none-elf-objdump.exe&quot;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>gcc</code>：RISC-V架构的交叉编译器前端
<ul>
<li>将C/C++源代码编译为RISC-V目标平台的机器码</li>
<li>管理整个编译流程（预处理→编译→汇编→链接）</li>
<li>支持RISC-V RV32/RV64指令集及扩展（如M/C/F/D等）</li>
</ul>
</li>
<li><code>objcopy</code>：目标文件格式转换工具
<ul>
<li>提取/转换ELF文件中的特定段（如从.elf提取.bin固件）</li>
<li>生成可烧录的二进制镜像（如用于Flash编程）</li>
<li>修改文件头信息或段属性</li>
</ul>
</li>
<li><code>objdump</code>：目标文件分析诊断工具
<ul>
<li>反汇编机器码为RISC-V汇编指令</li>
<li>显示ELF文件结构（段头、符号表等）</li>
<li>生成带地址的汇编列表文件</li>
</ul>
</li>
</ul>
<h2 id="文件变量">文件变量</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PROJECT</span></span><br><span class="line"><span class="variable">$PROJECT_DIR</span> = <span class="string">&quot;your_project_path&quot;</span></span><br><span class="line"><span class="variable">$MAIN_CODE</span> = <span class="string">&quot;main_file_name_without_extension&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># SOURCE</span></span><br><span class="line"><span class="variable">$LINKER_SCRIPT</span> = <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\sections.lds&quot;</span></span><br><span class="line"><span class="variable">$SOURCE_FILES</span> = <span class="selector-tag">@</span>(</span><br><span class="line">    <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\start.S&quot;</span>,</span><br><span class="line">    <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\<span class="variable">$MAIN_CODE</span>.c&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># OUTPUT</span></span><br><span class="line"><span class="variable">$MAP_FILE</span> = <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\sys.map&quot;</span></span><br><span class="line"><span class="variable">$ELF_OUTPUT</span> = <span class="string">&quot;<span class="variable">$PROJECT_DIR</span>\<span class="variable">$MAIN_CODE</span>.elf&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="编译选项">编译选项</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># OPTIONS</span></span><br><span class="line"><span class="variable">$CFLAGS</span> = <span class="selector-tag">@</span>(</span><br><span class="line">    <span class="string">&quot;-O3&quot;</span>,                  <span class="comment"># 启用最高级别优化</span></span><br><span class="line">    <span class="string">&quot;-nostdlib&quot;</span>,            <span class="comment"># 禁用标准库链接</span></span><br><span class="line">    <span class="string">&quot;-flto&quot;</span>,                <span class="comment"># 链接时优化</span></span><br><span class="line">    <span class="string">&quot;-ffreestanding&quot;</span>,       <span class="comment"># 独立环境编译</span></span><br><span class="line">    <span class="string">&quot;-ffunction-sections&quot;</span>,  <span class="comment"># 函数分段，配合链接器GC移除未使用函数</span></span><br><span class="line">    <span class="string">&quot;-fdata-sections&quot;</span>,      <span class="comment"># 数据分段，支持链接时移除未用数据</span></span><br><span class="line">    <span class="string">&quot;-fno-builtin&quot;</span>,         <span class="comment"># 禁用内置函数</span></span><br><span class="line">    <span class="string">&quot;--specs=nano.specs&quot;</span>,   <span class="comment"># 轻量库配置</span></span><br><span class="line">    <span class="string">&quot;--specs=nosys.specs&quot;</span>   <span class="comment"># 无系统调用配置</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>性能强化：编译、链接双阶段优化
<ul>
<li><code>-O3</code>+<code>-flto</code></li>
</ul>
</li>
<li>裸机环境适配：确保编译结果不依赖操作系统
<ul>
<li><code>-nostdlib</code>+<code>-ffreestanding</code>+<code>nosys.specs</code></li>
</ul>
</li>
<li>代码尺寸优化：移除未使用代码、数据
<ul>
<li><code>-ffunction-sections</code>+<code>-fdata-sections</code></li>
</ul>
</li>
<li>精简库：减小二进制体积
<ul>
<li><code>nano.specs</code></li>
</ul>
</li>
</ul>
<h2 id="链接选项">链接选项</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$LDFLAGS</span> = <span class="selector-tag">@</span>(</span><br><span class="line">    <span class="string">&quot;-Wl,--build-id=none&quot;</span>,   <span class="comment"># 禁用构建ID，减少二进制体积</span></span><br><span class="line">    <span class="string">&quot;-Wl,-Bstatic&quot;</span>,          <span class="comment"># 强制静态链接</span></span><br><span class="line">    <span class="string">&quot;-Wl,-T,<span class="variable">$LINKER_SCRIPT</span>&quot;</span>, <span class="comment"># 指定链接脚本，自定以内存布局</span></span><br><span class="line">    <span class="string">&quot;-Wl,-Map=<span class="variable">$MAP_FILE</span>&quot;</span>,    <span class="comment"># 生成链接映射，用于调试与内存分析</span></span><br><span class="line">    <span class="string">&quot;-L.&quot;</span>                    <span class="comment"># 添加库搜索路径</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ul>
<li>部署控制：强制静态链接（<code>-Bstatic</code>）和自定义内存布局（<code>-T</code>脚本）确保程序在目标硬件精确运行</li>
</ul>
<h2 id="编译命令">编译命令</h2>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="comment"># COMPILE</span></span><br><span class="line">&amp; <span class="variable">$RISCV_GCC</span> <span class="literal">-march</span>=rv32e <span class="literal">-mabi</span>=ilp32e <span class="variable">$CFLAGS</span> <span class="variable">$LDFLAGS</span> <span class="literal">-o</span> <span class="variable">$ELF_OUTPUT</span> <span class="variable">$SOURCE_FILES</span></span><br><span class="line">&amp; <span class="variable">$OBJDUMP</span> <span class="literal">-S</span> <span class="variable">$ELF_OUTPUT</span> &gt; (<span class="variable">$ELF_OUTPUT</span> <span class="operator">-replace</span> <span class="string">&#x27;\.elf$&#x27;</span>, <span class="string">&#x27;.s&#x27;</span>)</span><br><span class="line">&amp; <span class="variable">$OBJCOPY</span> <span class="literal">-O</span> binary <span class="variable">$ELF_OUTPUT</span> (<span class="variable">$ELF_OUTPUT</span> <span class="operator">-replace</span> <span class="string">&#x27;\.elf$&#x27;</span>, <span class="string">&#x27;.bin&#x27;</span>)</span><br><span class="line">&amp; <span class="variable">$OBJCOPY</span> <span class="literal">-O</span> verilog <span class="literal">--verilog-data-width</span> <span class="number">4</span> <span class="variable">$ELF_OUTPUT</span> (<span class="variable">$ELF_OUTPUT</span> <span class="operator">-replace</span> <span class="string">&#x27;\.elf$&#x27;</span>, <span class="string">&#x27;.hex&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="GUI开发">GUI开发</h1>
<h2 id="工具准备">工具准备</h2>
<ul>
<li><a href="../Eclipse%E6%8C%87%E5%8D%97">Eclipse操作指南</a>
<ul>
<li>Eclipse的安装及入门指南</li>
<li>JDK工具集的安装</li>
<li>Inno Setup打包工具</li>
</ul>
</li>
<li><a href="https://github.com/xpack-dev-tools/riscv-none-elf-gcc-xpack/releases/tag/v14.2.0-3">xpack-riscv-gcc下载</a></li>
</ul>
<h2 id="原型">原型</h2>
<ul>
<li>Eclipse新建Java Project，不勾选<code>Create module-info.java</code></li>
<li>先实现调用本地GCC的GUI原型，再封装GCC及GUI</li>
<li>Java GUI代码开源于我的<a href="https://github.com/arvinhwo/RISC-V-GCC-GUI">GitHub仓库</a>
<ul>
<li>SSH地址：<code>git@github.com:arvinhwo/RISC-V-GCC-GUI.git</code></li>
</ul>
</li>
<li>试运行</li>
</ul>
<p><img src="/images/image-20250807134828543.png" alt="image-20250807134828543"></p>
<h2 id="封装">封装</h2>
<ul>
<li>将RISCV GCC和Java环境封装进安装包，达到开箱即用的目的</li>
</ul>
<h3 id="GCC打包">GCC打包</h3>
<ul>
<li>将编译工具链放入项目根目录并改名<code>toolchain</code>
<ul>
<li>目录结构为<code>riscv_compiler/toolchain/bin/riscv-none-elf-gcc.exe</code></li>
</ul>
</li>
<li>将原型中工具链路径由用户输入改为自动获取</li>
</ul>
<h3 id="JAR打包">JAR打包</h3>
<ul>
<li>打包为<code>Runnable JAR file</code>类型
<ul>
<li>选择主类入口<code>RiscvCompilerGUI - risv_compiler</code></li>
<li>打包依赖项<code>Package required libraries into generated JAR</code></li>
<li>目录结构为<code>riscv_compiler/RiscvCompiler.jar</code></li>
</ul>
</li>
</ul>
<p><img src="/images/image-20250808102045734.png" alt="image-20250808102045734"></p>
<ul>
<li>使用JDK自带的<code>jlink</code>在项目目录中生成精简JRE，使封装后的GUI能在无JDK的环境中运行
<ul>
<li>JDK添加到环境变量后，<code>jlink --module-path jmods --add-modules java.base,java.desktop --output jre</code></li>
<li>目录结构为<code>riscv_compiler/jre/bin/java.exe</code></li>
<li>CMD验证JRE<code>jre\bin\java.exe -jar RiscvCompiler.jar</code></li>
</ul>
</li>
</ul>
<p><img src="/images/image-20250808103451834.png" alt="image-20250808103451834"></p>
<h3 id="EXE打包">EXE打包</h3>
<ul>
<li>在项目目录中新建<code>setup.iss</code>文件，使用Inno Setup打开并编译</li>
</ul>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="section">[Setup]</span></span><br><span class="line"><span class="attr">AppName</span>=RISC-V Compiler Suite</span><br><span class="line"><span class="attr">AppVersion</span>=<span class="number">1.0</span></span><br><span class="line"><span class="attr">DefaultDirName</span>=&#123;pf&#125;\RiscvCompiler</span><br><span class="line"><span class="attr">OutputDir</span>=.\Output</span><br><span class="line"><span class="attr">OutputBaseFilename</span>=RiscvCompiler_Setup</span><br><span class="line"><span class="attr">Compression</span>=lzma2</span><br><span class="line"><span class="attr">SolidCompression</span>=<span class="literal">yes</span></span><br><span class="line"><span class="attr">ArchitecturesAllowed</span>=x64</span><br><span class="line"><span class="attr">ArchitecturesInstallIn64BitMode</span>=x64</span><br><span class="line"></span><br><span class="line"><span class="section">[Files]</span></span><br><span class="line">Source: &quot;.\RiscvCompiler.jar&quot;<span class="comment">; DestDir: &quot;&#123;app&#125;&quot;; Flags: ignoreversion</span></span><br><span class="line">Source: &quot;.\toolchain\*&quot;<span class="comment">; DestDir: &quot;&#123;app&#125;\toolchain&quot;; Flags: ignoreversion recursesubdirs</span></span><br><span class="line">Source: &quot;.\jre\*&quot;<span class="comment">; DestDir: &quot;&#123;app&#125;\jre&quot;; Flags: ignoreversion recursesubdirs</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Icons]</span></span><br><span class="line">Name: &quot;&#123;commondesktop&#125;\RISC-V Compiler&quot;<span class="comment">; Filename: &quot;&#123;app&#125;\RiscvCompiler.bat&quot;; IconFilename: &quot;&#123;app&#125;\compiler_icon.ico&quot;</span></span><br><span class="line">Name: &quot;&#123;commonprograms&#125;\RISC-V Compiler&quot;<span class="comment">; Filename: &quot;&#123;app&#125;\RiscvCompiler.bat&quot;; IconFilename: &quot;&#123;app&#125;\compiler_icon.ico&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Run]</span></span><br><span class="line">Filename: &quot;&#123;app&#125;\RiscvCompiler.bat&quot;<span class="comment">; Description: &quot;启动编译器&quot;; Flags: postinstall nowait skipifsilent</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Code]</span></span><br><span class="line">// 创建强制使用内置JRE的启动脚本</span><br><span class="line">procedure CreateBatchFile<span class="comment">;</span></span><br><span class="line">var</span><br><span class="line">  BatchFile: string<span class="comment">;</span></span><br><span class="line">begin</span><br><span class="line">  BatchFile := ExpandConstant(&#x27;&#123;app&#125;\RiscvCompiler.bat&#x27;)<span class="comment">;</span></span><br><span class="line">  SaveStringToFile(BatchFile,</span><br><span class="line">    &#x27;@echo off&#x27; + <span class="comment">#13#10 +</span></span><br><span class="line">    &#x27;set <span class="attr">APPDIR</span>=%~dp0<span class="string">&#x27; + #13#10 +</span></span><br><span class="line"><span class="string">    &#x27;</span>start <span class="string">&quot;&quot;</span> <span class="string">&quot;%APPDIR%jre\bin\javaw.exe&quot;</span> -jar <span class="string">&quot;%APPDIR%RiscvCompiler.jar&quot;</span><span class="string">&#x27; + #13#10,</span></span><br><span class="line"><span class="string">    False</span></span><br><span class="line"><span class="string">  );</span></span><br><span class="line"><span class="string">end;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">procedure CurStepChanged(CurStep: TSetupStep);</span></span><br><span class="line"><span class="string">begin</span></span><br><span class="line"><span class="string">  if CurStep = ssPostInstall then</span></span><br><span class="line"><span class="string">    CreateBatchFile;</span></span><br><span class="line"><span class="string">end;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Tool-Dev</category>
        <category>RISC-V</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ps1</tag>
        <tag>iss</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS环境配置</title>
    <url>/MacOS%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="环境配置">环境配置</h1>
<h2 id="zprofile">.zprofile</h2>
<ul>
<li><code>.zprofile</code>管理环境：打开GU应用或Terminal时，自动从该文件中加载一次全局环境变量，直至本次进程结束
<ul>
<li>若<code>.zprofile</code>修改，GUI应用需要重启、Terminal重启或<code>source ~/.zprofile</code></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 自定义环境变量</span></span><br><span class="line"><span class="built_in">export</span> NAME=<span class="string">&quot;target_path&quot;</span></span><br><span class="line"><span class="comment"># 系统环境变量</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$BIN_DIR</span>:<span class="variable">$PATH</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改PATH识别顺序并去重</span></span><br><span class="line"><span class="function"><span class="title">prepend_path</span></span>() &#123;</span><br><span class="line">  [ <span class="string">&quot;<span class="variable">$#</span>&quot;</span> -lt 1 ] &amp;&amp; &#123; <span class="built_in">echo</span> <span class="string">&quot;Usage: prepend_path /path/one [/path/two ...]&quot;</span>; <span class="built_in">return</span> 1; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">local</span> paths=<span class="string">&quot;&quot;</span></span><br><span class="line">  <span class="keyword">for</span> <span class="built_in">dir</span> <span class="keyword">in</span> <span class="string">&quot;<span class="variable">$@</span>&quot;</span>; <span class="keyword">do</span></span><br><span class="line">    <span class="keyword">if</span> [ -d <span class="string">&quot;<span class="variable">$dir</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line">      paths=<span class="string">&quot;$paths<span class="variable">$dir</span>:&quot;</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">      <span class="built_in">echo</span> <span class="string">&quot;Warning: directory <span class="variable">$dir</span> does not exist.&quot;</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">  PATH=<span class="string">&quot;<span class="variable">$&#123;paths&#125;</span><span class="variable">$&#123;PATH&#125;</span>&quot;</span></span><br><span class="line">  <span class="built_in">export</span> PATH</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">export</span> PATH=$(<span class="built_in">echo</span> <span class="variable">$PATH</span> | <span class="built_in">tr</span> <span class="string">&#x27;:&#x27;</span> <span class="string">&#x27;\n&#x27;</span> | awk <span class="string">&#x27;!seen[$0]++&#x27;</span> | <span class="built_in">paste</span> -sd <span class="string">&#x27;:&#x27;</span> -)</span><br><span class="line"><span class="comment"># prepend_path path1 path2 ... pathn</span></span><br></pre></td></tr></table></figure>
<h2 id="zshrc">.zshrc</h2>
<ul>
<li><code>.zshrc</code>管理交互：每打开一个Terminal的新标签页都会执行，适合设置命令行工具、提示符、自动激活工具</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 彩色输入</span></span><br><span class="line">alias ls=<span class="string">&#x27;ls -G&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入目录的同时打印，builtin强调shell原始命令，避免递归</span></span><br><span class="line">cd () &#123;</span><br><span class="line">  builtin cd <span class="string">&quot;$@&quot;</span> &amp;&amp; ls</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件删除确认及日志</span></span><br><span class="line">rm () &#123;</span><br><span class="line">  command rm -i <span class="string">&quot;$@&quot;</span></span><br><span class="line">  echo <span class="string">&quot;[$(date)] 删除了文件: $@&quot;</span> &gt;&gt; ~/.rm_log</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数扩展，&#x27;github prj_name&#x27; 可快速进入指定项目，其余同理</span></span><br><span class="line">gt () &#123;</span><br><span class="line">  cd <span class="string">&quot;$HOME/workspace/github/$1&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="包管理">包管理</h1>
<h2 id="Homebrew">Homebrew</h2>
<h3 id="Install">Install</h3>
<ul>
<li>Homebrew是macOS上的包管理器，是用于安装、更新、卸载各种开发工具的和软件的命令行工具</li>
<li>使用官方安装脚本：<code>/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)&quot;</code>
<ul>
<li><code>/bin/bash -c</code>：指定使用Bash shell，从字符串<code>$(...)</code>中读取命令并执行</li>
<li><code>curl -fsSL</code>：从GitHub下载官方安装脚本<code>install.sh</code>
<ul>
<li><code>-f (--fail)</code>：入请求失败，直接返回非零退出码</li>
<li><code>-s (--silent)</code>：静默模式，不显示进度条、连接信息等冗余输出</li>
<li><code>-S (--show-error)</code>：与<code>-s</code>结合使用，当发生错误时显示冗余错误信息</li>
<li><code>-L (--location)</code>：若目标URL有跳转，自动跟进最终地址</li>
</ul>
</li>
</ul>
</li>
<li>在<code>~/.zprofile</code>中设置环境变量：<code>eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;</code>
<ul>
<li><code>eval</code>会自动执行<code>$(...)</code>内的字符串输出：自动将<code>/opt/homebrew/bin</code>中的可执行文件或软链接加入全局变量</li>
<li><code>source ~/.zrofile</code>后，输入<code>brew -v (--version)</code>检查环境变量设置是否成功</li>
</ul>
</li>
</ul>
<h3 id="Info">Info</h3>
<ul>
<li>使用<code>brew info xxx</code>能够查询到软件包的基础信息、安装状态、依赖项、注意事项和统计信息，以已安装的<code>openjdk</code>为例</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">arvin@arvinhwo ~ % brew info openjdk</span><br><span class="line">==&gt; openjdk: stable 25.0.1 (bottled) [keg-only]</span><br><span class="line">Development kit for the Java programming language</span><br><span class="line">https://openjdk.org/</span><br><span class="line">Installed</span><br><span class="line">/opt/homebrew/Cellar/openjdk/25.0.1 (557 files, 389.5MB)</span><br><span class="line">  Poured from bottle using the formulae.brew.sh API on 2025-11-26 at 15:29:20</span><br><span class="line">From: https://github.com/Homebrew/homebrew-core/blob/HEAD/Formula/o/openjdk.rb</span><br><span class="line">License: GPL-2.0-only WITH Classpath-exception-2.0</span><br><span class="line">==&gt; Dependencies</span><br><span class="line">Build: autoconf ✘, pkgconf ✘</span><br><span class="line">Required: freetype ✔, giflib ✔, harfbuzz ✔, jpeg-turbo ✔, libpng ✔, little-cms2 ✔</span><br><span class="line">==&gt; Requirements</span><br><span class="line">Build: Xcode (on macOS) ✘</span><br><span class="line">==&gt; Caveats</span><br><span class="line">For the system Java wrappers to find this JDK, symlink it with</span><br><span class="line">  sudo ln -sfn /opt/homebrew/opt/openjdk/libexec/openjdk.jdk /Library/Java/JavaVirtualMachines/openjdk.jdk</span><br><span class="line"></span><br><span class="line">openjdk is keg-only, which means it was not symlinked into /opt/homebrew,</span><br><span class="line">because macOS provides similar software and installing this software in</span><br><span class="line">parallel can cause all kinds of trouble.</span><br><span class="line"></span><br><span class="line">If you need to have openjdk first in your PATH, run:</span><br><span class="line">  echo &#x27;export PATH=&quot;/opt/homebrew/opt/openjdk/bin:$PATH&quot;&#x27; &gt;&gt; /Users/arvin/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find openjdk you may need to set:</span><br><span class="line">  export CPPFLAGS=&quot;-I/opt/homebrew/opt/openjdk/include&quot;</span><br><span class="line">==&gt; Analytics</span><br><span class="line">install: 79,590 (30 days), 230,715 (90 days), 1,003,295 (365 days)</span><br><span class="line">install-on-request: 34,596 (30 days), 102,135 (90 days), 501,993 (365 days)</span><br><span class="line">build-error: 1,961 (30 days)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>bottled</code>表示该软件包提供了预编译的二进制包，Homebrew默认优先使用
<ul>
<li>使用二进制包无需从源码编译安装，需要满足运行依赖项<code>Required</code></li>
</ul>
</li>
<li><code>keg-only</code>软件包单独存放，安装后不会自动在<code>/opt/homebrew/bin</code>建立全局软链接
<ul>
<li>这可以避免直接覆盖系统自带同名软件、破坏系统依赖，如<code>openjdk</code>，同时若使用Homebrew安装了多版本的<code>keg-only</code>软件包，也可以手动选择使用哪个版本</li>
</ul>
</li>
<li><code>Analytics</code>是Homebrew的匿名统计数据，反映该软件包的流行程度和稳定性</li>
</ul>
<h3 id="update">update</h3>
<ul>
<li>使用<code>brew update</code>拉取最新的软件包列表，会列出可供安装的新软件包和过时的软件包
<ul>
<li>或使用<code>brew outdated</code>查看可升级的软件包</li>
</ul>
</li>
<li>升级所有可升级的软件包<code>brew upgrade</code>，或升级单个软件包<code>brew upgrade xxx</code>
<ul>
<li><code>upgrade</code>命令会自动下载新版Bottle、安装新版本、自动执行<code>cleanup</code>，把旧版本移除</li>
<li>若需要保留旧版本，可以在<code>.zprofile</code>中设置<code>export HOMEBREW_NO_INSTALL_CLEANUP=1</code>关闭自动清除</li>
</ul>
</li>
</ul>
<h2 id="Python3">Python3</h2>
<ul>
<li>
<p>Python3是新一代Python语言和运行环境</p>
<ul>
<li>使用<code>pip3</code>、<code>python3</code>等命令运行</li>
<li><code>pip3</code>是Python3自带的包管理工具（Package Installer for Python）</li>
</ul>
</li>
<li>
<p>使用Homebrew安装Python3：<code>brew install python</code></p>
<ul>
<li>输入<code>brew info python</code>检查是否成功</li>
</ul>
</li>
<li>
<p>从info中得知，Homebrew并未直接将<code>python</code>、<code>pip</code>等无版本号命令加入全局链接</p>
<ul>
<li>在<code>~/.zprofile</code>中将<code>/opt/homebrew/opt/python@3.14/libexec/bin</code>加入环境变量后，即可使用<code>pip</code>、<code>python</code>等命令运行</li>
<li>若同时打开<code>/opt/homebrew/bin/pip3</code>和<code>/opt/homebrew/opt/python@3.14/libexec/bin/pip</code>可以发现内容是相同的</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">#</span><span class="language-bash">!/opt/homebrew/Cellar/python@3.14/3.14.0_1/bin/python3.14</span></span><br><span class="line">import sys</span><br><span class="line">from pip._internal.cli.main import main</span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    if sys.argv[0].endswith(&#x27;.exe&#x27;):</span><br><span class="line">        sys.argv[0] = sys.argv[0][:-4]</span><br><span class="line">    sys.exit(main())</span><br></pre></td></tr></table></figure>
<ul>
<li>若项目需要，可在项目根目录创建虚拟环境：<code>python -m venv myenv</code>
<ul>
<li>虚拟环境能实现在不同项目中使用不同版本的库，避免冲突</li>
<li>手动激活虚拟环境：<code>source myenv/bin/activate</code>；或使用下列<code>dienv</code>工具</li>
</ul>
</li>
</ul>
<h2 id="Direnv">Direnv</h2>
<ul>
<li>Direnv让目录自己管理环境，进出自动生效/撤销，不污染全局Shell</li>
<li>使用Homebrew安装Direnv：<code>brew install direnv</code>
<ul>
<li>输入<code>brew info direnv</code>检查是否成功</li>
</ul>
</li>
<li>配置自动识别：<code>echo 'eval &quot;$(direnv hook zsh)&quot;' &gt;&gt; ~/.zshrc</code>
<ul>
<li>放在<code>.zshrc</code>而非<code>.zprofile</code>是为了在新开的tab也能生效</li>
</ul>
</li>
<li>在项目根目录创建<code>.envrc</code>：<code>echo 'source ./myenv_path/bin/activate' &gt; .envrc</code>
<ul>
<li><code>&gt;&gt;</code>追加写入；<code>&gt;</code>覆盖写入</li>
</ul>
</li>
<li>允许<code>.envrc</code>：<code>dirnev allow</code>，实现每次进入项目目录，虚拟环境自动激活；离开目录，虚拟环境自动退出</li>
</ul>
<h2 id="Git">Git</h2>
<ul>
<li>
<p>Git是一个分布式版本控制系统，用来记录代码历史i、多人协作、管理项目变更</p>
<ul>
<li>使用<code>git</code>命令运行</li>
</ul>
</li>
<li>
<p>使用Homebrew进行安装：<code>brew install git</code></p>
<ul>
<li>输入<code>brew info git</code>检查是否成功</li>
</ul>
</li>
<li>
<p>其余操作与Windows平台中相同，参见文章<a href="../Git%E6%8C%87%E5%8D%97/#GitHub%E4%BB%93%E5%BA%93">Git指南</a></p>
</li>
</ul>
<h2 id="Node-js">Node.js</h2>
<ul>
<li>
<p>Node.js是运行JavaScript的高性能运行环境</p>
<ul>
<li>使用<code>npm</code>命令安装包，<code>npm</code>是Node.js自带的包管理器（Node Package Manager）</li>
</ul>
</li>
<li>
<p>使用Homebrew进行安装：<code>brew install node</code></p>
<ul>
<li>输入<code>brew info node</code>检查是否成功</li>
</ul>
</li>
</ul>
<h3 id="Hexo">Hexo</h3>
<ul>
<li>Hexo是一个快速、轻量的静态博客框架</li>
<li>使用<code>npm</code>命令安装Hexo：<code>npm install -g hexo-cli</code></li>
<li>操作与Windows平台中相同，参见文章<a href="../Hexo%E9%83%A8%E7%BD%B2/#%E7%BD%91%E9%A1%B5%E9%83%A8%E7%BD%B2">Hexo部署</a></li>
</ul>
<h2 id="OpenJDK">OpenJDK</h2>
<ul>
<li>Open Java Development Kit是Java平台的开源实现，包含Java开发和运行的核心组件
<ul>
<li>使用<code>java</code>命令运行</li>
</ul>
</li>
<li>使用Homebrew安装：<code>brew install openjdk</code>
<ul>
<li>也可以使用<code>brew search openjdk</code>搜索可用版本并安装</li>
<li>输入<code>brew info openjdk</code>检查是否成功</li>
</ul>
</li>
<li>OpenJDk是keg-only软件，需要在<code>~/.zprofile</code>中设置环境变量
<ul>
<li><code>source ~/.zrofile</code>后，输入<code>java -version</code>检查环境变量设置是否成功</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=<span class="string">&quot;/opt/homebrew/opt/openjdk&quot;</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="string">&quot;<span class="variable">$JAVA_HOME</span>/bin:<span class="variable">$PATH</span>&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="PlantUML">PlantUML</h2>
<ul>
<li>
<p>PlantUML是一个文字画UML图的工具，内部可以调用Graphviz来排版</p>
<ul>
<li>使用<code>plantuml</code>运行脚本</li>
<li>UML：Unified Modeling Landuage Diagram，统一建模语言图</li>
</ul>
</li>
<li>
<p>使用Homebrew安装：<code>brew install plantuml</code></p>
<ul>
<li>输入<code>brew info plantuml</code>检查是否成功</li>
</ul>
</li>
</ul>
<h3 id="Graphviz">Graphviz</h3>
<ul>
<li>Graphviz是一个图形布局引擎和绘图库，绘图基础工具
<ul>
<li>使用<code>dot</code>命令运行脚本</li>
</ul>
</li>
<li>使用Homebrew安装：<code>brew install graphviz</code>
<ul>
<li>输入<code>brew info graphviz</code>检查是否成功</li>
</ul>
</li>
</ul>
<h2 id="Tcl-Tk">Tcl/Tk</h2>
<ul>
<li>Tlk/Tk是一个跨平台脚本语言和GUI工具包
<ul>
<li>Tcl：Tool Command Language，用于自动化、测试、嵌入式开发，使用<code>tclsh</code>命令运行脚本</li>
<li>Tk：Tcl的图形界面库，可快速创建窗口、按钮、文本框等GUI，使用<code>wish</code>命令运行脚本</li>
</ul>
</li>
<li>使用Homebrew安装：<code>brew install tcl-tk</code>
<ul>
<li>输入<code>brew info tcl-tk</code>检查是否成功</li>
</ul>
</li>
</ul>
<h1 id="快捷键"><a href="https://support.apple.com/zh-cn/102650">快捷键</a></h1>
<h2 id="系统">系统</h2>
<ul>
<li>锁屏：<code>ctrl</code>+<code>command</code>+<code>q</code></li>
<li>结束当前应用进程：<code>command</code>+<code>q</code></li>
<li>卡死时强制退出：<code>command</code>+<code>option</code>+<code>esc</code></li>
<li>显示或隐藏程序坞<code>command</code>+<code>option</code>+<code>d</code></li>
<li>切换应用：<code>command</code> +<code>tab</code>
<ul>
<li>切换上一个应用：<code>command</code>+<code>shift</code>+<code>tab</code></li>
<li>切换同一个应用的窗口：<code>command</code>+<code>num</code></li>
</ul>
</li>
</ul>
<h2 id="窗口">窗口</h2>
<ul>
<li>关闭当前窗口：<code>command</code>+<code>w</code>
<ul>
<li>对应窗口左上角红色圆点，应用转为后台运行，内存不足时自动退出</li>
</ul>
</li>
<li>最小化窗口到程序坞：<code>command</code>+<code>m</code>
<ul>
<li>对应窗口左上角黄色圆点</li>
</ul>
</li>
<li>进入/退出全屏：<code>ctrl</code>+<code>command</code>+<code>F</code>
<ul>
<li>对应窗口左上角绿色圆点</li>
</ul>
</li>
<li>隐藏当前应用所有窗口：<code>command</code>+<code>h</code></li>
</ul>
<h2 id="截图">截图</h2>
<ul>
<li><code>command</code>+<code>shift</code>+<code>3</code>：截取屏幕到文件
<ul>
<li><code>command</code>+<code>shift</code>+<code>control</code>+<code>3</code>：截取屏幕到剪切板</li>
</ul>
</li>
<li><code>command</code>+<code>shift</code>+<code>4</code>：截取指定区域到到文件
<ul>
<li><code>command</code>+<code>shift</code>+<code>control</code>+<code>4</code>：截取指定区域到到剪切板</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>How-To</category>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>sh</tag>
      </tags>
  </entry>
  <entry>
    <title>SV数据类型</title>
    <url>/SV%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="四状态类型">四状态类型</h1>
<h2 id="逻辑类型">逻辑类型</h2>
<ul>
<li>
<p><code>logic</code>：推荐替代<code>wire</code>和<code>reg</code>的类型</p>
<ul>
<li><code>reg</code>：Verilog遗留类型，过程赋值中存储值</li>
<li><code>wire</code>：Verilog遗留类型，连续赋值或端口连接</li>
</ul>
</li>
<li>
<p>可表示四种状态：0、1、X（未知）、Z（高阻）</p>
</li>
<li>
<p>可用于线网连接，也可用于过程赋值，编译器根据上下文自行判断</p>
</li>
<li>
<p>只能有一个驱动，否则编译报错</p>
<ul>
<li>如双向总线<code>inout</code>应该使用线网类型<code>wire</code>或<code>tri</code></li>
</ul>
</li>
</ul>
<h2 id="整数类型">整数类型</h2>
<ul>
<li><code>integer</code>：带符号的四值整数，不指定明确位宽
<ul>
<li>位宽由实现定义，通常是32位</li>
<li>主要用于循环控制、通用计算，不用于硬件建模</li>
</ul>
</li>
<li><code>time t</code>：存储仿真时间值的无符号四值整数，不指定明确位宽
<ul>
<li><code>timeunit 1ns;</code>用于指定仿真中<code>#</code>延迟</li>
<li><code>timeprecision 1ps;</code> 用于指定<code>$time</code>单位</li>
</ul>
</li>
</ul>
<h1 id="双状态类型">双状态类型</h1>
<blockquote>
<p>相比于四值类型，引入双值类型有利于提高仿真器性能并减少内存的使用量</p>
</blockquote>
<h2 id="整数类型-v2">整数类型</h2>
<ul>
<li><code>bit</code>：最常用的二值类型，无符号整数</li>
<li><code>bit [31:0]</code>：32比特无符号整数</li>
<li><code>unsigned int</code>：32比特无符号整数</li>
<li><code>int</code>：32比特有符号整数</li>
<li><code>byte</code> ：8比特有符号整数，范围是 $[-128, 127]$</li>
<li><code>shortint</code>：16比特有符号整数</li>
<li><code>longint</code>：64比特有符号整数</li>
</ul>
<blockquote>
<p>注意：当把双状态变量连接到被测设计输出时，若输出X或Z态会被转换成双状态值而测试代码无法察觉。使用<code>$isunknown</code>操作符，在表达式任意位出现X或Z态时返回1</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">$isunknown</span>(iport) == <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;@%t: 4-state value detected on iport %b&quot;</span>, <span class="built_in">$time</span>, iport);</span><br></pre></td></tr></table></figure>
<h1 id="类型转换">类型转换</h1>
<h2 id="静态转换">静态转换</h2>
<ul>
<li>语法：<code>目标类型'(表达式)</code></li>
<li>强制改变表达式类型，不进行越界检查</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="keyword">int</span>&#x27;(<span class="number">10</span><span class="variable">.0</span> - <span class="number">0</span><span class="variable">.1</span>);           <span class="comment">// 浮点转整型（截断小数）</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] byte_val = <span class="keyword">unsigned</span>&#x27;(-<span class="number">1</span>); <span class="comment">// 有符号转无符号（结果为255）</span></span><br><span class="line"><span class="keyword">void</span>&#x27;(function_call());             <span class="comment">// 忽略函数返回值  </span></span><br></pre></td></tr></table></figure>
<h2 id="动态转换">动态转换</h2>
<ul>
<li>语法：<code>$cast(目标变量, 源表达式)</code></li>
<li>返回值：1表示转换成功，0表示转换失败</li>
<li>应用场景
<ul>
<li>非枚举值赋给枚举变量时需显式检查，避免引入非法值</li>
<li>当父类句柄指向子类对象时，将父类句柄转换为子类句柄</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚举转换</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, BLUE&#125; color_e;    <span class="comment">// RED=0, BLUE=1</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">2</span>;</span><br><span class="line">color_e color;</span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">$cast</span>(color, c)) <span class="built_in">$error</span>(<span class="string">&quot;越界&quot;</span>); <span class="comment">// c=2超出枚举范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类向下转型</span></span><br><span class="line"><span class="keyword">class</span> Parent; <span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">class</span> Child <span class="keyword">extends</span> Parent; <span class="keyword">endclass</span></span><br><span class="line">Parent p = <span class="keyword">new</span> Child();</span><br><span class="line">Child c;</span><br><span class="line"><span class="built_in">$cast</span>(c, p);  <span class="comment">// 合法向下转型</span></span><br></pre></td></tr></table></figure>
<h2 id="隐式转换">隐式转换</h2>
<ul>
<li>由编译器自动完成，无需额外语法
<ul>
<li>不同位宽/符号类型：自动扩展/截断、补零或符号扩展</li>
<li>可能引入风险</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] x_vec = <span class="number">&#x27;b11x0</span>; </span><br><span class="line"><span class="keyword">bit</span> [<span class="number">2</span>:<span class="number">0</span>] b_vec = x_vec; <span class="comment">// 风险：b_vec=&#x27;b010（x被转为0），四值-&gt;二值，可能隐蔽错误</span></span><br></pre></td></tr></table></figure>
<h1 id="特殊类型">特殊类型</h1>
<ul>
<li>浮点数类型
<ul>
<li><code>real</code>：双精度浮点数，等效于IEEE 754标准的64位浮点</li>
<li><code>shortreal</code>：单精度浮点数，32位</li>
</ul>
</li>
<li>空类型
<ul>
<li><code>void</code>声明无返回值的函数或任务</li>
</ul>
</li>
<li>句柄类型
<ul>
<li><code>chandle</code>存储由C/C++通过DPI传递的指针</li>
</ul>
</li>
<li>事件类型
<ul>
<li><code>event</code>用于声明同步时间，无数据，仅作为同步信号标识</li>
<li>通过操作符<code>-&gt;</code>触发事件，<code>@</code>或<code>wait()</code>等待事件</li>
</ul>
</li>
<li>字符串
<ul>
<li>用于存储动态文本字符串，本质是字符队列</li>
</ul>
</li>
</ul>
<h1 id="字符串">字符串</h1>
<h2 id="特性">特性</h2>
<ul>
<li>动态长度：运行时自动调整长度，无需预定义大小</li>
<li>ASCII存储：每个字符以字节形式存储 (ASCII 编码)</li>
<li>空终止符：自动维护结尾的<code>\0</code>字符，与C语言兼容</li>
<li>索引访问：支持<code>str[i]</code>访问字符</li>
<li>支持转移序列：<code>\n</code> <code>\t</code> <code>\\</code> <code>\&quot;</code> <code>\0</code> <code>\xHH</code> (十六进制)</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> msg = <span class="string">&quot;Hello SV!&quot;</span>;         <span class="comment">// 初始化</span></span><br><span class="line"><span class="keyword">string</span> empty_str;                 <span class="comment">// 默认值 &quot;&quot; </span></span><br><span class="line"><span class="keyword">string</span> path = <span class="string">&quot;dir/file.txt&quot;</span>;     <span class="comment">// 路径字符串</span></span><br><span class="line"><span class="keyword">string</span> hex_str = <span class="string">&quot;A\x42C&quot;</span>;        <span class="comment">// 包含十六进制字符 (ABC)</span></span><br></pre></td></tr></table></figure>
<h2 id="内建方法">内建方法</h2>
<h3 id="长度操作">长度操作</h3>
<ul>
<li><code>len()</code>或<code>length()</code>：返回字符串长度</li>
<li><code>putc(int i, byte c)</code>：替换位置<code>i</code>的的字符为<code>c</code>，索引从0开始</li>
<li><code>getc(int i)</code>：获取位置<code>i</code>的字符</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> word = <span class="string">&quot;test&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> length = word<span class="variable">.len</span>();       <span class="comment">// length = 4</span></span><br><span class="line">word<span class="variable">.putc</span>(length-<span class="number">1</span>, &#x27;!&#x27;);      <span class="comment">// 修改为 &quot;tes!&quot;</span></span><br><span class="line"><span class="keyword">byte</span> last_char = word<span class="variable">.getc</span>(<span class="number">3</span>); <span class="comment">// 返回 &#x27;!&#x27; (ASCII 33)</span></span><br></pre></td></tr></table></figure>
<h3 id="大小写转换">大小写转换</h3>
<ul>
<li><code>toupper()</code>：转为全大写</li>
<li><code>tolower()</code>：转为全小写</li>
</ul>
<blockquote>
<p>大写：Uppercase Letter；小写：Lowercase Letter</p>
</blockquote>
<h3 id="子串操作">子串操作</h3>
<ul>
<li><code>substr(int s, int e)</code>：提取子串<code>[s,e]</code></li>
<li><code>delete(int s, int e)</code>：删除子串</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> full = <span class="string">&quot;SystemVerilog&quot;</span>;</span><br><span class="line"><span class="keyword">string</span> sub = full<span class="variable">.substr</span>(<span class="number">6</span>, <span class="number">8</span>);  <span class="comment">// &quot;Ver&quot;</span></span><br></pre></td></tr></table></figure>
<h3 id="比较与搜索">比较与搜索</h3>
<ul>
<li><code>compare(string s)</code>：区分大小写比较，相等时返回0，大于时返回1，小于时返回-1</li>
<li><code>icompare(string s)</code>：不区分大小写比较</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> a = <span class="string">&quot;apple&quot;</span>, b = <span class="string">&quot;Apple&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> cmp1 = a<span class="variable">.compare</span>(b);     <span class="comment">// 非零值 (区分大小写)</span></span><br><span class="line"><span class="keyword">int</span> cmp2 = a<span class="variable">.icompare</span>(b);    <span class="comment">// 0 (不区分大小写)</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>find(string substr)</code>：正向（从左往右）查找字符串位置
<ul>
<li>大小写敏感</li>
<li>返回子串第一次出现的起始索引或-1</li>
<li>用于提取前缀、解析命令</li>
</ul>
</li>
<li><code>rfind(string substr)</code>：反向（从右往左）查找子串位置
<ul>
<li>大小写敏感</li>
<li>返回子串最后一次出现的起始索引或-1</li>
<li>用于提取后缀、处理文件扩展名或路径</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">string</span> s = <span class="string">&quot;apple,orange,apple&quot;</span>;</span><br><span class="line"><span class="keyword">string</span> file_path = <span class="string">&quot;/home/user/report_2023.pdf&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> pos1 = s<span class="variable">.find</span>(<span class="string">&quot;apple&quot;</span>);    <span class="comment">// 返回 0 (第一个&quot;apple&quot;)</span></span><br><span class="line"><span class="keyword">int</span> pos2 = s<span class="variable">.rfind</span>(<span class="string">&quot;apple&quot;</span>);   <span class="comment">// 返回 13 (最后一个&quot;apple&quot;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dot_pos = file_path<span class="variable">.rfind</span>(<span class="string">&quot;.&quot;</span>);      <span class="comment">// 查找最后一个点号的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(dot_pos != -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">string</span> extension = file_path<span class="variable">.substr</span>(dot_pos, file_path<span class="variable">.len</span>()-<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Extension: %s&quot;</span>, extension); <span class="comment">// 输出 &quot;.pdf&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类型转换-v2">类型转换</h3>
<ul>
<li><code>atoi()</code>：字符串-&gt;十进制整数</li>
<li><code>atohex()</code>：字符串-&gt;十六进制整数</li>
<li><code>atobin()</code>：字符串-&gt;二进制整数</li>
<li><code>atoreal()</code>：字符串-&gt;实数</li>
<li><code>hextoa(int i)</code>：十六进制整数-&gt;字符串
<ul>
<li>SV不直接提供<code>itoa()</code>，需先使用<code>$sformatf</code></li>
</ul>
</li>
<li><code>bintoa(int i)</code>：二进制整数-&gt;字符串
<ul>
<li>需先使用<code>$sformatf</code></li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> value = <span class="string">&quot;7F&quot;</span><span class="variable">.atohex</span>();  <span class="comment">// 十六进制转整数 → 127</span></span><br><span class="line"><span class="keyword">real</span> pi = <span class="string">&quot;3.1416&quot;</span><span class="variable">.atoreal</span>(); <span class="comment">// 字符串转实数</span></span><br></pre></td></tr></table></figure>
<h3 id="格式化">格式化</h3>
<ul>
<li><code>$sformatf</code>：格式化字符串生成器
<ul>
<li>优先使用此函数代替拼接</li>
<li>SV不直接提供<code>itoa()</code>，需使用<code>$sformatf</code></li>
<li>尽管大多数仿真支持<code>$psprintf</code>函数，功能也和<code>$sformatf</code>相同，但并不是SV的原生函数</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> data = <span class="number">255</span>;</span><br><span class="line"><span class="keyword">string</span> hex_str = <span class="built_in">$sformatf</span>(<span class="string">&quot;%h&quot;</span>, data);     <span class="comment">// 默认格式 → &quot;ff&quot;</span></span><br><span class="line"><span class="keyword">string</span> hex_fmt = <span class="built_in">$sformatf</span>(<span class="string">&quot;0x%h&quot;</span>, data);    <span class="comment">// 带前缀 → &quot;0xff&quot;</span></span><br><span class="line"><span class="keyword">string</span> hex_auto = <span class="built_in">$sformatf</span>(<span class="string">&quot;%0h&quot;</span>, data);    <span class="comment">// &quot;ff&quot; (推荐)</span></span><br><span class="line"><span class="keyword">string</span> hex_4bit = <span class="built_in">$sformatf</span>(<span class="string">&quot;%4h&quot;</span>, value);   <span class="comment">// &quot;  ff&quot; (空格填充)</span></span><br><span class="line"><span class="keyword">string</span> hex_04bit = <span class="built_in">$sformatf</span>(<span class="string">&quot;%04h&quot;</span>, value); <span class="comment">// &quot;00ff&quot; (零填充)</span></span><br></pre></td></tr></table></figure>
<h1 id="结构体">结构体</h1>
<h2 id="类型重命名">类型重命名</h2>
<ul>
<li><code>typedef</code>语句为现有的数据类型创建新名称（别名）
<ul>
<li>提高代码的可读性、复用性和可维护性</li>
<li>约定俗成：一般所有用户自定义类型都带后缀<code>_t</code></li>
<li><code>typedef</code>定义的类型与原始类型完全等效</li>
</ul>
</li>
<li>定义数组类型的语法：<code>typedef &lt;元素类型&gt; &lt;新类型&gt; [&lt;维度&gt;];</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Verilog风格</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> OPSIZE 8</span></span><br><span class="line"><span class="meta">`<span class="keyword">define</span> OPREG reg [`OPSIZE-1:0]</span></span><br><span class="line">`OPREG op_a, op_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SystemVerilog风格</span></span><br><span class="line"><span class="keyword">parameter</span> OPSIZE = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">reg</span> [OPSIZE-<span class="number">1</span>:<span class="number">0</span>] opreg_t;</span><br><span class="line">opreg_t op_a op_b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义数组类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] byte_array [<span class="number">64</span>];</span><br><span class="line">byte_array buffer;</span><br></pre></td></tr></table></figure>
<h2 id="包">包</h2>
<ul>
<li>可以把<code>parameter</code>和<code>typedef</code>语句放到一个程序包（package）里，使之能被整个设计和测试平台使用
<ul>
<li>包允许在模块、包、程序和接口间共享声明</li>
</ul>
</li>
<li>使用<code>import</code>语句从包里导入符号
<ul>
<li>引用的模块优先使用自己索引路径中的符号，若没有才去包里寻找</li>
<li>使用范围操作符<code>::</code>导入指定的符号</li>
</ul>
</li>
<li>包是完全独立的，可以被放到任何需要的地方
<ul>
<li>包只能看到包内部定义的符号，或者包自己导入的包</li>
<li>不能层次化引用来自包外部的符号</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ABC总线的包</span></span><br><span class="line"><span class="keyword">package</span> ABC;</span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">int</span> abc_data_width = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">logic</span> [abc_data_width-<span class="number">1</span>:<span class="number">0</span>] abc_data_t;</span><br><span class="line">    <span class="keyword">parameter</span> <span class="keyword">time</span> timeout = <span class="number">100</span>ns;</span><br><span class="line">    <span class="keyword">string</span> message = <span class="string">&quot;ABC done&quot;</span>;</span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入包</span></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">    <span class="keyword">import</span> ABC::*;                        <span class="comment">// 导入包中所有符号</span></span><br><span class="line">    </span><br><span class="line">    abc_data_t data;                    <span class="comment">// 来自包ABC的符号</span></span><br><span class="line">    <span class="keyword">string</span> message = <span class="string">&quot;Test timed out&quot;</span>;  <span class="comment">// 本地的message隐藏了包里的message符号</span></span><br><span class="line">    <span class="comment">//若确实需要使用ABC中的messge，则使用ABC::message指定</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="variable">#(timeout)</span>;                     <span class="comment">// 来自包ABC的符号</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Timeout - %s&quot;</span>, message);</span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="创建结构体">创建结构体</h2>
<ul>
<li><code>struct</code>语句把若干变量组合到一个结构中
<ul>
<li>封装数据，便于模块间传递（可综合）</li>
<li>约定俗成：一般用户自定义类型带后缀<code>_s</code></li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;          <span class="comment">// 8位红、绿、蓝通道</span></span><br><span class="line">&#125; pixel_s;                      <span class="comment">// 定义结构体类型 pixel_s</span></span><br><span class="line"></span><br><span class="line">pixel_s my_pixel;               <span class="comment">// 声明变量</span></span><br><span class="line">my_pixel = &#x27;&#123;<span class="number">&#x27;h10</span>, <span class="number">&#x27;h20</span>, <span class="number">&#x27;h30</span>&#125;; <span class="comment">// 结构体赋值</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>packed</code>关键字将结构体中的数据合并到尽可能小的空间中
<ul>
<li>若需经常对整个结构体进行复制，使用合并结构效率更高</li>
<li>若需经常对结构内的个体进行操作，使用非合并结构效率更高</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 上例中的pixel_s占用了三个长字的存储空间，即使实际只需三个字节</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;         <span class="comment">// 使用packed进行压缩</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] r, g, b;          <span class="comment">// 8位红、绿、蓝通道</span></span><br><span class="line">&#125; pixel_s_p;</span><br></pre></td></tr></table></figure>
<h2 id="流操作符">流操作符</h2>
<ul>
<li>流操作符用于数据打包和解包，简化数据的序列化操作
<ul>
<li><code>&gt;&gt;</code>（从左至右打包或解包）：将数据打包成比特流，或从比特流中解包提取数据</li>
<li><code>&lt;&lt;</code>（从右至左打包或解包）：反序打包数据，或反序解包比特流</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打包（Pack）：将多个变量组合成比特流，如总线数据传输</span></span><br><span class="line">type_packed = &#123; &gt;&gt; &#123;var1, var2, ...&#125; &#125;;  <span class="comment">// 从左至右打包</span></span><br><span class="line">type_packed = &#123; &lt;&lt; &#123;var1, var2, ...&#125; &#125;;  <span class="comment">// 从右至左打包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解包（Unpack）：从比特流中提取数据，如DUT输出数据的解析</span></span><br><span class="line">&#123; &gt;&gt; &#123;var1, var2, ...&#125; &#125; = type_packed;  <span class="comment">// 从左至右解包</span></span><br><span class="line">&#123; &lt;&lt; &#123;var1, var2, ...&#125; &#125; = type_packed;  <span class="comment">// 从右至左解包</span></span><br></pre></td></tr></table></figure>
<ul>
<li>支持数据结构，使用与结构体、数组等复杂类型</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">  <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; packet_t;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 打包：将结构体打包成比特流</span></span><br><span class="line">packet_t tx_packet;</span><br><span class="line"><span class="keyword">logic</span> [<span class="number">39</span>:<span class="number">0</span>] packed_stream; <span class="comment">// 总宽度：8-bit + 32-bit = 40-bit</span></span><br><span class="line">tx_packet<span class="variable">.addr</span> = <span class="number">8&#x27;hA5</span>;</span><br><span class="line">tx_packet<span class="variable">.data</span> = <span class="number">32&#x27;h1234_5678</span>;</span><br><span class="line">packed_stream = &#123; &gt;&gt; &#123;tx_packet<span class="variable">.addr</span>, tx_packet<span class="variable">.data</span>&#125; &#125;;</span><br><span class="line"><span class="comment">// 从左至右打包：addr在前，data在后</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解包：从比特流中提取数据</span></span><br><span class="line">packet_t rx_packet;</span><br><span class="line">&#123; &gt;&gt; &#123;rx_packet<span class="variable">.addr</span>, rx_packet<span class="variable">.data</span>&#125; &#125; = packed_stream;</span><br><span class="line"><span class="comment">// 解包后：rx_packet.addr = 8&#x27;hA5, rx_packet.data = 32&#x27;h1234_5678</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可指定片段宽度，再将数据按照指定宽度分段后再打包或解包</li>
<li>比特流结果不能直接赋值给<a href="../SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97">非合并数组</a>
<ul>
<li>这是因为非合并数组相邻元素间可能存在间隙，如定宽数组使用字边界</li>
<li>需在赋值表达式的左边使用流操作符把比特流拆分到非合并数组中</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] stream = <span class="number">32&#x27;hA5A5_A5A5</span>;</span><br><span class="line"><span class="keyword">int</span> arr [<span class="number">0</span>:<span class="number">3</span>]; <span class="comment">// 非合并数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接赋值违反语言规则</span></span><br><span class="line">arr = stream; <span class="comment">// 编译报错</span></span><br><span class="line"><span class="comment">// 正确：左侧流操作符拆分比特流</span></span><br><span class="line">&#123; &gt;&gt; &#123;arr&#125; &#125; = stream;      <span class="comment">// 等价于按32比特分段，未被赋值的部分自动填充默认值0</span></span><br><span class="line">&#123; &gt;&gt; <span class="keyword">byte</span> &#123;arr&#125; &#125; = stream; <span class="comment">// 按照指定片段宽度解包</span></span><br></pre></td></tr></table></figure>
<h1 id="枚举类型">枚举类型</h1>
<h2 id="定义与特性">定义与特性</h2>
<ul>
<li>
<p>定义</p>
<ul>
<li>枚举类型<code>enum</code>定义一组命名常量集合</li>
<li>增强可读性和安全性，避免手动赋值繁琐易出错</li>
</ul>
</li>
<li>
<p>特性</p>
<ul>
<li>
<p>默认首标签为0，后续标签自动递增</p>
<ul>
<li>也可以显式指定任意数值，未赋值的标签继承上一个标签值+1</li>
</ul>
</li>
<li>
<p>默认基类为<code>int</code>，支持自定义基类，需显式声明宽度</p>
<ul>
<li>例如<code>enum bit {TRUE=1, FALSE=0} Boolean;</code></li>
</ul>
</li>
<li>
<p>标签值在同一枚举类型中必须唯一</p>
</li>
<li>
<p>标签名在同一模块中必须唯一，并且不能以数字开头</p>
</li>
<li>
<p>支持范围语法批量生成标签</p>
</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123;RED, YELLOW, GREEN&#125; light;  <span class="comment">// 默认标签：RED=0, YELLOW=1, GREEN=2</span></span><br><span class="line"><span class="keyword">enum</span> &#123;R, Y, G&#125; color;             <span class="comment">// 默认标签：R=0, Y=1, G=2</span></span><br><span class="line"><span class="comment">//标签值重复：虽然RED和R默认都为0，但属于两个不同的枚举类型，相互独立并不冲突</span></span><br><span class="line"><span class="comment">//也可使用显示赋值，避免打印时混淆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//标签名称重复：同一模块内不同枚举类型的标签名称重复会导致编译错误，哪怕值不同</span></span><br><span class="line"><span class="keyword">enum</span> &#123;R = <span class="number">10</span>, Y, G&#125; color_e;      <span class="comment">// 默认标签：R=10, Y=11, G=12</span></span><br><span class="line"><span class="comment">//应对方法：使用唯一的标签名；在不同的模块中使用</span></span><br><span class="line"><span class="comment">//或使用typedef定义枚举类型，为每个枚举类型创建独立类型，减少名称污染风险</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;RESET, S[<span class="number">5</span>], W[<span class="number">6</span>:<span class="number">9</span>]&#125; state; <span class="comment">// 生成 RESET, S0-S4, W6-W9</span></span><br></pre></td></tr></table></figure>
<h2 id="自定义枚举类型">自定义枚举类型</h2>
<ul>
<li>使用<code>typedef</code>定义可复用的枚举类型
<ul>
<li>支持包导入，需显式导入包<code>import ABC::*;</code>，<code>*</code>也可以是指定的枚举类型</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;INIT, DECODE, IDLE&#125; fsm_state_e; <span class="comment">//使用后缀_e表示枚举类型</span></span><br><span class="line">fsm_state_e st, nst;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">case</span> (st)</span><br><span class="line">        IDLE: nst = INIT;</span><br><span class="line">        INIT: nst = DECODE;</span><br><span class="line">        <span class="keyword">default</span>: nst = IDLE;</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Next state is %s&quot;</span>, nst<span class="variable">.name</span>());</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="枚举类型子程序">枚举类型子程序</h2>
<ul>
<li><code>first()</code>或<code>first</code>返回第一个枚举常量</li>
<li><code>last()</code>返回最后一个枚举常量</li>
<li><code>next()</code>返回下一个枚举常量</li>
<li><code>next(N)</code>返回第N个枚举常量</li>
<li><code>prev()</code>返回前一个枚举常量</li>
<li><code>prev(N)</code>返回前第N个枚举常量</li>
</ul>
<blockquote>
<p>当到达枚举常量列表的头或尾时，函数<code>next</code>和<code>prev</code>会自动以环形方式绕回</p>
</blockquote>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//遍历所有枚举成员</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;RED, BLUE, GREEN&#125; color_e;</span><br><span class="line">color_e color;</span><br><span class="line">color = color<span class="variable">.first</span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Color = %0d/%s&quot;</span>, color, color<span class="variable">.name</span>());</span><br><span class="line">        color = color<span class="variable">.next</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">while</span> (color != color<span class="variable">.first</span>)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LNotes</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>sv</tag>
      </tags>
  </entry>
  <entry>
    <title>LFSR原理</title>
    <url>/LFSR%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="定义">定义</h1>
<ul>
<li>线性反馈移位寄存器（Linear Feedback Shift Register，LFSR），其运算是确定的，所以，由寄存器所生成的数据流完全决定于寄存器当时或者之前的状态
<ul>
<li>种子：赋给 LFSR 的初始值</li>
<li>抽头：影响 LFSR 下一个状态的比特位</li>
</ul>
</li>
</ul>
<p>$$<br>
f(x) = g_n x^n + g_{n-1} x^{n-1} + \cdots + g_1 x + 1<br>
$$</p>
<ul>
<li>本源多项式：决定了线性移位寄存器的反馈结构
<ul>
<li>反馈系数 g_i 可以为0或1，但g_n和g_0只能为1</li>
<li>因为当 g_i 为0时表示不存在该反馈路径</li>
</ul>
</li>
<li>逻辑运算：异或、同或
<ul>
<li>使用异或门的 LFSR 全<code>0</code>状态下为无效状态</li>
<li>使用同或门的 LFSR 全<code>1</code>状态下为无效状态</li>
<li>不管是异或还是同或，都需避免选择全<code>0</code>或全<code>1</code>的种子，避免 LFSR 进入死循环</li>
</ul>
</li>
<li>抽头序列：选取的某些位构成的序列
<ul>
<li>不同的抽头序列对应不同的本源多项式，产生不同的反馈路径</li>
<li>抽头的位置会影响LSFR的输出状态的最大长度序列（Maximum Length Sequence, MLS）
<ul>
<li>一个n bits的LFSR最多能输出$2^n-1$种状态</li>
<li>能使LFSR拥有MLS的抽头序列不唯一</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/images/d404df040093a43db7ce434e675b1fef.png" alt="img"></p>
<h1 id="分类">分类</h1>
<h2 id="外部型">外部型</h2>
<ul>
<li>Fibonacci LFSR：斐波那契（外部 LFSR），又称 many-to-one</li>
</ul>
<p><img src="/images/72ed10554a9bb553e9f70c6dc25bd607.jpeg" alt="img"></p>
<ul>
<li>下例是一个本源多项式为$f(x) = x^{16} + x^{14} + x^{13} + x^{11} + 1$的 Fibonacci LFSR
<ul>
<li>抽头序列是 <code>[16,14,13,11]</code></li>
<li>抽头依次与输出比特进行异或运算，然后反馈回最左端的位</li>
<li>LFSR 最右端的比特为输出比特，当前状态为<code>0x8735</code> ，下一个状态是<code>0x0E6A</code></li>
</ul>
</li>
</ul>
<p><img src="/images/LFSR-F16.gif" alt="img"></p>
<h2 id="内部型">内部型</h2>
<ul>
<li>Galois LFSR：伽罗瓦（内部LFSR），又称one-to-many</li>
</ul>
<p><img src="/images/8890b6add5570033b9bfe7a58502d40e.jpeg" alt="img"></p>
<ul>
<li>下例是一个本源多项式为$f(x) = x^3 + x^2 + 1$的 Galois LFSR
<ul>
<li>抽头序列为<code>[3，2]</code></li>
</ul>
</li>
</ul>
<img src="/images/0f083c2a50c9f10a25041923d8755d0e.png" alt="Image 1" style="zoom:50%;" />
<ul>
<li>这个3位的LFSR的伪功能代码可以用C描述为</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">lfsr3</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> temp0, temp1, temp2;</span><br><span class="line">    temp0 = ff0; </span><br><span class="line">    temp1 = ff1; </span><br><span class="line">    temp2 = ff2; </span><br><span class="line">    ff0 = temp2;</span><br><span class="line">    ff1 = temp0 ^ (<span class="number">0</span> * temp2);</span><br><span class="line">    ff2 = temp1 ^ (<span class="number">1</span> * temp2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>从上述代码的状态转移图中可以发现7个状态组成一个循环，这也是3为LFSR所能达到的最多状态</li>
</ul>
<img src="/images/3938a2752887e8627ad11e36e1033478.png" alt="Image 2" style="zoom:50%;" />
<h1 id="实例">实例</h1>
<ul>
<li>抽头序列为<code>[3,2]</code>的3级Fibonacci LFSR</li>
</ul>
<img src="/images/c7eb25dcea5e4ad6a000681a9db6b90a.png" alt="img" style="zoom: 150%;" />
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR3_D(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">2</span>:<span class="number">0</span>] LFSR = <span class="number">1</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">1</span>] ^ LFSR[<span class="number">2</span>];</span><br><span class="line">        LFSR[<span class="number">2</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">1</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> <span class="number">100</span>   <span class="comment">// 种子为1</span></span><br><span class="line"><span class="number">1</span> <span class="number">010</span>   <span class="comment">// 2</span></span><br><span class="line"><span class="number">2</span> <span class="number">101</span>   <span class="comment">// 5</span></span><br><span class="line"><span class="number">3</span> <span class="number">110</span>   <span class="comment">// 3</span></span><br><span class="line"><span class="number">4</span> <span class="number">111</span>   <span class="comment">// 7</span></span><br><span class="line"><span class="number">5</span> <span class="number">011</span>   <span class="comment">// 6</span></span><br><span class="line"><span class="number">6</span> <span class="number">001</span>   <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抽头序列为<code>[4，2]</code>的4级Fibonacci LFSR</li>
</ul>
<img src="/images/3a130ac32df24e40945909900fc4a463.png" alt="Image 2" style="zoom:150%;" />
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR4_15(</span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] LFSR = <span class="number">15</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">1</span>] ^ LFSR[<span class="number">3</span>];</span><br><span class="line">        LFSR[<span class="number">3</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fibonacci_LFSR4_15</span></span><br><span class="line"><span class="comment">// status hex sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> F <span class="number">1111</span></span><br><span class="line"><span class="number">1</span> E <span class="number">0111</span></span><br><span class="line"><span class="number">2</span> C <span class="number">0011</span></span><br><span class="line"><span class="number">3</span> <span class="number">9</span> <span class="number">1001</span></span><br><span class="line"><span class="number">4</span> <span class="number">3</span> <span class="number">1100</span></span><br><span class="line"><span class="number">5</span> <span class="number">7</span> <span class="number">1110</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>抽头序列为<code>[4，1]</code>的4级Fibonacci LFSR</li>
</ul>
<img src="/images/e8f427dc46d94eaf8e9d2365f8b93996.png" alt="Image 1" style="zoom:150%;" />
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR4_13(</span><br><span class="line"><span class="keyword">input</span> clk,</span><br><span class="line"><span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">3</span>:<span class="number">0</span>] LFSR = <span class="number">15</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">0</span>] ^ LFSR[<span class="number">3</span>];</span><br><span class="line">        LFSR[<span class="number">3</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">2</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fibonacci_LFSR4_13</span></span><br><span class="line"><span class="comment">// status hex sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> F <span class="number">1111</span></span><br><span class="line"><span class="number">1</span> E <span class="number">0111</span></span><br><span class="line"><span class="number">2</span> D <span class="number">1011</span></span><br><span class="line"><span class="number">3</span> A <span class="number">0101</span></span><br><span class="line"><span class="number">4</span> <span class="number">5</span> <span class="number">1010</span></span><br><span class="line"><span class="number">5</span> B <span class="number">1101</span></span><br><span class="line"><span class="number">6</span> <span class="number">6</span> <span class="number">0110</span></span><br><span class="line"><span class="number">7</span> C <span class="number">0011</span></span><br><span class="line"><span class="number">8</span> <span class="number">9</span> <span class="number">1001</span></span><br><span class="line"><span class="number">9</span> <span class="number">2</span> <span class="number">0100</span></span><br><span class="line"><span class="number">10</span> <span class="number">4</span> <span class="number">0010</span></span><br><span class="line"><span class="number">11</span> <span class="number">8</span> <span class="number">0001</span></span><br><span class="line"><span class="number">12</span> <span class="number">1</span> <span class="number">1000</span></span><br><span class="line"><span class="number">13</span> <span class="number">3</span> <span class="number">1100</span></span><br><span class="line"><span class="number">14</span> <span class="number">7</span> <span class="number">1110</span></span><br></pre></td></tr></table></figure>
<ul>
<li>抽头序列为<code>[16,14,13,11]</code>的16级Fibonacci LFSR</li>
</ul>
<p><img src="/images/d6037e33c5464a3882290ec9fda84c70.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR16_16801(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] LFSR = <span class="number">34613</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">10</span>] ^ LFSR[<span class="number">12</span>] ^ LFSR[<span class="number">13</span>] ^ LFSR[<span class="number">15</span>];</span><br><span class="line">        LFSR[<span class="number">15</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">14</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//status hex sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> <span class="number">8735</span> <span class="number">1010110011100001</span></span><br><span class="line"><span class="number">1</span> <span class="number">0</span>E6A <span class="number">0101011001110000</span></span><br><span class="line"><span class="number">2</span> <span class="number">1</span>CD5 <span class="number">1010101100111000</span></span><br><span class="line"><span class="number">3</span> <span class="number">39</span>AA <span class="number">0101010110011100</span></span><br><span class="line"><span class="number">4</span> <span class="number">7354</span> <span class="number">0010101011001110</span></span><br><span class="line"><span class="number">5</span> E6A8 <span class="number">0001010101100111</span></span><br><span class="line"><span class="number">6</span> CD51 <span class="number">1000101010110011</span></span><br><span class="line"><span class="number">7</span> <span class="number">9</span>AA2 <span class="number">0100010101011001</span></span><br><span class="line"><span class="number">8</span> <span class="number">3544</span> <span class="number">0010001010101100</span></span><br><span class="line"><span class="number">9</span> <span class="number">6</span>A89 <span class="number">1001000101010110</span></span><br><span class="line"><span class="number">10</span> D513 <span class="number">1100100010101011</span></span><br><span class="line"><span class="number">11</span> AA27 <span class="number">1110010001010101</span></span><br><span class="line"><span class="number">12</span> <span class="number">544</span>E <span class="number">0111001000101010</span></span><br><span class="line"><span class="number">13</span> A89C <span class="number">0011100100010101</span></span><br><span class="line"><span class="number">14</span> <span class="number">5138</span> <span class="number">0001110010001010</span></span><br><span class="line"><span class="number">15</span> A271 <span class="number">1000111001000101</span></span><br><span class="line"><span class="number">16</span> <span class="number">44</span>E2 <span class="number">0100011100100010</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>若需要将全0状态加入上述LFSR的循环中</li>
</ul>
<p><img src="/images/5a8ad698bb944c7fa539b4d2ebd0bc19.png" alt="img"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> Fibonacci_LFSR16_16801_0(</span><br><span class="line">    <span class="keyword">input</span> clk,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">reg</span> [<span class="number">15</span>:<span class="number">0</span>] LFSR = <span class="number">0</span></span><br><span class="line">);</span><br><span class="line"><span class="keyword">always</span> @(<span class="keyword">posedge</span> clk)</span><br><span class="line">    <span class="keyword">begin</span></span><br><span class="line">        LFSR[<span class="number">0</span>] &lt;= LFSR[<span class="number">10</span>] ^ LFSR[<span class="number">12</span>] ^ LFSR[<span class="number">13</span>] ^ LFSR[<span class="number">15</span>] ^ (LFSR[<span class="number">14</span>:<span class="number">0</span>]==<span class="number">15&#x27;b000000000000000</span>);</span><br><span class="line">        LFSR[<span class="number">15</span>:<span class="number">1</span>] &lt;= LFSR[<span class="number">14</span>:<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//status hex sequence(LSB-&gt;MSB)</span></span><br><span class="line"><span class="number">0</span> <span class="number">0000</span> <span class="number">0000000000000000</span></span><br><span class="line"><span class="number">1</span> <span class="number">0001</span> <span class="number">1000000000000000</span></span><br><span class="line"><span class="number">2</span> <span class="number">0002</span> <span class="number">0100000000000000</span></span><br><span class="line"><span class="number">3</span> <span class="number">0004</span> <span class="number">0010000000000000</span></span><br><span class="line"><span class="number">4</span> <span class="number">0008</span> <span class="number">0001000000000000</span></span><br><span class="line"><span class="number">5</span> <span class="number">0010</span> <span class="number">0000100000000000</span></span><br><span class="line"><span class="number">6</span> <span class="number">0020</span> <span class="number">0000010000000000</span></span><br><span class="line"><span class="number">7</span> <span class="number">0040</span> <span class="number">0000001000000000</span></span><br><span class="line"><span class="number">8</span> <span class="number">0080</span> <span class="number">0000000100000000</span></span><br><span class="line"><span class="number">9</span> <span class="number">0100</span> <span class="number">0000000010000000</span></span><br><span class="line"><span class="number">10</span> <span class="number">0200</span> <span class="number">0000000001000000</span></span><br><span class="line"><span class="number">11</span> <span class="number">0400</span> <span class="number">0000000000100000</span></span><br><span class="line"><span class="number">12</span> <span class="number">0801</span> <span class="number">1000000000010000</span></span><br><span class="line"><span class="number">13</span> <span class="number">1002</span> <span class="number">0100000000001000</span></span><br><span class="line"><span class="number">14</span> <span class="number">2005</span> <span class="number">1010000000000100</span></span><br><span class="line"><span class="number">15</span> <span class="number">400</span>B <span class="number">1101000000000010</span></span><br><span class="line"><span class="number">16</span> <span class="number">8016</span> <span class="number">0110100000000001</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="应用">应用</h1>
<ul>
<li>伪随机数生成
<ul>
<li>LFSR只能产生伪随机，是伪随机数生成器（Pseudo Random Number Generator，PRNG）的一种实现方案，在实际应用中，可以使用一些分立器件如D触发器构造LFSR</li>
<li>虽然在反馈路径确定后，LFSR的输出状态序列也是确定的，且最终会实现循环，但随着n的增大，任意时刻的输出状态的随机性也会随之增大</li>
</ul>
</li>
<li>数据加密
<ul>
<li>数据发送端通过加扰将源数据流与一个随机序列异或后，再发送出去，异或操作完成后的数据流基本是伪随机的</li>
<li>在数据接收端也有解扰操作，解扰与加扰必须完全同步，即LFSR使用相同的公式、相同的初始值、相同时刻的输出</li>
</ul>
</li>
<li>CRC校验
<ul>
<li>LFSR还可用于CRC的校验，会用到模2的多项式运算，遵循如下的运算原则：</li>
</ul>
</li>
</ul>
<img src="/images/48368b99c006653092b4985da8179729.png" alt="img" style="zoom: 67%;" />
]]></content>
      <categories>
        <category>LNotes</category>
        <category>LFSR</category>
      </categories>
      <tags>
        <tag>v</tag>
      </tags>
  </entry>
  <entry>
    <title>SV数组队列</title>
    <url>/SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<h1 id="定宽数组">定宽数组</h1>
<ul>
<li>定宽数组（Fixed-Size Arrays）是SV中用于存储固定数量元素的静态数据结构</li>
<li>编译时确定大小，运行时不改变容量，在内存中连续存储，支持高效索引访问</li>
</ul>
<h2 id="特性与声明">特性与声明</h2>
<ul>
<li>基础格式：<code>&lt;数据类型&gt; &lt;数组名&gt;[&lt;维度1&gt;][&lt;维度2&gt;]...;</code>
<ul>
<li>紧凑声明：SV允许只声明数组宽带，使用0作为索引下界</li>
<li>格式化描述符：可使用<code>%p</code>打印数组、结构、类等</li>
<li>SV仿真器存放数组元素时使用字边界</li>
</ul>
</li>
</ul>
<p><img src="/images/image-20250715152350189.png" alt="image-20250715152350189"></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> array1[<span class="number">0</span>:<span class="number">7</span>];                <span class="comment">// 1x8，完整声明，索引下界0、上界7</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] arry2[<span class="number">0</span>:<span class="number">3</span>][<span class="number">0</span>:<span class="number">2</span>];   <span class="comment">// 4*3</span></span><br><span class="line"><span class="keyword">int</span> array1[<span class="number">8</span>];                  <span class="comment">// 紧凑声明</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] arry2[<span class="number">4</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<ul>
<li>常量数组初始化
<ul>
<li>使用一个单引号加大括号来初始化数组，为部分或所有元素赋值</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> b[<span class="number">4</span>] = &#x27;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;    <span class="comment">// 显式声明静态变量，并同时赋值</span></span><br><span class="line">    <span class="keyword">int</span> c[<span class="number">2</span>][<span class="number">3</span>];</span><br><span class="line">    a = &#x27;&#123;<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;                   <span class="comment">// 为全部元素赋值</span></span><br><span class="line">    a = &#x27;&#123;<span class="number">7</span>,<span class="number">6</span>,<span class="number">5</span>&#125;;                       <span class="comment">// 为前3个元素赋值</span></span><br><span class="line">    b = &#x27;&#123;<span class="number">4</span>&#123;<span class="number">8</span>&#125;&#125;;                        <span class="comment">// 全赋值8</span></span><br><span class="line">    b = &#x27;&#123;<span class="keyword">default</span>:<span class="number">42</span>&#125;;                  <span class="comment">// 全赋值42</span></span><br><span class="line">    c = &#x27;&#123;&#x27;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#x27;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;           <span class="comment">// 为全部元素赋值</span></span><br><span class="line">    c[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">1</span>;                        <span class="comment">// 为最后一个元素赋值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="foreach循环">foreach循环</h2>
<ul>
<li>索引变量自动声明，只在循环内有效</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src[<span class="number">5</span>], dst[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> rev[<span class="number">6</span>:<span class="number">2</span>];                       <span class="comment">// 索引从6开始，递减索引</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;<span class="built_in">$size</span>(src); i++)</span><br><span class="line">        src[i] = i;</span><br><span class="line">    <span class="keyword">foreach</span> (dst[j])                    <span class="comment">// 等同于for(int j=0; j&lt;=4; j++)</span></span><br><span class="line">        dst[j] = src[j] * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">foreach</span> (rev[k])                    <span class="comment">// 等同于for(int k=6; j&gt;=2; k--)</span></span><br><span class="line">        rev[k] = k;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>多维数组使用foreach，用逗号将下标隔开后放在同一个方括号中</li>
<li>若不需要遍历所有维度，可以在方括号中忽略掉它们</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> md[<span class="number">2</span>][<span class="number">3</span>] = &#x27;&#123;&#x27;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;,&#x27;&#123;<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (md[i,j])                               <span class="comment">// 遍历所有维度，i++(j++)</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;md[%d][%d] = %d&quot;</span>, i, j, md[i][j]);</span><br><span class="line">    <span class="keyword">foreach</span> (md[i]) <span class="keyword">begin</span>                           <span class="comment">// 分维度遍历，与上面等效</span></span><br><span class="line">        <span class="built_in">$write</span>(<span class="string">&quot;%2d:&quot;</span>, i);                          <span class="comment">// $write输出后不换行</span></span><br><span class="line">        <span class="keyword">foreach</span> (md[,j])</span><br><span class="line">            <span class="built_in">$write</span>(<span class="string">&quot;md[%d][%d] = %d&quot;</span>, i, j, md[i][j]);</span><br><span class="line">        <span class="built_in">$display</span>;                                   <span class="comment">// $display输出后换行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="比较和复制">比较和复制</h2>
<ul>
<li>可以不使用循环而对数组进行聚合比较和复制，聚合操作适用于整个数组而不是单个元素</li>
<li>对于数组的加、减法等算术运算不能使用聚合操作，应该使用foreach循环</li>
<li>对于异或等逻辑运算，应该使用循环或合并数组</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] src[<span class="number">5</span>] = &#x27;&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;, dst[<span class="number">5</span>] = &#x27;&#123;<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;src %s dst&quot;</span>, (src == dst) ? <span class="string">&quot;==&quot;</span> : <span class="string">&quot;!=&quot;</span>);         <span class="comment">// 所有元素值是否相等</span></span><br><span class="line">    dst = src                                                   <span class="comment">// 复制src元素到dst</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;src[1:4] %s dst[1:4]&quot;</span>,</span><br><span class="line">             (src[<span class="number">1</span>:<span class="number">4</span>] == dst[<span class="number">1</span>:<span class="number">4</span>]) ? <span class="string">&quot;==&quot;</span> : <span class="string">&quot;!=&quot;</span>);             <span class="comment">// 比较第1~4个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 同时使用数组下标和位下标打印</span></span><br><span class="line">    <span class="built_in">$displayb</span>(<span class="string">&quot;dst[0][2:1]&quot;</span>);                                   <span class="comment">// &#x27;b10，dst[0]是4</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="合并数组">合并数组</h1>
<h2 id="特性与声明-v2">特性与声明</h2>
<ul>
<li>合并数组是一种特殊的多维数组，其所有维度在内存中连续存储
<ul>
<li>区别于普通向量，合并数组适合处理具有自然分层的结构（如网络包、图像数据）</li>
<li>区别于普通数组使用字边界的存放方式，使得合并数组支持直接的位级操作（如异或运算）</li>
</ul>
</li>
<li>声明合并数组时，数组大小和合并位宽必须在变量名前指定
<ul>
<li>数组大小格式必须是<code>[msb:lsb]</code>，而不是<code>[size]</code></li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] A;       <span class="comment">// 简单的logic变量，存储32bit，访问bit片段需要使用切片</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] B[<span class="number">8</span>];     <span class="comment">// 非合并数组，使用字边界，bit不连续</span></span><br><span class="line"><span class="keyword">logic</span> [<span class="number">3</span>:<span class="number">0</span>] [<span class="number">7</span>:<span class="number">0</span>] C;  <span class="comment">// 4x8合并数组，连续存储，数组大小是4，合并8位</span></span><br><span class="line"><span class="keyword">int</span> [<span class="number">1</span>:<span class="number">0</span>] D;          <span class="comment">// 2x32合并数组，数组大小是2，int合并32位</span></span><br><span class="line"><span class="comment">// 合并数组C的内存布局与向量A相同，但索引方式不同，下图为内存布局图示</span></span><br><span class="line"><span class="comment">//         合并数组 C[3:0][7:0]               普通向量 A[31:0]</span></span><br><span class="line"><span class="comment">//       ┌───────────────────────┐          ┌───────────────────────┐</span></span><br><span class="line"><span class="comment">//字节3   │       C[3][7:0]       │ 31-24    │ A[31:24]              │</span></span><br><span class="line"><span class="comment">//       ├───────────────────────┤          ├───────────────────────┤</span></span><br><span class="line"><span class="comment">//字节2   │       C[2][7:0]       │ 23-16    │ A[23:16]              │</span></span><br><span class="line"><span class="comment">//       ├───────────────────────┤          ├───────────────────────┤</span></span><br><span class="line"><span class="comment">//字节1   │       C[1][7:0]       │ 15-8     │ A[15:8]               │</span></span><br><span class="line"><span class="comment">//       ├───────────────────────┤          ├───────────────────────┤</span></span><br><span class="line"><span class="comment">//字节0   │       C[0][7:0]       │ 7-0      │ A[7:0]                │</span></span><br><span class="line"><span class="comment">//       └───────────────────────┘          └───────────────────────┘</span></span><br></pre></td></tr></table></figure>
<h2 id="混合使用">混合使用</h2>
<ul>
<li>合并数组（Packed Array）和非合并数组（Unpacked Array）可以混合使用
<ul>
<li>合并数组作为非合并数组的元素类型</li>
<li>支持更复杂的硬件建模需求，如数据包、寄存器组</li>
<li>优化内存布局：合并部分连续、非合并灵活分散</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// barray是一个有5个合并数据作为元素的非合并数组</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] [<span class="number">7</span>:<span class="number">0</span>] barray [<span class="number">5</span>];</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] oneword = <span class="number">32&#x27;h012345678</span>;</span><br><span class="line">barray[<span class="number">0</span>] = oneword;</span><br><span class="line"><span class="comment">// barray[0][3] = 8&#x27;h01;</span></span><br><span class="line"><span class="comment">// barray[0][1][6] = 1&#x27;b1;</span></span><br></pre></td></tr></table></figure>
<img src="/images/image-20250718164324555.png" alt="image-20250718164324555" style="zoom: 33%;" />
<h1 id="动态数组">动态数组</h1>
<h2 id="特性与声明-v3">特性与声明</h2>
<ul>
<li>动态数组在声明时使用空的下标<code>[]</code>，表示数组尺寸在编译时未指定</li>
<li>仿真运行时通过<code>new[]</code>操作符显式地预分配内存大小</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> dyn[],d2[];                  <span class="comment">// 声明动态数组</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">5</span>];                <span class="comment">// 分配5个元素空间</span></span><br><span class="line">    <span class="keyword">foreach</span> (dyn[j]) dyn[j] = j; <span class="comment">// 初始化元素（例如：dyn[0]=0, dyn[1]=1...）</span></span><br><span class="line">    d2 = dyn;                    <span class="comment">// 复制一个动态数组</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">20</span>](dyn);          <span class="comment">// 重新分配20个整数并进行复制</span></span><br><span class="line">    dyn = <span class="keyword">new</span>[<span class="number">100</span>];              <span class="comment">// 重新分配100个整数，舍弃旧值</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>基本数据类型（如<code>int</code>）相同，定宽数组和动态数据之间可以相互赋值
<ul>
<li>当把一个定宽数组复制给一个动态数组时，会自动分配空间</li>
<li>适用于想声明一个常数数组但又不想统计元素的个数</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] mask[] = `&#123;<span class="number">2&#x27;b00</span>, <span class="number">2&#x27;b01</span>, <span class="number">2&#x27;b10</span>, <span class="number">2&#x27;b11</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>声明多维动态数组时，需按照从左到右的维度构造</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[][];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    d = <span class="keyword">new</span>[<span class="number">4</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (d[i]) d[i] = <span class="keyword">new</span>[i+<span class="number">123</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (d[i,j]) d[i][j] = i + j;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="常用内建方法">常用内建方法</h2>
<ul>
<li>长度操作：<code>array.size()</code>获取数组当前元素个数，等同于<code>$size(array)</code></li>
<li>删除内存：<code>array.delete()</code>释放数组内存</li>
<li>插入元素：<code>array.insert(index, value)</code>在指定索引位置插入元素，数组大小自动增加</li>
<li>删除元素：<code>array.delete(index)</code>删除指定索引处的元素，数组大小减1</li>
</ul>
<blockquote>
<p>动态数据使用上述内建函数消耗性能，更多内建方法见最后一章</p>
</blockquote>
<h1 id="队列">队列</h1>
<h2 id="特性与声明-v4">特性与声明</h2>
<ul>
<li>队列 (queues) 特性
<ul>
<li>动态：队列长度在仿真期间自动伸缩，无需预分配大小</li>
<li>同质：队列中所有元素的类型必须相同</li>
<li>有序：队列中的元素是有序的，能够通过索引访问</li>
<li>高效操作：SV提供内置的方法高效地在队列的任意位置删减元素</li>
</ul>
</li>
<li>队列声明
<ul>
<li>声明队列的语法与数组类似，但需使用<code>$</code></li>
<li>队列的常量初始化不再需要使用<code>'</code></li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_int_q[$];              <span class="comment">// 声明一个整数队列</span></span><br><span class="line">my_class_type my_object_q[$]; <span class="comment">// 声明一个自定义类对象句柄队列</span></span><br><span class="line">my_int_q[$] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>打包与解包</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] pk_addr, pk_csm, pk_data[<span class="number">8</span>];     <span class="comment">// pack</span></span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] upk_addr, upk_csm, upk_data[<span class="number">8</span>];  <span class="comment">// unpack</span></span><br><span class="line"><span class="keyword">byte</span> bytes[$];</span><br><span class="line">bytes = &#123; &gt;&gt; &#123;pk_addr, pk_csm, pk_data&#125;&#125;;</span><br><span class="line">&#123; &gt;&gt; &#123;upk_addr, upk_csm, upk_data&#125;&#125; = bytes;</span><br></pre></td></tr></table></figure>
<h2 id="常用内建方法-v2">常用内建方法</h2>
<ul>
<li>长度操作：<code>q.size()</code>返回队列中元素的当前数量，等同于<code>$size(q)</code></li>
<li>删除内存：<code>array.delete()</code>释放数组内存</li>
<li>删除元素：<code>q.delete(index)</code>删除指定索引处的元素</li>
<li>插入元素：<code>q.insert(index, item)</code>在指定索引处插入一个元素</li>
<li>头部插入：<code>q.push_front(item)</code>在队列的头部插入一个元素</li>
<li>尾部插入：<code>q.push_back(item)</code>在队列的尾部插入一个元素</li>
<li>头部发送：<code>q.pop_front()</code>移除并返回队列头部的元素</li>
<li>尾部发送：<code>q.pop_back()</code>移除并返回队列尾部的元素</li>
<li>移除重复：<code>q.unique()</code>移除队列中的重复元素</li>
</ul>
<h1 id="关联数组">关联数组</h1>
<h2 id="特性与声明-v5">特性与声明</h2>
<ul>
<li>关联数组（Associative Arrays）允许使用任意类型（如整型、字符串等）作为索引（键Key），快速存取对应的值，原理示例<code>Key: “apple” -&gt; 哈希表 -&gt; 索引值 -&gt; 定位存储位置（通）-&gt; 返回值</code>
<ul>
<li>动态：内存仅在写入元素时分配，无需预分配</li>
<li>无序：存储非连续索引的数据（如大范围地址的稀疏数据），避免内存浪费</li>
<li>灵活：索引可以为任意类型</li>
</ul>
</li>
</ul>
<img src="/images/image-20250721163601864.png" alt="image-20250721163601864" style="zoom:50%;" />
<ul>
<li>声明格式：<code>data_type array_name [index_type];</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//声明及初始化</span></span><br><span class="line"><span class="keyword">int</span> fruit_prices[<span class="keyword">string</span>] = &#x27;&#123;<span class="string">&quot;apple&quot;</span>: <span class="number">5</span>, <span class="string">&quot;banana&quot;</span>: <span class="number">3</span>, <span class="string">&quot;orange&quot;</span>: <span class="number">4</span>&#125;;</span><br><span class="line">fruit_prices[<span class="string">&quot;grape&quot;</span>] = <span class="number">6</span>; <span class="comment">// 动态赋值</span></span><br><span class="line"><span class="comment">// foreach循环遍历</span></span><br><span class="line"><span class="keyword">foreach</span> (fruit_prices[i]) <span class="keyword">begin</span>  </span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;fruit_prices[%s] = %0d&quot;</span>, i, fruit_prices[i]);  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">// first/next循环遍历</span></span><br><span class="line"><span class="keyword">string</span> key;</span><br><span class="line"><span class="keyword">if</span> (my_array<span class="variable">.first</span>(key)) <span class="keyword">begin</span>  <span class="comment">// 获取第一个键存入字符串变量key</span></span><br><span class="line">    <span class="keyword">do</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;my_array[%s] = %0d&quot;</span>, key, my_array[key]); <span class="comment">// 打印键值</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">while</span> (my_array<span class="variable">.next</span>(key));  <span class="comment">// 获取下一个键，直到返回0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="常用内建方法-v3">常用内建方法</h2>
<ul>
<li>删除内存：<code>array.delete()</code></li>
<li>删除键值对：<code>array.delete(key)</code></li>
<li>检查键存在：<code>array.exitsts(key)</code>检查指定键是否存在，若存在返回布尔值1</li>
<li>数量查询：<code>array.nun()</code>查询数组中键值对的总数量</li>
<li>获取首键：<code>array.first(ref)</code>获取第一个键赋值给参数ref</li>
<li>获取未键：<code>array.last(ref)</code>获取最后一个键赋值给参数ref</li>
<li>获取下一键：<code>array.next(ref)</code>获取下一个键赋值给参数ref</li>
<li>获取上一键：<code>array.prev(ref)</code>获取上一个键赋值给参数ref</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> memory_model;  </span><br><span class="line">  <span class="comment">// 假设这是一个简单的内存模型，用于存储和检索数据  </span></span><br><span class="line">  <span class="keyword">byte</span> memory[<span class="keyword">int</span>];  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> write(<span class="keyword">int</span> addr, <span class="keyword">byte</span> data);  </span><br><span class="line">    memory[addr] = data;  </span><br><span class="line">  <span class="keyword">endfunction</span>  </span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">byte</span> read(<span class="keyword">int</span> addr);  </span><br><span class="line">    <span class="keyword">if</span> (memory<span class="variable">.exists</span>(addr)) <span class="keyword">return</span> memory[addr];  </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 假设如果地址不存在，则返回0  </span></span><br><span class="line">  <span class="keyword">endfunction</span>  </span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h1 id="数组的方法">数组的方法</h1>
<ul>
<li>数组内建方法汇总，使用于任何非合并的数组类型，包括定宽数组、动态数组、队列和关联数组</li>
</ul>
<h2 id="缩减">缩减</h2>
<ul>
<li>数组的缩减方法是指将数组缩减成一个值，结果和元素的位宽一致</li>
<li>缩减方法可以用来计算数组中所有元素的和、积或逻辑运算
<ul>
<li>和积：<code>array.sum()</code>、<code>array.product()</code></li>
<li>与或：<code>array.and()</code>、<code>array.or()</code></li>
<li>异或：<code>array.xor()</code></li>
</ul>
</li>
<li>SV并没有内建从数组中随机选取一个元素的方法，但可以生成一个随机索引</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> my_array[<span class="number">4</span>] = &#x27;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> random_index, selected_element;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成随机索引（0 到 3）</span></span><br><span class="line">random_index = $urandom_range(my_array<span class="variable">.size</span>() - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 选取元素</span></span><br><span class="line">selected_element = my_array[random_index];</span><br><span class="line"><span class="built_in">$display</span>(<span class="string">&quot;随机选取的元素: %d&quot;</span>, selected_element);</span><br></pre></td></tr></table></figure>
<h2 id="定位-条件">定位/条件</h2>
<ul>
<li>用于查找数组中所有满足指定条件的元素，并将结果以队列形式（无<code>'</code>）返回</li>
<li>数组定位方法：min、max、unique
<ul>
<li><code>array.min()</code>和<code>array.max()</code>返回数组的最值队列</li>
<li><code>array.unique()</code>返回数组中唯一值的队列</li>
</ul>
</li>
<li>数组定位方法：find
<ul>
<li><code>array.find() with (condition)</code>强制使用<code>with</code>语句查找指定条件，并以队列形式返回
<ul>
<li>无匹配时返回空队列<code>{}</code>，需在代码中检查结果中是否有效</li>
<li><code>with</code>支持复杂逻辑，如<code>item &gt; 2 &amp;&amp; intem &lt; 8</code></li>
</ul>
</li>
<li><code>array.find_first() with (conditon)</code>以队列形式返回首个满足条件的元素</li>
<li><code>array.find_last() with (conditon)</code>以队列形式返回最后一个满足条件的元素</li>
<li><code>array.find_index() with (conditon)</code>以队列形式返回首个满足条件的元素的索引
<ul>
<li>对于<code>find_index</code>方法，返回的队列类型是双状态<code>int</code>而不是四状态<code>integer</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#x27;&#123;<span class="number">3</span>, <span class="number">7</span>, <span class="number">2</span>, <span class="number">9</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> found_queue[$] = arr<span class="variable">.find</span>() <span class="keyword">with</span> (item &gt; <span class="number">5</span>);   <span class="comment">// found_queue = &#123;7, 9&#125;</span></span><br><span class="line"><span class="comment">// found_queue.delete();</span></span><br><span class="line">found_queue = arr<span class="variable">.find_first</span>() <span class="keyword">with</span> (item % <span class="number">2</span> == <span class="number">0</span>); <span class="comment">// 首个偶数：&#123;2&#125;</span></span><br><span class="line">found_queue = arr<span class="variable">.find_last</span>() <span class="keyword">with</span> (item &lt; <span class="number">6</span>); <span class="comment">// 最后一个小于6的数：&#123;5&#125;</span></span><br><span class="line"><span class="keyword">int</span> index_queue[$] = arr<span class="variable">.find_index</span>() <span class="keyword">with</span> (item == <span class="number">9</span>); <span class="comment">// 索引：&#123;3&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在条件语句<code>with</code>中，<code>item</code>被称为重复参数，是一个缺省的名字，也可以指定其他名字，以下四个语句是等同的</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">found_queue = arr<span class="variable">.find</span>() <span class="keyword">with</span> (item == <span class="number">3</span>);</span><br><span class="line">found_queue = arr<span class="variable">.find</span> <span class="keyword">with</span> (item == <span class="number">3</span>);</span><br><span class="line">found_queue = arr<span class="variable">.find</span>(item) <span class="keyword">with</span> (item == <span class="number">3</span>);</span><br><span class="line">found_queue = arr<span class="variable">.find</span>(x) <span class="keyword">with</span> (x == <span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>当把数组缩减方法<code>sum()</code>与条件语句<code>with</code>结合使用时，可以检测表达式为真的次数</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count, total, d[] = `&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">count = d<span class="variable">.sum</span>(x) <span class="keyword">with</span> (x &gt; <span class="number">7</span>);        <span class="comment">// 2 = sum&#123;1,0,1,0,0,0&#125;</span></span><br><span class="line">total = d<span class="variable">.sum</span>(x) <span class="keyword">with</span> ((x &gt; <span class="number">7</span>) * x)   <span class="comment">// 17 = sum&#123;9,0,8,0,0,0&#125;</span></span><br><span class="line">total = d<span class="variable">.sum</span>(x) <span class="keyword">with</span> (x &lt; <span class="number">8</span> ? x : <span class="number">0</span>) <span class="comment">// 12 = sum&#123;0,1,0,3,4,4&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>下面介绍了一种使用数组定位方法建立记分板的方法，使用<code>typedef</code>创建包结构（对于包信息的存储，更好的方法是使用类）
<ul>
<li>例子中<code>check_addr()</code>函数在计分板中寻找和参数匹配的地址</li>
<li><code>find_index()</code>方法返回一个<code>int</code>队列</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="keyword">packed</span> &#123;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] pr;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] data;</span><br><span class="line">&#125; Packet;</span><br><span class="line"></span><br><span class="line">Packet scb[$];</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> check_addr(<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr);</span><br><span class="line">    <span class="keyword">int</span> intq[$];</span><br><span class="line">    </span><br><span class="line">    intq = scb<span class="variable">.find_index</span>() <span class="keyword">with</span> (item<span class="variable">.addr</span> == addr);</span><br><span class="line">    <span class="keyword">case</span>(intq<span class="variable">.size</span>())</span><br><span class="line">        <span class="number">0</span>: <span class="built_in">$display</span>(<span class="string">&quot;Addr %h not found in scoreboard&quot;</span>, addr);</span><br><span class="line">        <span class="number">1</span>: scb<span class="variable">.delete</span>(intq[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">default</span>: <span class="built_in">$display</span>(<span class="string">&quot;ERROR: Multiple hits for addr %h&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endfunction</span> : check_addr</span><br></pre></td></tr></table></figure>
<h2 id="排序">排序</h2>
<ul>
<li>只有定宽数组、动态数组、队列可以排序、反转、打乱次序，关联数组不能重新排序</li>
<li>排序方法改变了原始数组，而定位方法是新建一个队列来保存结果
<ul>
<li><code>array.sort()</code>按照元素大小进行升序排序</li>
<li><code>array.rsort()</code>按照元素大小进行降序排序</li>
<li><code>array.reverse()</code>反转数组中元素的顺序</li>
<li><code>array.shuffle()</code>打乱数组中元素的顺序</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> d[] = &#x27;&#123;<span class="number">9</span>,<span class="number">1</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>&#125;;</span><br><span class="line">d<span class="variable">.sort</span>();    <span class="comment">//&#x27;&#123;1,3,4,4,8,9&#125;</span></span><br><span class="line">d<span class="variable">.rsort</span>();   <span class="comment">//&#x27;&#123;9,8,4,4,3,1&#125;</span></span><br><span class="line">d<span class="variable">.reverse</span>(); <span class="comment">//&#x27;&#123;4,4,3,8,1,9&#125;</span></span><br><span class="line">d<span class="variable">.shuffle</span>(); <span class="comment">//&#x27;&#123;9,4,3,8,1,4&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用子域对一个结构数组进行排序时，<code>reverse</code>和<code>shuffle</code>方法不能带<code>with</code>语句</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="keyword">packed</span> &#123; <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] red, green, blue&#125; color[];</span><br><span class="line">color = &#x27;&#123;&#x27;&#123;red:<span class="number">7</span>, grean:<span class="number">4</span>, blue:<span class="number">9</span>&#125;, &#x27;&#123;red:<span class="number">3</span>, grean:<span class="number">2</span>, blue:<span class="number">9</span>&#125;, &#x27;&#123;red:<span class="number">5</span>, grean:<span class="number">2</span>, blue:<span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">color<span class="variable">.sort</span> <span class="keyword">with</span> (item<span class="variable">.red</span>);           <span class="comment">//只对红色像素进行重新排序</span></span><br><span class="line"><span class="comment">//&#x27;&#123;&#x27;&#123;red:3, grean:2, blue:9&#125;, &#x27;&#123;red:5, grean:2, blue:1&#125;, &#x27;&#123;red:7, grean:4, blue:9&#125;&#125;</span></span><br><span class="line">color<span class="variable">.sort</span>(x) <span class="keyword">with</span> (x<span class="variable">.green</span>, x<span class="variable">.blue</span>)  <span class="comment">//先对绿色再对蓝色进行重新排序</span></span><br></pre></td></tr></table></figure>
<h1 id="选择数据结构">选择数据结构</h1>
<blockquote>
<p>本章介绍一些如何正确选择存储类型（数据结构）的经验法则</p>
</blockquote>
<ul>
<li>网络数据包建模
<ul>
<li>特点：长度固定、顺序读取</li>
<li>针对长度固定或可变的数据可分别采用定宽数组或动态数组</li>
</ul>
</li>
<li>保存期望值的记分板
<ul>
<li>特点：仿真前长度位置，按值存取，长度经常变化</li>
<li>一般情况下可使用队列，方便在仿真期间连续增加和删除元素</li>
<li>如果记分板由数百个元素，而且需要经常对元素进行增删操作，则使用关联数组在速度上可能更快</li>
<li>如果将事务建模成对象，那么记分板可以是句柄的队列</li>
<li>如果不用记分板进行搜索，那么只需要把预期的数值存入信箱（mailbox）</li>
</ul>
</li>
<li>有序结构
<ul>
<li>如果数据按照可预见的顺序输出，可以使用队列</li>
<li>如果输出顺序不确定，则使用关联数组</li>
</ul>
</li>
<li>对特大容量存储器建模
<ul>
<li>如果不需要用到所有存储空间，可以使用关联数组实现稀疏存储</li>
<li>确保使用的是双状态类型的32比特合并数据，以节约仿真器使用的内存</li>
</ul>
</li>
<li>文件中的命令名或操作码
<ul>
<li>特点：把字符串转换成固定值</li>
<li>从文件中读出字符串，然后使用命令作为字符串索引在关联数组中查找命令名或操作码</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>LNotes</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>sv</tag>
      </tags>
  </entry>
  <entry>
    <title>Next配置</title>
    <url>/Next%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="Next部署">Next部署</h1>
<h2 id="安装更新">安装更新</h2>
<ul>
<li>在站点根目录下安装<a href="https://github.com/next-theme/hexo-theme-next?tab=readme-ov-file">NEXT_8.x仓库</a>
<ul>
<li>首次安装：<code>git clone https://github.com/next-theme/hexo-theme-next themes/next</code></li>
<li>后续更新：<code>git -C themes/next pull</code></li>
</ul>
</li>
<li>安装完成后，更改站点配置文件<code>theme: next</code></li>
</ul>
<h2 id="备用配置">备用配置</h2>
<ul>
<li>传统配置NEXT主题的方式是直接编辑主题配置文件（<code>themes/next/_config.yml</code>），然而在升级主题时配置文件会被覆盖，因此使用备用主题配置的方法</li>
<li>在站点根目录中创建备用主题配置文件<code>cp themes/next/_config.yml _config.next.yml</code>
<ul>
<li>或者只将修改的部分放到<code>_config.next.yml</code>中，默认的部分不放入</li>
</ul>
</li>
</ul>
<h1 id="主题设置">主题设置</h1>
<ul>
<li>Next 8.x支持原生黑夜主题，主要在主题配置文件<code>_config.next.yml</code>中配置<code>darkmode: true</code>
<ul>
<li>此后根据系统偏好自动决定是否启用黑夜主题</li>
</ul>
</li>
<li>上述方法缺少主动切换网页端主动切换的按键，可以通过插件解决
<ul>
<li>关闭原生黑夜主题<code>darkmode: false</code></li>
<li>安装插件<code>npm install hexo-next-darkmode --save</code></li>
<li>在主题配置文件中添加如下内容</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Darkmode JS</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/rqh656418510/hexo-next-darkmode, https://github.com/sandoche/Darkmode.js</span></span><br><span class="line"><span class="attr">darkmode_js:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">bottom:</span> <span class="string">&#x27;64px&#x27;</span> <span class="comment"># default: &#x27;32px&#x27;</span></span><br><span class="line">  <span class="attr">right:</span> <span class="string">&#x27;32px&#x27;</span> <span class="comment"># default: &#x27;32px&#x27;</span></span><br><span class="line">  <span class="attr">left:</span> <span class="string">&#x27;unset&#x27;</span> <span class="comment"># default: &#x27;unset&#x27;</span></span><br><span class="line">  <span class="attr">time:</span> <span class="string">&#x27;0.5s&#x27;</span> <span class="comment"># default: &#x27;0.3s&#x27;</span></span><br><span class="line">  <span class="attr">mixColor:</span> <span class="string">&#x27;transparent&#x27;</span> <span class="comment"># default: &#x27;#fff&#x27;</span></span><br><span class="line">  <span class="attr">backgroundColor:</span> <span class="string">&#x27;transparent&#x27;</span> <span class="comment"># default: &#x27;#fff&#x27;</span></span><br><span class="line">  <span class="attr">buttonColorDark:</span> <span class="string">&#x27;#100f2c&#x27;</span> <span class="comment"># default: &#x27;#100f2c&#x27;</span></span><br><span class="line">  <span class="attr">buttonColorLight:</span> <span class="string">&#x27;#fff&#x27;</span> <span class="comment"># default: &#x27;#fff&#x27;</span></span><br><span class="line">  <span class="attr">isActivated:</span> <span class="literal">false</span> <span class="comment"># default false</span></span><br><span class="line">  <span class="attr">saveInCookies:</span> <span class="literal">true</span> <span class="comment"># default: true</span></span><br><span class="line">  <span class="attr">label:</span> <span class="string">&#x27;🌓&#x27;</span> <span class="comment"># default: &#x27;&#x27;</span></span><br><span class="line">  <span class="attr">autoMatchOsTheme:</span> <span class="literal">true</span> <span class="comment"># default: true</span></span><br><span class="line">  <span class="attr">libUrl:</span> <span class="comment"># Set custom library cdn url for Darkmode.js</span></span><br></pre></td></tr></table></figure>
<h1 id="信息设置">信息设置</h1>
<h2 id="图标">图标</h2>
<ul>
<li>搜索favicon设置图标，<a href="https://www.iconfont.cn/">图标素材网站</a></li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-A.png</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-A.png</span></span><br><span class="line">  <span class="attr">large:</span> <span class="string">/images/favicon-48x48-A.png</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/favicon-A.svg</span></span><br><span class="line">  <span class="comment">#android_manifest: /images/manifest.json</span></span><br><span class="line">  <span class="comment">#ms_browserconfig: /images/browserconfig.xml</span></span><br></pre></td></tr></table></figure>
<h2 id="版权说明">版权说明</h2>
<ul>
<li>使用<code>by-nc-sa</code>协议，显示版权说明</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="菜单设置">菜单设置</h1>
<ul>
<li>打开themes/next目录下的主题配置文_config.yml，查找menu</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="comment"># tags: /tags/ || fa fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment"># schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>
<ul>
<li>根目录下使用命令在source中建立文件夹
<ul>
<li><code>hexo new page &quot;categories&quot;</code></li>
<li><code>hexo new page &quot;tags&quot;</code></li>
</ul>
</li>
<li>修改所生成文件夹中的index.md文件自定义标题</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2025-07-09 11:44:14</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">&quot;categories&quot;</span></span><br><span class="line"><span class="attr">comments:</span> <span class="literal">false</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<h1 id="侧边栏设置">侧边栏设置</h1>
<h2 id="头像">头像</h2>
<ul>
<li>自定义头像、设置头像圆形显示并随鼠标旋转</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Sidebar Avatar</span></span><br><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">url:</span> <span class="string">/images/A.png</span></span><br><span class="line">  <span class="attr">rounded:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">rotated:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="目录">目录</h2>
<ul>
<li>开启标题自动编号、禁止目录自动换行、启用默认展开所有目录</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span>      <span class="comment">#目录项前显示数字序号</span></span><br><span class="line">  <span class="attr">wrap:</span> <span class="literal">false</span>       <span class="comment">#文章过长时是否自动换行</span></span><br><span class="line">  <span class="attr">expand_all:</span> <span class="literal">true</span>  <span class="comment">#是否默认展开所有层级目录</span></span><br><span class="line">  <span class="attr">max_depth:</span> <span class="number">6</span>      <span class="comment">#生成目录的最大标题深度</span></span><br></pre></td></tr></table></figure>
<h1 id="页脚设置">页脚设置</h1>
<ul>
<li>启用图标动态化、关闭<code>Powered by</code>显示</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">fa</span> <span class="string">fa-heart</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">&quot;#ff0000&quot;</span></span><br><span class="line">  <span class="attr">powered:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h1 id="正文设置">正文设置</h1>
<h2 id="标签图标">标签图标</h2>
<ul>
<li>设置文末的标签使用图标代替<code>#</code>符号</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">tag_icon:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="其他设置">其他设置</h1>
<h2 id="正文对齐">正文对齐</h2>
<ul>
<li>左右对齐更改为根据左对齐，以适配窄屏设备</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">text_align:</span></span><br><span class="line">  <span class="comment"># Available values: start | end | left | right | center | justify | justify-all | match-parent</span></span><br><span class="line">  <span class="attr">desktop:</span> <span class="string">start</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="string">start</span></span><br></pre></td></tr></table></figure>
<h2 id="代码块渲染">代码块渲染</h2>
<ul>
<li>设置代码框为MAC样式，开启复制按键，并设置代码块自动折叠</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">mac</span></span><br><span class="line">  <span class="attr">fold:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">height:</span> <span class="number">300</span></span><br></pre></td></tr></table></figure>
<h2 id="浏览进度">浏览进度</h2>
<ul>
<li>在返回顶部按键中显示当前阅读进度</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="外部库">外部库</h1>
<h2 id="预加载">预加载</h2>
<ul>
<li>启用<code>pjax</code>进行预加载</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Easily enable fast Ajax navigation on your website.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/next-theme/pjax</span></span><br><span class="line"><span class="attr">pjax:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="图片放大">图片放大</h2>
<ul>
<li>图片视频放大浏览</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.</span></span><br><span class="line"><span class="comment"># For more information: https://fancyapps.com/fancybox/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="中英文显示">中英文显示</h2>
<ul>
<li>自动在页面上所有的汉字和英文数字符号之间插入一个空格</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Automatically insert whitespace between CJK and half-width characters.</span></span><br><span class="line"><span class="comment"># For more information: https://github.com/vinta/pangu.js</span></span><br><span class="line"><span class="comment"># Server-side plugin: https://github.com/next-theme/hexo-pangu</span></span><br><span class="line"><span class="attr">pangu:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h2 id="快速链接">快速链接</h2>
<ul>
<li>在空闲时间预加载页面链接，来加快后续页面的加载速度</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">quicklink:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">home:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archive:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">delay:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">timeout:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">priority:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h1 id="搜索服务">搜索服务</h1>
<ul>
<li>开启本地搜索服务</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">1</span>     <span class="comment">#每篇文章显示的结果数</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span>          <span class="comment">#是否转义HTML特殊字符</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span>           <span class="comment">#是否预加载搜索结果</span></span><br></pre></td></tr></table></figure>
<h1 id="自定义文件"><a href="https://theme-next.js.org/docs/advanced-settings/custom-files.html#Examples-of-Modifying-Layout">自定义文件</a></h1>
<ul>
<li>将自定义文件与主题文件分开，避免因<code>git merge</code>（<code>git pull</code>包含拉取更新和合并分支两个操作）而产生的冲突</li>
<li>将自定义文件添加到<code>hexo-site/source/_data</code>，随后取消备用主题配置文件中对应的注释即可</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path:</span></span><br><span class="line">  <span class="comment">#head: source/_data/head.njk</span></span><br><span class="line">  <span class="comment">#header: source/_data/header.njk</span></span><br><span class="line">  <span class="comment">#sidebar: source/_data/sidebar.njk</span></span><br><span class="line">  <span class="comment">#postMeta: source/_data/post-meta.njk</span></span><br><span class="line">  <span class="comment">#postBodyStart: source/_data/post-body-start.njk</span></span><br><span class="line">  <span class="comment">#postBodyEnd: source/_data/post-body-end.njk</span></span><br><span class="line">  <span class="comment">#footer: source/_data/footer.njk</span></span><br><span class="line">  <span class="comment">#bodyEnd: source/_data/body-end.njk</span></span><br><span class="line">  <span class="comment">#variable: source/_data/variables.styl</span></span><br><span class="line">  <span class="comment">#mixin: source/_data/mixins.styl</span></span><br><span class="line">  <span class="comment">#style: source/_data/styles.styl</span></span><br></pre></td></tr></table></figure>
<h2 id="标题编号">标题编号</h2>
<ul>
<li>对于Hexo-NEXT渲染的html文件，默认为TOC自动添加编号，但是缺少对正文标题编号的自动添加</li>
<li>首先在<code>hexo-site/source./_data</code>中新建<code>styles.styl</code>文件，取消<code>_config.next.yml</code>中的注释</li>
<li>往<code>hexo-site/source./_data/styles.styl</code>中添加如下代码</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.post-block</span> &#123;</span><br><span class="line">  <span class="selector-class">.post-body</span> &#123;<span class="attribute">counter-reset</span>: h1&#125;</span><br><span class="line">          <span class="selector-tag">h1</span> &#123;<span class="attribute">counter-reset</span>: h2&#125;</span><br><span class="line">          <span class="selector-tag">h2</span> &#123;<span class="attribute">counter-reset</span>: h3&#125;</span><br><span class="line">          <span class="selector-tag">h3</span> &#123;<span class="attribute">counter-reset</span>: h4&#125;</span><br><span class="line">          <span class="selector-tag">h4</span> &#123;<span class="attribute">counter-reset</span>: h5&#125;</span><br><span class="line">          <span class="selector-tag">h5</span> &#123;<span class="attribute">counter-reset</span>: h6&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.post-body</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h1; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h2</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h2; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h3</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h3; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h4</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h4; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h5</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h5; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">  <span class="selector-tag">h6</span><span class="selector-pseudo">:before</span> &#123;<span class="attribute">counter-increment</span>: h6; <span class="attribute">content</span>: <span class="built_in">counter</span>(h1) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h2) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h3) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h4) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h5) <span class="string">&quot;.&quot;</span> <span class="built_in">counter</span>(h6) <span class="string">&quot;. &quot;</span>&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="页脚自定义">页脚自定义</h2>
<ul>
<li>在<code>hexo-site/source./_data</code>中新建<code>footer.njk</code>文件，取消<code>_config.next.yml</code>中的注释</li>
<li>往<code>hexo-site/source./_data/footer.njk</code>中添加如下代码</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">div</span> class=&quot;custom-<span class="selector-tag">footer</span>&quot;&gt;</span><br><span class="line">  &lt;<span class="selector-tag">p</span>&gt;自定义文字&lt;/<span class="selector-tag">p</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">div</span>&gt;</span><br></pre></td></tr></table></figure>
<h1 id="修改源码">修改源码</h1>
<ul>
<li>对于<code>8.23.2</code>版本的Next，无法在只修改自定义文件的前提下实现以下功能，注意做好版本更新时的迁移</li>
<li>虽然实测可行，但出于更新风险的考虑，以下所有功能已弃用，源码恢复原样</li>
</ul>
<h2 id="球形标签云">球形标签云</h2>
<ul>
<li>右键另存<a href="https://www.goat1000.com/tagcanvas.js">tagcanvas.js</a>入<code>next-site/source/js</code>路径下</li>
<li>在<code>next-site/source/js</code>路径下创建文件<code>tagcloud.js</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="title class_">TagCanvas</span>.<span class="title class_">Start</span>(<span class="string">&#x27;my3DTags&#x27;</span>, <span class="string">&#x27;tags&#x27;</span>,</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">textFont</span>: <span class="string">&#x27;Georgia,Optima&#x27;</span>,</span><br><span class="line">                <span class="attr">textColour</span>: <span class="literal">null</span>,</span><br><span class="line">                <span class="attr">outlineColour</span>: <span class="string">&#x27;black&#x27;</span>,</span><br><span class="line">                <span class="attr">weight</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">reverse</span>: <span class="literal">true</span>,</span><br><span class="line">                <span class="attr">depth</span>: <span class="number">0.8</span>,</span><br><span class="line">                <span class="attr">maxSpeed</span>: <span class="number">0.05</span>,</span><br><span class="line">                <span class="attr">bgRadius</span>: <span class="number">1</span>,</span><br><span class="line">                <span class="attr">freezeDecel</span>: <span class="literal">true</span></span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        <span class="variable language_">document</span></span><br><span class="line">            .<span class="title function_">getElementById</span>(<span class="string">&#x27;myTags&#x27;</span>)</span><br><span class="line">            .<span class="property">style</span></span><br><span class="line">            .<span class="property">display</span> = <span class="string">&#x27;none&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如下修改<code>next-site/layout/_partials/pages/tags.njk</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">&quot;tag-cloud&quot;</span>&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tag-cloud-title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; _p(&#x27;counter.tag_cloud&#x27;, site.tags.length) &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tag-cloud-tags&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    &#123;&#123; tagcloud(&#123;</span></span><br><span class="line"><span class="language-xml">      min_font: theme.tagcloud.min,</span></span><br><span class="line"><span class="language-xml">      max_font: theme.tagcloud.max,</span></span><br><span class="line"><span class="language-xml">      amount  : theme.tagcloud.amount,</span></span><br><span class="line"><span class="language-xml">      orderby : theme.tagcloud.orderby,</span></span><br><span class="line"><span class="language-xml">      order   : theme.tagcloud.order,</span></span><br><span class="line"><span class="language-xml">      class   : &#x27;tag-cloud&#x27;</span></span><br><span class="line"><span class="language-xml">      &#125;)</span></span><br><span class="line"><span class="language-xml">    &#125;&#125;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#123;# 球形云标签 #&#125;</span><br><span class="line">  &lt;div <span class="keyword">class</span>=<span class="string">&quot;tags&quot;</span> id=<span class="string">&quot;myTags&quot;</span>&gt;</span><br><span class="line">    <span class="language-xml"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">&quot;720&quot;</span> <span class="attr">height</span>=<span class="string">&quot;720&quot;</span> <span class="attr">id</span>=<span class="string">&quot;my3DTags&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display: block;margin: 0 auto;&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;tags&quot;</span> <span class="attr">id</span>=<span class="string">&quot;tags&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;display: none&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      &#123;&#123; tagcloud(&#123;</span></span><br><span class="line"><span class="language-xml">          min_font   : 16,</span></span><br><span class="line"><span class="language-xml">          max_font   : 35,</span></span><br><span class="line"><span class="language-xml">          amount     : 999,</span></span><br><span class="line"><span class="language-xml">          color      : false,</span></span><br><span class="line"><span class="language-xml">          start_color: &#x27;black&#x27;,</span></span><br><span class="line"><span class="language-xml">          end_color  : &#x27;green&#x27;</span></span><br><span class="line"><span class="language-xml">        &#125;)</span></span><br><span class="line"><span class="language-xml">      &#125;&#125;</span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcanvas.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  <span class="language-xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;/js/tagcloud.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &#123;# 球形云标签 #&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在站点配置文件中添加如下开关</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">crashcheat:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">tagcanvas:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>How-To</category>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>yml</tag>
        <tag>sh</tag>
        <tag>styl</tag>
        <tag>js</tag>
        <tag>njk</tag>
      </tags>
  </entry>
  <entry>
    <title>SV类与对象</title>
    <url>/SV%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h1 id="OOP概述">OOP概述</h1>
<h2 id="特性">特性</h2>
<ul>
<li>SV面向对象编程（Object Oriented Programming, OOP）是在传统Verilog基础上扩展的核心特性
<ul>
<li>能够创建复杂的数据类型及方法，并且将它们和子程序紧密第结合在一起</li>
<li>能够在更加抽象的层次建立测试平台和系统级模型，使之更加易于维护</li>
</ul>
</li>
<li>通过封装、继承、多态等机制实现代码复用、模块化和灵活扩展
<ul>
<li>传统的测试平台强调操作：创建一个事务、发送、接收、检查结果、产生报告</li>
<li>在OOP中更加聚焦于各个组件及功能，如<code>Driver</code>、<code>Monitor</code>、<code>Packet</code>、<code>Transaction</code>、<code>Scoreboard</code>等</li>
</ul>
</li>
</ul>
<h2 id="术语">术语</h2>
<ul>
<li>在Verilog中，通过创建模块并在编译时逐层例化，可以得到一个复杂的设计，其顶层模块是隐式例化的</li>
<li>在OOP中创建类并在运行时构造它们（创建对象），可以得到一个相似的层次结构，SV类在使用前都需例化</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">SV</th>
<th style="text-align:left">简介</th>
<th style="text-align:left">对应Verilog</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类<code>class</code></td>
<td style="text-align:left">包含变量和子程序的基本构建块</td>
<td style="text-align:left">模块<code>module</code></td>
</tr>
<tr>
<td style="text-align:center">对象<code>object</code></td>
<td style="text-align:left">类的实例化</td>
<td style="text-align:left">模块实例化</td>
</tr>
<tr>
<td style="text-align:center">句柄<code>handle</code></td>
<td style="text-align:left">指向对象的指针</td>
<td style="text-align:left">``top.u_t.func/task/variable`</td>
</tr>
<tr>
<td style="text-align:center">属性Property</td>
<td style="text-align:left">存储数据的成员变量</td>
<td style="text-align:left"><code>reg</code>或<code>wire</code></td>
</tr>
<tr>
<td style="text-align:center">方法method</td>
<td style="text-align:left">操作变量的子程序</td>
<td style="text-align:left">任务和函数</td>
</tr>
<tr>
<td style="text-align:center">原型prototype</td>
<td style="text-align:left"><code>extern</code>方法名和参数</td>
<td style="text-align:left">不支持</td>
</tr>
</tbody>
</table>
<h1 id="类">类</h1>
<h2 id="定义">定义</h2>
<ul>
<li>类是对象的模板，类中的成员变量用来保存数据，而子程序用来控制这些数值
<ul>
<li>下例为一个通用事务的类，属性：地址、校验和、存储值的数组；方法：显示地址、计算数据校验和</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> display();</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Transaction: %h&quot;</span>, addr);</span><br><span class="line">    <span class="keyword">endfunction</span> : display  <span class="comment">// 标记label</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> calc_csm();</span><br><span class="line">        csm = addr ^ data<span class="variable">.xor</span>;</span><br><span class="line">    <span class="keyword">endfunction</span> : calc_csm</span><br><span class="line">    </span><br><span class="line"><span class="keyword">endclass</span> : Transactoin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>习惯性地使用标记，在有很多嵌套块的复杂代码中用处很大，可以很好地配对<code>end</code>、<code>endtask</code>、<code>endfunction</code>、<code>endclass</code></p>
</blockquote>
<h2 id="包">包</h2>
<ul>
<li>类应在<code>program</code>或<code>module</code>，或其外的<code>package</code>中定义</li>
<li>在<a href="../SV%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">SV数据类型</a>这篇文章中也曾介绍过包的概念，当时是用于封装常数和结构体，包还能用于封装类
<ul>
<li>项目文件较多时，可以使用包<code>package</code>将一组相关的类和类型定义捆绑在一起</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 文件abc.svh</span></span><br><span class="line"><span class="keyword">package</span> abc;      <span class="comment">// $root.abc绝对路径</span></span><br><span class="line">    <span class="keyword">class</span> Transaction;</span><br><span class="line">        <span class="keyword">int</span> pd;   <span class="comment">// $root.abc.Transaction.pd</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line"><span class="keyword">endpackage</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试文件</span></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line">    <span class="keyword">import</span> abc::*；<span class="comment">// 导入包</span></span><br><span class="line">    <span class="keyword">int</span> d;         <span class="comment">// $root.test.d</span></span><br><span class="line">    Transaction tr;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">class</span> xyz;</span><br><span class="line">        <span class="keyword">int</span> l;     <span class="comment">// $root.test.xyz.l</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line">    </span><br><span class="line">    ...            <span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<h2 id="方法">方法</h2>
<ul>
<li>类中的程序也称为方法，即类的作用域内定义的内部<code>task</code>和<code>function</code></li>
<li>类中的方法默认使用自动存储，即隐式<code>automatic</code></li>
</ul>
<h3 id="原型方法">原型方法</h3>
<ul>
<li>为了提高代码可读性，可以在类外定义方法
<ul>
<li>将方法的原型定义（方法名和参数）放在类的内部</li>
<li>方法的程序体放在类的后面定义</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> PCI_Tran;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, data;</span><br><span class="line">    <span class="keyword">extern</span> <span class="keyword">function</span> <span class="keyword">void</span> display();</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">        </span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> PCI_Tran::display();</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;@0t: PCI: addr = %h, data = %h&quot;</span>, <span class="built_in">$time</span>, addr, data);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h3 id="静态方法">静态方法</h3>
<ul>
<li>类中的自动变量必须通过类的实例（对象）访问</li>
<li>类的静态变量和静态方法属于类的全局资源，而非某个具体对象实例
<ul>
<li>可以直接通过类名访问<code>类名::静态成员</code>，无需实例化对象</li>
<li>类作用域操作符<code>::</code>，用于明确指定访问类作用域中的成员</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Counter;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> total_count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">function</span> <span class="keyword">void</span> display_statics();</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;display statics test&quot;</span>);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">      Counter::total_count = <span class="number">100</span>;                            <span class="comment">// 修改静态变量</span></span><br><span class="line">      <span class="built_in">$display</span>(<span class="string">&quot;total_count：%0d&quot;</span>, Counter::total_count);    <span class="comment">// 输出：100</span></span><br><span class="line">      Transaction::display_static();                         <span class="comment">// 调用静态方法</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h1 id="对象">对象</h1>
<ul>
<li>若将类视为描述房子结构的蓝图，而对象则是一幢可以实际居住的房子，房子的地址就是句柄</li>
</ul>
<h2 id="构造">构造</h2>
<ul>
<li>创建类的实例的过程被称为实例化，实例化后的类称为对象，<code>new()</code>函数被称为构造函数（Constructor）</li>
<li><code>new()</code>为对象分配空间，并初始化变量，构造完成后，返回保存对象的地址，即句柄
<ul>
<li>创建对象时使用的是<code>new()</code>，而在创建<a href="../SV%E6%95%B0%E7%BB%84%E9%98%9F%E5%88%97">动态数组</a>大小时使用的是<code>new[]</code>，注意区分</li>
</ul>
</li>
</ul>
<h3 id="参数化构造">参数化构造</h3>
<ul>
<li>使用参数化<code>new()</code>可以实现自定义初始值，否则默认初始化二值变量为0、四值变量为X</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">31</span>:<span class="number">0</span>] a = <span class="number">3</span>);</span><br><span class="line">        addr = a;</span><br><span class="line">        data = `&#123;<span class="keyword">default</span>:<span class="number">5</span>&#125;; <span class="comment">// 所有元素均为5</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Transaction tr;         <span class="comment">// 声明一个对象的句柄</span></span><br><span class="line">    tr = <span class="keyword">new</span>(<span class="variable">.a</span>(<span class="number">10</span>));       <span class="comment">// 构造对象，并返回句柄</span></span><br><span class="line">    <span class="comment">// 使用.a(10)则addr指定10，若未使用则addr默认3</span></span><br><span class="line">    <span class="comment">// data指定固定值，csm被初始化未默认值x</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当方法的参数名或局部变量与类的成员变量同名时，使用<code>this</code>可以明确指定要访问的是当前对象的成员变量</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass;</span><br><span class="line">  <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data;  <span class="comment">// 成员变量</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 构造函数：参数名与成员变量同名</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data);</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.data</span> = data; <span class="comment">// 用 &#x27;this&#x27; 指定左侧是成员变量</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法：局部变量与成员同名</span></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> set_data(<span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data);</span><br><span class="line">    <span class="keyword">this</span><span class="variable">.data</span> = data; <span class="comment">// 明确赋值给成员变量</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] get_data();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span><span class="variable">.data</span>; <span class="comment">// 显式返回成员变量（非必需，但清晰）</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">MyClass mc;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    mc = <span class="keyword">new</span>(<span class="variable">.data</span>(<span class="number">123</span>));</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="访问">访问</h2>
<h3 id="直接访问">直接访问</h3>
<ul>
<li>通过对象句柄直接访问成员变量或方法
<ul>
<li>本质是直接操作对象内部数据，依赖成员变量的公有访问权限</li>
<li>SV中所有成员都是公有的，除非标记为私有<code>local</code>或<code>protected</code></li>
</ul>
</li>
<li>直接访问破坏封装性，适用于需要在测试平台的地方访问时
<ul>
<li>外部代码需知晓内部数据结构，无法限制输入合法性，可能导致数据异常</li>
<li>一旦内部变量重命名或变更类型，外界所有直接访问的代码都需要同步更改</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Counter;</span><br><span class="line">  <span class="keyword">int</span> count; <span class="comment">// 公有成员，允许直接访问</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Counter c = <span class="keyword">new</span>();</span><br><span class="line">    c<span class="variable">.count</span> = <span class="number">10</span>; <span class="comment">// 合法赋值</span></span><br><span class="line">    c<span class="variable">.count</span> = -<span class="number">5</span>; <span class="comment">// 直接赋负值，破坏数据合法性（无保护）</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Count: %0d&quot;</span>, c<span class="variable">.count</span>); <span class="comment">// 输出 -5（错误状态）</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="访问函数">访问函数</h3>
<ul>
<li>通过类的访问函数间接访问内部数据
<ul>
<li>本质是通过接口方法控制数据交互，内部数据通常被声明为<code>local</code>或<code>protected</code></li>
</ul>
</li>
<li>访问函数具备更好的安全性和可维护性，但同样也会使测试平台变得更大更复杂
<ul>
<li>可在访问函数内添加验证逻辑，确保数据合法性，同时实现日志功能，这在直接访问中是无法实现的</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Counter;</span><br><span class="line">  <span class="keyword">local</span> <span class="keyword">int</span> count; <span class="comment">// 私有成员，默认类型，外部不可直接访问</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">int</span> get_count(); <span class="comment">// 读取count（getter），可附加日志</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;[LOG] get_count: %0d&quot;</span>, count); <span class="comment">// 记录访问日志</span></span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">void</span> put_count(<span class="keyword">int</span> val); <span class="comment">// 修改count（putter），验证输入合法性</span></span><br><span class="line">    <span class="keyword">if</span> (val &lt; <span class="number">0</span>) <span class="keyword">begin</span> <span class="comment">// 检查输入合法性</span></span><br><span class="line">      <span class="built_in">$error</span>(<span class="string">&quot;[ERROR] Invalid count: %0d (must be non-negative)&quot;</span>, val);</span><br><span class="line">      <span class="keyword">return</span>; <span class="comment">// 拒绝非法值</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    count = val;</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;[LOG] put_count: %0d&quot;</span>, count); <span class="comment">// 记录修改日志</span></span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> test;</span><br><span class="line">  <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Counter c = <span class="keyword">new</span>();</span><br><span class="line">    c<span class="variable">.put_count</span>(<span class="number">10</span>); <span class="comment">// 合法赋值，日志：[LOG] put_count: 10</span></span><br><span class="line">    c<span class="variable">.put_count</span>(-<span class="number">5</span>); <span class="comment">// 非法赋值，报错：[ERROR] Invalid count: -5...</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Current count: %0d&quot;</span>, c<span class="variable">.get_count</span>()); <span class="comment">// 日志：[LOG] get_count: 10，输出：10</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h2 id="方法-v2">方法</h2>
<h3 id="对象句柄">对象句柄</h3>
<ul>
<li>句柄本质是对象的引用，存储的是对象在内存中的地址
<ul>
<li>通过修改句柄的值，可以让同一各句柄在仿真过程中先后指向不用的对象示例</li>
<li>而在Verilog中名字和内存是静态捆绑在一起的</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">Transaction t1, t2; <span class="comment">// 声明两个句柄</span></span><br><span class="line">t1 = <span class="keyword">new</span>();         <span class="comment">// 构造第一个对象，并返回内存地址</span></span><br><span class="line">t2 = t1;            <span class="comment">// 复制内存地址，使t1和t2都指向第一个对象</span></span><br><span class="line">t1 = <span class="keyword">new</span>();         <span class="comment">// 构造第二个对象，并返回内存地址，此时t1指向第二个对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当没有任何句柄指向一个对象时，SV会自动回收其内存，避免了忘记手动释放对象时可能发生的内存泄露
<ul>
<li>若对象包含从一个<a href="../SV%E7%BA%BF%E7%A8%8B">线程</a>派生出的程序，只要线程仍在运行，对象的空间就不会释放</li>
<li>同样，被线程所使用的对象在该线程结束之前也不会解除分配</li>
</ul>
</li>
</ul>
<h3 id="静态句柄">静态句柄</h3>
<ul>
<li>当类中的变量声明和方法原型过多时，可以将类分成几个更小、相关的类</li>
<li>当类的每个实例都需要从同一个对象获取信息时，使用静态句柄可以避免内存的浪费
<ul>
<li>注意使用类中类时，一定要先例化，否则其句柄是<code>null</code></li>
<li>若类中类在被包含类之后定义，需要使用<code>typedef</code>进行前向声明</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">class</span> Config;  <span class="comment">// 当Config在Transaction之后定义，需要前向声明</span></span><br><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">static</span> Config cfg; <span class="comment">// 使用静态存储的句柄，类中类</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Config;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line">    </span><br><span class="line">Config cfg;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    cfg = <span class="keyword">new</span>(<span class="variable">.num_trans</span>(<span class="number">42</span>));     <span class="comment">// 例化对象，通过参数名传递初始值</span></span><br><span class="line">    Transaction::cfg = cfg;        <span class="comment">// 将已例化对象的句柄传递给类中类</span></span><br><span class="line">    <span class="comment">// 上述两行等同于Transaction::cfg = new(.(num_trans(42)));</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="传递句柄">传递句柄</h3>
<ul>
<li>将句柄传递给方法，传递的是对象的句柄而非对象本身</li>
</ul>
<p><img src="/images/image-20250811144144482.png" alt="image-20250811144144482"></p>
<ul>
<li>被传递句柄的方法，可以修改共享对象，但不能修改原句柄的指向</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> transmit(<span class="keyword">input</span> Transaction t); <span class="comment">// 形参t是generator中的t的副本（按值传递）</span></span><br><span class="line">    t<span class="variable">.addr</span> = <span class="number">100</span>; <span class="comment">// 修改共享对象的addr，t.addr会变为100</span></span><br><span class="line">    t = <span class="keyword">new</span>();    <span class="comment">// 修改句柄t本身，让transmit中的t指向新对象，generator中的t仍指向原对象</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当所传递的句柄使用<code>ref</code>修饰时，被传递句柄的方法修改句柄，可以改变原句柄的指向
<ul>
<li><code>ref</code>让形参与实参“绑定”为同一变量</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> create(<span class="keyword">ref</span> Transaction tr);</span><br><span class="line">    tr = <span class="keyword">new</span>();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">Transaction t;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span> </span><br><span class="line">    create(t);           <span class="comment">// 在方法中创建一个transaction</span></span><br><span class="line">    <span class="built_in">$display</span>(t<span class="variable">.addr</span>);    <span class="comment">// 若无ref，则 t = null，未改变原句柄的指向</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="句柄数组">句柄数组</h3>
<ul>
<li>在搭建测试平台时，需要保存并引用许多对象，可以创建句柄数组，数组的每个元素指向一个对象</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> generator();</span><br><span class="line">    Transaction tarray[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">foreach</span> (tarray[i]) <span class="keyword">begin</span></span><br><span class="line">        tarray[i] = <span class="keyword">new</span>();    <span class="comment">// 创建每个对象</span></span><br><span class="line">        transmit(tarray[i]);</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<h2 id="复制">复制</h2>
<ul>
<li>复制一个对象，以防止被传递句柄的方法修改原始对象的值</li>
</ul>
<h3 id="浅层复制">浅层复制</h3>
<ul>
<li>使用<code>new</code>操作符复制一个对象
<ul>
<li>创建一个新的对象，并且复制现有对象的所有变量</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;In %m&quot;</span>);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction src, dst;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    src = <span class="keyword">new</span>();   <span class="comment">// 创建第一个对象</span></span><br><span class="line">    dst = <span class="keyword">new</span> src; <span class="comment">// 使用new操作符进行复制</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用<code>new</code>进行复制时，若类中包含一个指向另一个类的句柄，则只会复制句柄的值
<ul>
<li>若对复制后的对象中的句柄进行操作，也会影响原型对象中的句柄所指向的对象</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Statistics;</span><br><span class="line">    <span class="keyword">time</span> startT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> start();</span><br><span class="line">        starrT = <span class="built_in">$time</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Statistics stats;              <span class="comment">// 指向另一个对象的句柄</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();                <span class="comment">// new复制时，构造不会再次执行，见下图中的id</span></span><br><span class="line">        stats = <span class="keyword">new</span>();             <span class="comment">// 构造一个新的Statistics对象</span></span><br><span class="line">        id = count++;              <span class="comment">// 每构造一个对象都有一个唯一的id</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction src, dst;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    src = <span class="keyword">new</span>();</span><br><span class="line">    src<span class="variable">.stats</span><span class="variable">.startT</span> = <span class="number">42</span>;</span><br><span class="line">    dst = <span class="keyword">new</span> src;                    <span class="comment">// 复制类中另一个对象句柄的值</span></span><br><span class="line">    dst<span class="variable">.stats</span><span class="variable">.startT</span> = <span class="number">96</span>;            <span class="comment">// 由于复制了同一个句柄的值，会同时改变dst和src中的stats</span></span><br><span class="line">    <span class="built_in">$display</span>(src<span class="variable">.stats</span><span class="variable">.startT</span>);       <span class="comment">// &quot;96&quot;而非&quot;42&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20250811170922501.png" alt="image-20250811170922501"></p>
<ul>
<li>若要复制一个不包含另一个对象句柄的简单类，编写简单的自定义<code>copy()</code>函数也能起到和使用<code>new</code>一样的效果</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];  <span class="comment">// 不包含指向另一个对象的句柄</span></span><br><span class="line">    <span class="keyword">function</span> Transaction copy();    <span class="comment">// 创建独立的对象那个副本</span></span><br><span class="line">        copy = <span class="keyword">new</span>();               <span class="comment">// 每次调用copy()时构造目标对象</span></span><br><span class="line">        copy<span class="variable">.addr</span> = addr;           <span class="comment">// 填入自定义数值</span></span><br><span class="line">        copy<span class="variable">.csm</span> = csm;</span><br><span class="line">        copy<span class="variable">.data</span> = data;           <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction src, dst;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    src = <span class="keyword">new</span>();</span><br><span class="line">    dst = src<span class="variable">.copy</span>();</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="深层复制">深层复制</h3>
<ul>
<li>对于并非简单的类，需要进行深层复制
<ul>
<li>通过调用类所包含的所有对象的<code>copy</code>函数</li>
<li>在<code>copy()</code>函数中构造目标对象，避免出现只复制句柄值得情况</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Statistics;</span><br><span class="line">    <span class="keyword">time</span> startT;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> start();</span><br><span class="line">        starrT = <span class="built_in">$time</span>;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> Statistics copy();</span><br><span class="line">        copy = <span class="keyword">new</span>();             <span class="comment">// 每次调用copy()时构造目标对象</span></span><br><span class="line">        copy<span class="variable">.startT</span> = startT;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr, csm, data[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    Statistics stats;              <span class="comment">// 指向另一个对象的句柄</span></span><br><span class="line">    <span class="keyword">int</span> id;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        stats = <span class="keyword">new</span>();</span><br><span class="line">        id = count++;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> Transaction copy();    <span class="comment">// 创建独立的对象那个副本</span></span><br><span class="line">        copy = <span class="keyword">new</span>();               <span class="comment">// 创建目标对象</span></span><br><span class="line">        copy<span class="variable">.addr</span> = addr;           <span class="comment">// 填入自定义数值</span></span><br><span class="line">        copy<span class="variable">.csm</span> = csm;</span><br><span class="line">        copy<span class="variable">.data</span> = data;</span><br><span class="line">        copy<span class="variable">.stats</span> = stats<span class="variable">.copy</span>();  <span class="comment">// 调用Statics::copy函数</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction src, dst;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    src = <span class="keyword">new</span>();</span><br><span class="line">    src<span class="variable">.stats</span><span class="variable">.startT</span> = <span class="number">42</span>;</span><br><span class="line">    dst = src<span class="variable">.copy</span>();                 <span class="comment">// 深层复制src</span></span><br><span class="line">    dst<span class="variable">.stats</span><span class="variable">.startT</span> = <span class="number">96</span>;            <span class="comment">// 仅改变dst的stats值</span></span><br><span class="line">    <span class="built_in">$display</span>(src<span class="variable">.stats</span><span class="variable">.startT</span>);       <span class="comment">// &quot;42&quot;</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p><img src="/images/image-20250811173731432.png" alt="image-20250811173731432"></p>
<blockquote>
<p>UVM数据宏会自动创建复制函数，无需手动编写它们。手动创建这些函数在添加变量时非常出错</p>
</blockquote>
]]></content>
      <categories>
        <category>LNotes</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>sv</tag>
      </tags>
  </entry>
  <entry>
    <title>SV线程</title>
    <url>/SV%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<h1 id="线程的使用">线程的使用</h1>
<h2 id="定义特性">定义特性</h2>
<ul>
<li>线程是独立运行的程序单元，线程（thread）与进程（process）经常互换使用</li>
<li>每个<code>initial</code>或<code>always</code>过程块均派生一个独立线程，仿真0时刻开始执行
<ul>
<li><code>initial</code>及显式线程可主动结束</li>
<li><code>always</code>线程持续监控信号</li>
</ul>
</li>
<li>父线程可衍生多个子线程，如<code>fork</code>内嵌多个子块
<ul>
<li><code>fork-join</code>结构可显式创建并行子线程，但必须等所有子线程执行完后才可进行后续的处理</li>
<li><code>begin-end</code>结构以顺序结构执行，可以用于过程块<code>initial</code>中，或用作<code>fork-join</code>中的一个顺序子线程</li>
</ul>
</li>
</ul>
<h2 id="并行线程">并行线程</h2>
<p><img src="/images/image-20250728173027785.png" alt="image-20250728173027785"></p>
<ul>
<li><code>fork-join</code>：所有子线程结束才继续后续代码
<ul>
<li>标准Verilog语句，适用于需要等待所有并发任务完成的场景</li>
</ul>
</li>
<li><code>fork-join_any</code>：任一子线程结束即可继续后续代码
<ul>
<li>SV引入的创建线程新方法，适用于等待首个任务响应，如超时控制等</li>
</ul>
</li>
<li><code>fork-join_none</code>：立即继续主线程，子线程后台并行
<ul>
<li>SV引入的创建线程新方法，适用于启动异步任务，如监测信号等</li>
</ul>
</li>
<li><code>wait fork;</code>语句放在<code>fork-join</code>及其变体后，用于等待所有子线程结束</li>
</ul>
<h2 id="动态线程">动态线程</h2>
<ul>
<li>动态线程是在<strong>运行时</strong>通过显示语法（<code>fork-join</code>及其变体）创建的子线程，而<strong>非静态编译时</strong>定义的线程（<code>always</code>、<code>initial</code>、<code>fork-join</code>）
<ul>
<li>允许类、任务或函数内部生成子线程，实现子线程与父线程并发运行</li>
<li>若线程使用<code>automatic</code>存储类，变量在每次调用时独立分配内存，避免多线竞争</li>
<li>子线程在启动后独立运行，可自动结束或通过同步机制（事件<code>event</code>、旗语<code>semaphore</code>、信箱<code>mailbox</code>）控制终止</li>
<li>常用于测试平台的事务处理、验证场景的并行激励生成等</li>
</ul>
</li>
<li>下例中，测试平台产生随机事务并发送到被测设计中，在等待被测设计回复的过程中，同时也不停止随机数据的产生</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test (bus_ifc<span class="variable">.TB</span> bus);</span><br><span class="line">    <span class="comment">//省略接口代码</span></span><br><span class="line">    <span class="comment">//当check_trans被调用时，将产生一个线程用来检测总线来获取匹配的事务数据</span></span><br><span class="line">    <span class="keyword">task</span> check_trans(<span class="keyword">input</span> Transaction tr);</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                <span class="keyword">wait</span> (bus<span class="variable">.cb</span><span class="variable">.data</span> == tr<span class="variable">.data</span>);</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;@%0t: data match %d&quot;</span>, <span class="built_in">$time</span>, tr<span class="variable">.data</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join_none</span>             <span class="comment">//不阻塞的并发线程</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    </span><br><span class="line">    Transaction tr;           <span class="comment">// 声明事务类型</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">repeat</span> (<span class="number">10</span>) <span class="keyword">begin</span></span><br><span class="line">            tr = <span class="keyword">new</span>();       <span class="comment">//创建一个随机事务</span></span><br><span class="line">            `SV_RAND_CHECK(tr<span class="variable">.randomize</span>());</span><br><span class="line">            transmit(tr);     <span class="comment">//把事务发送到被测设计中</span></span><br><span class="line">            check_trans(tr);  <span class="comment">//并行等待被测设计回复</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">100</span>;</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<h2 id="类的线程">类的线程</h2>
<ul>
<li>在类中创建线程，要求线程控制权与任务逻辑分离
<ul>
<li>类内线程不应该在父类中启动，而是在任务<code>run</code>里产生，受到到子类控制</li>
<li>构造函数<code>new()</code>只用来对数值进行初始化，不启动任何线程</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Gen_drive;             <span class="comment">//带任务run的发生器/驱动器</span></span><br><span class="line">    <span class="keyword">task</span> run (<span class="keyword">input</span> <span class="keyword">int</span> n);  <span class="comment">//N个数据包的事务处理器</span></span><br><span class="line">        Packet p;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">repeat</span> (n) <span class="keyword">begin</span> <span class="comment">//顺序重复n次代码块</span></span><br><span class="line">                `SV_RAND_CHECK(p<span class="variable">.randomize</span>());</span><br><span class="line">                transmit(p);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join_none</span>            <span class="comment">//使用fork-join_none避免repeat(n)阻塞run()</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">task</span> transmit(<span class="keyword">input</span> Packet p);</span><br><span class="line">        ...</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Gen_drive gen;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    gen = <span class="keyword">new</span>();               <span class="comment">//调用构造函数，完成初始化</span></span><br><span class="line">    gen<span class="variable">.run</span>(<span class="number">10</span>);               <span class="comment">//启动类内线程</span></span><br><span class="line">    ...                        <span class="comment">//启动检验、监测和其他线程</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="线程的停止">线程的停止</h1>
<ul>
<li>在SV中，停止线程主要通过<code>disable</code>语句实现，避免使用暴力终止，如使用过时的<code>stop()</code></li>
</ul>
<h2 id="停止内部线程">停止内部线程</h2>
<ul>
<li>在<code>fork-join</code>块内使用<code>disable fork;</code>停止所有子进程
<ul>
<li>使用<code>fork-join</code>把目标代码包围起来以限制<code>disable fork</code>语句的作用范围</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    check_trans(tr0);             <span class="comment">// 线程0，使用了动态线程中定义的一个任务</span></span><br><span class="line">    <span class="keyword">fork</span>                          <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            check_trans(tr1);     <span class="comment">// 线程1.1，父线程为线程1</span></span><br><span class="line">            check_trans(tr2);     <span class="comment">// 线程1.2</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">123</span> <span class="keyword">disable</span> <span class="keyword">fork</span>;        <span class="comment">// 除线程0外其余线程全部停止</span></span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="停止指定线程">停止指定线程</h2>
<ul>
<li>为线程指定标签，使用带标签的<code>disable</code>语句</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    check_trans(tr0);             <span class="comment">// 线程0</span></span><br><span class="line">    <span class="keyword">fork</span>                          <span class="comment">// 线程1</span></span><br><span class="line">        <span class="keyword">begin</span> : thread1</span><br><span class="line">            check_trans(tr1);     <span class="comment">// 线程1.1</span></span><br><span class="line">            check_trans(tr2);     <span class="comment">// 线程1.2</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        #<span class="number">123</span> <span class="keyword">disable</span> thread1;     <span class="comment">// 保留线程0</span></span><br><span class="line">    <span class="keyword">join</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>停止指定<code>fork-join</code>块中所有线程
<ul>
<li>在下例中，如果正确的总线来得足够早，则等<code>wait</code>结构先完成，<code>fork-join_any</code>得以执行，之后的<code>disable</code>结束剩余的线程</li>
<li>如果正确的总线在<code>TIME_OUT</code>时延完成时没有到来，则会打印错误警告的信息，<code>fork-join_any</code>被执行，之后<code>disalbe</code>结束<code>wait</code>线程</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">parameter</span> TIME_OUT = <span class="number">1000</span>ns;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> check_trans(<span class="keyword">input</span> Transaction tr);</span><br><span class="line">    <span class="keyword">fork</span></span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="keyword">fork</span> : timeout_block</span><br><span class="line">                <span class="keyword">begin</span>                             <span class="comment">// thread1 in timeout_block</span></span><br><span class="line">                    <span class="keyword">wait</span> (bus<span class="variable">.cb</span><span class="variable">.data</span> == tr<span class="variable">.data</span>);</span><br><span class="line">                    <span class="built_in">$display</span>(<span class="string">&quot;@%0t: data match %d&quot;</span>, <span class="built_in">$time</span>, tr<span class="variable">.data</span>);</span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">                #TIME_OUT <span class="built_in">$display</span>(<span class="string">&quot;@%0t: Error: timeout&quot;</span>, <span class="built_in">$time</span>); <span class="comment">// thread2</span></span><br><span class="line">            <span class="keyword">join_any</span></span><br><span class="line">            <span class="keyword">disable</span> timeout_block;</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join_none</span>   <span class="comment">// 产生非阻塞的线程</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<h2 id="停止任务线程">停止任务线程</h2>
<ul>
<li>当从任务块内部停止该块时，将会停止所有由该任务启动的线程
<ul>
<li>使用<code>disable</code>标签语句将停止所有所有使用这段代码的线程，不仅仅是当前线程</li>
</ul>
</li>
<li>在下例中，任务<code>wait_for_time_out</code>被调用三次，从而产生了三个线程
<ul>
<li>线程0在<code>#2ns</code>延时后禁止了该任务，三个线程都启动了，但最终都停止了</li>
<li>如果这个任务位于多次实例化的驱动器类中，则其中的<code>disable</code>标签语句将停止所有块</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> wait_for_time_out (<span class="keyword">input</span> <span class="keyword">int</span> id);</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                #<span class="number">2</span>ns;</span><br><span class="line">                <span class="built_in">$display</span>(<span class="string">&quot;@%0t: disable wait_for_time_out&quot;</span>, <span class="built_in">$time</span>);</span><br><span class="line">                disabel wait_for_time_out;</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">fork</span> : just_a_little</span><br><span class="line">        <span class="keyword">begin</span></span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;@%0t: %m: %0d entering thread&quot;</span>, <span class="built_in">$time</span>, id);</span><br><span class="line">            #TIME_OUT;</span><br><span class="line">            <span class="built_in">$display</span>(<span class="string">&quot;@%0t: %m: %0d done&quot;</span>, <span class="built_in">$time</span>, id); <span class="comment">// %m表示输出调用此语句的模块的层次路径</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">join_none</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<h1 id="线程间通信">线程间通信</h1>
<h2 id="IPC概念">IPC概念</h2>
<ul>
<li>每个线程都会和相邻的线程通信
<ul>
<li>环境类需要知道发生器什么时候完成任务，以便及时终止测试平台还在运行的线程</li>
<li>如下图测试平台环境中的发生器把激励传递给代理</li>
</ul>
</li>
</ul>
<p><img src="/images/image-20250724095858230.png" alt="image-20250724095858230"></p>
<ul>
<li>所有数据交换和控制的同步被称为线程间的通信（Inter-Process Communication, IPC），本章介绍以下三种
<ul>
<li>事件：用于控制多线程间的同步</li>
<li>旗语：用于控制多线程对共享资源的访问</li>
<li>信箱：用于控制多线程间的信息传递或者线程间通信</li>
</ul>
</li>
</ul>
<h2 id="事件">事件</h2>
<h3 id="事件操作">事件操作</h3>
<ul>
<li>触发事件（Trigger）：通过<code>-&gt;</code>操作符通知事件发生</li>
<li>等待事件（Wait）：通过阻塞线程知道事件被触发
<ul>
<li>边沿敏感型：<code>@</code>，检测事件的上升沿，从无触发到触发</li>
<li>电平敏感型：SV引入<code>wait(event_example.triggered)</code>，检测事件是否已经被触发过</li>
</ul>
</li>
</ul>
<h3 id="事件竞争">事件竞争</h3>
<ul>
<li>在同一仿真时间步内，多个线程因时间等待与触发顺序不确定而发生的竞争状态，导致在不同的仿真器中运行的结果可能不同
<ul>
<li>下例中，先执行B？A永远阻塞</li>
<li>先执行A？A需要捕获事件才继续</li>
<li>同时执行？取决于仿真器</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">event</span> my_event;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>         <span class="comment">// 进程A</span></span><br><span class="line">  @my_event;          <span class="comment">// 事件等待</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Process A activated&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span>          <span class="comment">// 进程B</span></span><br><span class="line">  -&gt; my_event;         <span class="comment">// 事件触发</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Process B triggered&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>若在循环中使用<code>wait(handshake.triggered)</code>，需确保在<strong>下次等待所处的仿真时间步不能与本次等待的相同</strong>，否则代码进入一个零时延循环
<ul>
<li>若时间步不变，<code>.triggered</code>不会重置，<code>wait</code>再次立即通过，形成无线循环</li>
<li>可以使用边沿敏感型等待事件，避免<code>.triggered</code>不重置的问题</li>
<li>或使用<code>#0</code>使进程挂起指导指定延时结束，当恢复执行，时间已推进</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">forever</span> <span class="keyword">begin</span> <span class="comment">// 这是一个零时延循环，造成仿真的不确定</span></span><br><span class="line">    <span class="keyword">wait</span>(handshake<span class="variable">.triggered</span>);</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Received next event&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">forever</span> <span class="keyword">begin</span> <span class="comment">// 使用边沿敏感或时延+电平敏感避免零时延循环</span></span><br><span class="line">    @handshake;</span><br><span class="line">    <span class="comment">// #0 wait(handshake.triggered);</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Received next event&quot;</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="事件传递">事件传递</h3>
<ul>
<li>在SV中，事件作为同步对象的句柄，可以传递给子程序
<ul>
<li>允许在对象间共享事件，不用把事件定义成全局的，最常见的方式是把事件传递到一个对象的构造器中</li>
<li>下例中，一个事件被事务处理器用来作为其执行完毕的标志信号</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line">    <span class="keyword">class</span> generator;</span><br><span class="line">        <span class="keyword">event</span> done;</span><br><span class="line">        <span class="keyword">function</span> <span class="keyword">new</span> (<span class="keyword">input</span> <span class="keyword">event</span> done);   <span class="comment">// 从测试平台传来事件</span></span><br><span class="line">            <span class="keyword">this</span><span class="variable">.done</span> = done;              <span class="comment">// 同步句柄：测试平台中的gen_done与类中的done同步</span></span><br><span class="line">        <span class="keyword">endfunction</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">task</span> run();</span><br><span class="line">            <span class="keyword">fork</span></span><br><span class="line">                <span class="keyword">begin</span></span><br><span class="line">                    ...                     <span class="comment">// 创建事务</span></span><br><span class="line">                    -&gt; done;                <span class="comment">// 告知测试程序任务已完成</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">join_none</span></span><br><span class="line">        <span class="keyword">endtask</span></span><br><span class="line">    <span class="keyword">endclass</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">event</span> gen_done;</span><br><span class="line">    generator gen;</span><br><span class="line">    <span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">        gen = <span class="keyword">new</span>(gen_done);                 <span class="comment">// 测试程序实例化</span></span><br><span class="line">        gen<span class="variable">.run</span>();                           <span class="comment">// 运行事务处理器</span></span><br><span class="line">        <span class="keyword">wait</span>(gen_done<span class="variable">.triggered</span>);            <span class="comment">// 等待任务结束</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<h3 id="多事件等待">多事件等待</h3>
<ul>
<li>上例中只有单个发生器释放单个时间，如果测试环境类有N个发生器，必须等待多个子线程完成</li>
<li>传递事件句柄等待多事件
<ul>
<li>使用<code>wait fork</code>来等待所有子线程约束</li>
<li>也可以使用<code>wait_order(event1, event2)</code>来等待指定顺序的事件</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">event</span> done[N_GENERATORS];         <span class="comment">// 定义N个发生器的阻塞事件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (gen[i]) <span class="keyword">begin</span></span><br><span class="line">        gen[i] = <span class="keyword">new</span>(done[i]);    <span class="comment">// 创建N个发生器</span></span><br><span class="line">        gen[i]<span class="variable">.run</span>();             <span class="comment">// 发生器开始运行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (gen[i])</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">automatic</span> <span class="keyword">int</span> k = i;</span><br><span class="line">            <span class="keyword">wait</span> (done[k]<span class="variable">.trriggered</span>);</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wait</span> <span class="keyword">fork</span>;                     <span class="comment">// 等待所有触发事件完成</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>通过对触发事件进行计数来等待多个线程</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">event</span> done[N_GENERATORS];</span><br><span class="line"><span class="keyword">int</span> done_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (gen[i]) <span class="keyword">begin</span></span><br><span class="line">        gen[i] = <span class="keyword">new</span>(done[i]);       <span class="comment">// 创建N个发生器</span></span><br><span class="line">        gen[i]<span class="variable">.run</span>();                <span class="comment">// 发生器开始运行</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (gen[i])</span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">automatic</span> <span class="keyword">int</span> k = i;</span><br><span class="line">            done_count++;</span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wait</span> (done_count == N_GENERATORS); <span class="comment">// 等待触发</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用线程计数来等待多个线程
<ul>
<li>使用类作用域分辨操作符<code>::</code>：用于明确指定访问某个类作用域内的成员</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Generator;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> thread_count = <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">task</span> run();</span><br><span class="line">        thread_count++;         <span class="comment">// 启动另一个线程</span></span><br><span class="line">        <span class="keyword">fork</span></span><br><span class="line">            <span class="keyword">begin</span></span><br><span class="line">                ...             <span class="comment">// 实际事务代码</span></span><br><span class="line">                thread_count--;   <span class="comment">// 事务完成时，线程数目减一</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">join_none</span></span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Generator gen[N_GENERATORS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">foreach</span> (gen[i])</span><br><span class="line">        gen[i] = <span class="keyword">new</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">foreach</span> (gen[i])</span><br><span class="line">        gen[i]<span class="variable">.run</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">wait</span> (Generator::thead_count == <span class="number">0</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="旗语">旗语</h2>
<h3 id="基本特性">基本特性</h3>
<ul>
<li>作用：一种同步机制，用于控制多线程对共享资源的访问</li>
<li>类型：旗语<code>semaphore</code>是SV内置类，维护一个可用资源数量计数器</li>
</ul>
<h3 id="操作方法">操作方法</h3>
<ul>
<li>创建旗语：<code>semaphore sem = new(1);</code>
<ul>
<li>包含两步操作：声明旗语变量<code>semaphore sem;</code>，创建旗语并初始化计数器为1<code>sem = new(1);</code></li>
</ul>
</li>
<li>获取钥匙：<code>sem.get(1);</code>
<ul>
<li>进程访问共享资源前，通过<code>get()</code>获取钥匙，减少计数器，若钥匙不足则阻塞等待</li>
<li>多个阻塞线程以先进先出（FIFO）的方式排队</li>
</ul>
</li>
<li>归还钥匙：<code>sem.put(1);</code>
<ul>
<li>访问完成后，通过<code>put()</code>归还钥匙，增加计数器，允许其他进程获取</li>
<li>注意归还的钥匙可以比取出来的多</li>
</ul>
</li>
<li>尝试获取：<code>sem.try_get(1);</code>
<ul>
<li>尝试获取一把钥匙，成功返回<code>1</code>，失败返回<code>0</code>，非阻塞</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">semaphore sem = <span class="keyword">new</span>(<span class="number">1</span>); <span class="comment">// 创建含1把钥匙的信号量</span></span><br><span class="line">process_A: <span class="keyword">begin</span></span><br><span class="line">    sem<span class="variable">.get</span>(<span class="number">1</span>);         <span class="comment">// 获取钥匙</span></span><br><span class="line">    shared_var = ...;   <span class="comment">// 安全访问共享变量</span></span><br><span class="line">    sem<span class="variable">.put</span>(<span class="number">1</span>);         <span class="comment">// 归还钥匙</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">process_B: <span class="keyword">begin</span></span><br><span class="line">    sem<span class="variable">.get</span>(<span class="number">1</span>);         <span class="comment">// 若钥匙被占用，则阻塞等待</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="信箱">信箱</h2>
<p><img src="/images/image-20250804105625565.png" alt="image-20250804105625565"></p>
<h3 id="基本特性-v2">基本特性</h3>
<ul>
<li>作用：用于并发线程间的数据交换</li>
<li>类型：信箱<code>mailbox</code>是SV内置类，维护一个有界或无界的消息队列
<ul>
<li>有界：固定容量，满时阻塞；无界，理论上无限容量</li>
</ul>
</li>
</ul>
<h3 id="操作方法-v2">操作方法</h3>
<ul>
<li>创建信箱
<ul>
<li>声明参数化信箱，可以强制邮箱使用一种数据类型</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">mailbox mbx;   <span class="comment">// 声明信箱变量</span></span><br><span class="line">mbx = <span class="keyword">new</span>();   <span class="comment">// 创建无界信箱</span></span><br><span class="line">mbc = <span class="keyword">new</span>(<span class="number">10</span>); <span class="comment">// 创建有界信箱，容量为10</span></span><br><span class="line"></span><br><span class="line">mailbox <span class="variable">#(int) int_mbx = new()</span>;    <span class="comment">// 只能存放int类型的信箱</span></span><br><span class="line">mailbox <span class="variable">#(string) str_mbx = new()</span>; <span class="comment">// 只能存放string类型的信箱</span></span><br><span class="line">int_mbx<span class="variable">.put</span>(<span class="number">42</span>);</span><br><span class="line"><span class="comment">// int_mbx.put(&quot;hello&quot;);           // 编译错误，类型不匹配</span></span><br></pre></td></tr></table></figure>
<ul>
<li>放入数据：<code>mbx.put(data)</code>
<ul>
<li>生产方将<code>data</code>放入信箱，若信箱满则阻塞</li>
<li>数据可以是整数、任意宽度<code>logic</code>或句柄</li>
</ul>
</li>
<li>获取数据：<code>mbx.get(data)</code>
<ul>
<li>消费方从信箱获取数据到<code>data</code>变量，同时在信箱中移除，若信箱空则阻塞</li>
</ul>
</li>
<li>尝试放入：<code>mbx.try_put(data)</code>
<ul>
<li>尝试放入数据，成功返回1，信箱满返回0，非阻塞</li>
</ul>
</li>
<li>尝试获取：<code>mbx.try_get(data)</code>
<ul>
<li>尝试获取数据，成功返回1，信箱空返回0，非阻塞</li>
</ul>
</li>
<li>探视数据：<code>mbx.peek(data)</code>
<ul>
<li>探视信箱里的数据但不将其移除</li>
<li>允许接收方检查数据内容后再决定是否处理</li>
<li>允许同一数据可以被多个线程查看</li>
</ul>
</li>
<li>获取数量：<code>mbx.num()</code>
<ul>
<li>返回信箱中当前消息的数量</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">mailbox <span class="variable">#(int) mbx = new(5)</span>;    <span class="comment">// 容量为5的有界参数化信箱，指定存储整型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产者进程</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">10</span>; i++) <span class="keyword">begin</span></span><br><span class="line">    mbx<span class="variable">.put</span>(i);          <span class="comment">// 放入数据</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Produced: %0d&quot;</span>, i);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者进程</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">int</span> received;</span><br><span class="line">  <span class="keyword">forever</span> <span class="keyword">begin</span></span><br><span class="line">    mbx<span class="variable">.get</span>(received);   <span class="comment">// 获取数据</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;Consumed: %0d&quot;</span>, received);</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LNotes</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>sv</tag>
      </tags>
  </entry>
  <entry>
    <title>SV过程与子程序</title>
    <url>/SV%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%AD%90%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<h1 id="过程语句">过程语句</h1>
<h2 id="概念">概念</h2>
<ul>
<li><code>initial</code>语句
<ul>
<li>用于初始化行为建模，仅在仿真开始时执行一次</li>
</ul>
</li>
<li><code>always</code>语句
<ul>
<li>用于持续执行的行为建模，仿真过程中重复执行</li>
<li>需要明确列出敏感事件列表</li>
</ul>
</li>
<li>SV扩展了<code>always</code>块
<ul>
<li><code>always_comb</code>：自动推断组合逻辑敏感列表，避免遗漏信号</li>
<li><code>always_ff</code>：明确用于时序逻辑，需指定时钟和复位条件</li>
<li><code>always_latch</code>：专为锁存器设计，明确设计意图，提高可维护性</li>
</ul>
</li>
</ul>
<h2 id="赋值规则">赋值规则</h2>
<ul>
<li>阻塞赋值<code>=</code>
<ul>
<li>按代码顺序立即执行，适用于组合逻辑建模</li>
<li>执行时后续语句需等待当前赋值完成</li>
</ul>
</li>
<li>非阻塞赋值<code>&lt;=</code>
<ul>
<li>赋值操作并行执行，适用于时序逻辑</li>
<li>在时钟边沿捕获当前值，结束后统一更新结果，避免竞争风险</li>
</ul>
</li>
<li>限制
<ul>
<li>过程赋值的被赋值变量必须是寄存器类型（<code>reg</code>或<code>logic</code>），并且只能在过程块中使用</li>
<li>区别于连续赋值<code>assign</code>只能驱动线网类型</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> xor_comb(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> a, b,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> out</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_comb</span> <span class="keyword">begin</span></span><br><span class="line">        out = a ^ b;  <span class="comment">// 阻塞赋值，组合逻辑</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> d_latch(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> enable, d,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> q</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_latch</span> <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (enable) <span class="keyword">begin</span></span><br><span class="line">            q = d;  <span class="comment">// 当enable为高时，q锁存d的值</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">module</span> d_flipflop(</span><br><span class="line">    <span class="keyword">input</span> <span class="keyword">logic</span> clk, reset, d,</span><br><span class="line">    <span class="keyword">output</span> <span class="keyword">logic</span> q</span><br><span class="line">);</span><br><span class="line">    <span class="keyword">always_ff</span> @(<span class="keyword">posedge</span> clk <span class="keyword">or</span> <span class="keyword">posedge</span> reset) <span class="keyword">begin</span></span><br><span class="line">        <span class="keyword">if</span> (reset) <span class="keyword">begin</span></span><br><span class="line">            q &lt;= <span class="number">0</span>;  <span class="comment">// 复位时q置0</span></span><br><span class="line">        <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">            q &lt;= d;  <span class="comment">// 时钟上升沿时q更新为d</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h1 id="子程序">子程序</h1>
<h2 id="任务与函数">任务与函数</h2>
<ul>
<li>任务用于封装可包含时序控制的行为代码块
<ul>
<li>延时<code>#</code>、事件触发<code>@</code>、等待<code>wait</code></li>
</ul>
</li>
<li>无返回值，支持<code>input</code>、<code>output</code>、<code>inout</code>参数
<ul>
<li>无输入输出时空括号可省略</li>
<li>只有输入时，<code>input</code>可省略</li>
</ul>
</li>
<li><code>begin ... end</code>不再是必需的，但必须使用通用的输入类型<code>logic</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> send_data(<span class="keyword">input</span> <span class="keyword">logic</span> [<span class="number">7</span>:<span class="number">0</span>] data, <span class="keyword">output</span> <span class="keyword">bit</span> ack);</span><br><span class="line">   #<span class="number">10</span>;          <span class="comment">// 延时10个时间单位</span></span><br><span class="line">   ack = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<ul>
<li>函数用于纯计算或组合逻辑，无任何时序控制，执行时间为0</li>
<li>必须至少有一个输入参数，通过函数名返回单一值</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add(<span class="keyword">input</span> <span class="keyword">int</span> a, b);</span><br><span class="line">   <span class="keyword">return</span> a + b;  <span class="comment">// 直接返回计算结果</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h2 id="子程序参数">子程序参数</h2>
<h3 id="引用传参">引用传参</h3>
<ul>
<li>在SV中，参数的传递除了可以使用<code>input</code>、<code>output</code>、<code>inout</code>进行复制外，还可以使用引用的方式传参</li>
<li>核心：使用<code>ref</code>实现对变量的直接引用（类似指针）
<ul>
<li>避免大型数据（如结构体、数组）的复制开销，提升性能</li>
<li>子程序内部对ref参数的修改立即可见于外部调用者</li>
</ul>
</li>
<li>使用规则
<ul>
<li>只使用于变量，不支持线网类型</li>
<li>多个并发子程序通过<code>ref</code>访问同一变量时，可能导致数据竞争
<ul>
<li>为避免竞争，可以使用<a href="../SV%E7%BA%BF%E7%A8%8B">旗语或信箱</a>等方式进行同步或传递副本</li>
</ul>
</li>
<li>与<code>const</code>联合使用，声明可强制引用为只读，防止意外修改</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> print_sum(<span class="keyword">const</span> <span class="keyword">ref</span> <span class="keyword">int</span> arr[]);</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">foreach</span>(arr[i]) sum += arr[i];</span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Sum: %0d&quot;</span>, sum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h3 id="参数的缺省值">参数的缺省值</h3>
<ul>
<li>在声明函数时为部分或全部参数预设缺省值（默认值），当调用函数时，若未显示传入，则使用缺省值
<ul>
<li>使用-1或其他任何越界值作为缺省值，便于获知调用时是否有指定值</li>
</ul>
</li>
<li>显示指定参数名<code>.parameter_name(value)</code>
<ul>
<li>使用名字进行传参，允许直接关联参数名与值，而不依赖参数在模块定义中的声明顺序</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">void</span> print_csm(<span class="keyword">const</span> <span class="keyword">ref</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] a[],</span><br><span class="line">                                  <span class="keyword">input</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] low = <span class="number">0</span>,</span><br><span class="line">                                  <span class="keyword">input</span> <span class="keyword">int</span> high = -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] checksum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (high == -<span class="number">1</span> || hign &gt;= a<span class="variable">.size</span>())</span><br><span class="line">        high = a<span class="variable">.size</span>()-<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = low; i &lt;= high; i++)</span><br><span class="line">        checksum ^= a[i];</span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;The array checksum is %h&quot;</span>, checksum);</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">print_csm(a);        <span class="comment">//check a[0:size()-1]</span></span><br><span class="line">print_csm(a, <span class="number">2</span>, <span class="number">4</span>);  <span class="comment">//check a[2:4]</span></span><br><span class="line">print_csm(a, <span class="number">1</span>);     <span class="comment">//check a[1:size()-1]</span></span><br><span class="line">print_csm(a,, <span class="number">2</span>);    <span class="comment">//check a[0:2]</span></span><br><span class="line">print_csm();         <span class="comment">//编译错误，a无缺省值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//显示指定参数名，若low &gt; high or a.size()，for循环不执行 </span></span><br><span class="line">print_csm(a, <span class="variable">.c</span>(<span class="number">3</span>)); <span class="comment">//check a[3:size()-1]</span></span><br></pre></td></tr></table></figure>
<h2 id="子程序的返回">子程序的返回</h2>
<h3 id="显式返回">显式返回</h3>
<ul>
<li><code>void</code>函数无返回值，非<code>void</code>函数必须提供返回值
<ul>
<li><code>return</code>关键词适用于单个返回值的函数</li>
<li>多返回值需用<code>output</code>或结构体</li>
</ul>
</li>
<li>在任何函数中，<code>return</code>语句都可用于发现错误提前终止退出
<ul>
<li>SV支持<code>return</code>关键词灵活退出，而Verilog仅能在<code>endfunciton</code>处返回</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示返回</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">int</span> add(<span class="keyword">int</span> a, <span class="keyword">int</span> b);</span><br><span class="line">  <span class="keyword">return</span> a + b; <span class="comment">// 必须显式返回</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"><span class="comment">//提前退出</span></span><br><span class="line"><span class="keyword">function</span> <span class="keyword">void</span> check(<span class="keyword">int</span> a);</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="number">0</span>) <span class="keyword">return</span>; <span class="comment">// 提前退出</span></span><br><span class="line">  <span class="built_in">$display</span>(<span class="string">&quot;Valid value&quot;</span>);</span><br><span class="line"><span class="keyword">endfunction</span></span><br></pre></td></tr></table></figure>
<h3 id="隐式返回">隐式返回</h3>
<ul>
<li>当函数名被赋值时，函数名即返回变量，无需显示<code>return</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> array_t [<span class="number">5</span>];  <span class="comment">//自定义数组类型</span></span><br><span class="line">array_t at;</span><br><span class="line"><span class="keyword">function</span> array_t init(<span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (init[i])</span><br><span class="line">        init[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    at = init(<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (at[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;at[%0d] = %0d&quot;</span>, i ,at[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="数组的返回">数组的返回</h3>
<ul>
<li>上述数组或结构体的返回除上面的例子外，还可以用引用参数实现</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="keyword">automatic</span> <span class="keyword">void</span> init (<span class="keyword">ref</span> <span class="keyword">int</span> f[<span class="number">5</span>], <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    <span class="keyword">foreach</span> (f[i])</span><br><span class="line">        f[i] = i + start;</span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> fa[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    init(fa, <span class="number">5</span>);</span><br><span class="line">    <span class="keyword">foreach</span> (fa[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;fa[%0d] = %0d&quot;</span>, i, fa[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>也可以将数组包装到一个<a href="../SV%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1">类</a>中，然后返回对象的句柄</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> ArrayWrapper;</span><br><span class="line">  <span class="keyword">int</span> data[];</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">input</span> <span class="keyword">int</span> size, <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">    data = <span class="keyword">new</span>[size];</span><br><span class="line">    <span class="keyword">foreach</span>(data[i]) data[i] = i + start;</span><br><span class="line">  <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> ArrayWrapper create_wrapped_array(<span class="keyword">input</span> <span class="keyword">int</span> size, <span class="keyword">input</span> <span class="keyword">int</span> start);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span>(size, start);  <span class="comment">// 返回新对象句柄</span></span><br><span class="line"><span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试代码</span></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  ArrayWrapper obj;</span><br><span class="line">  obj = create_wrapped_array(<span class="number">5</span>, <span class="number">3</span>);  <span class="comment">// 初始化数组 [3,4,5,6,7]</span></span><br><span class="line">  <span class="keyword">foreach</span>(obj<span class="variable">.data</span>[i]) </span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;obj.data[%0d] = %0d&quot;</span>, i, obj<span class="variable">.data</span>[i]);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LNotes</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>sv</tag>
      </tags>
  </entry>
  <entry>
    <title>SV随机化控制</title>
    <url>/SV%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<h1 id="控制方法">控制方法</h1>
<h2 id="分布控制">分布控制</h2>
<ul>
<li>系统预定义的回调函数，可以在类中重写，以便在随机化过程的关键节点注入自定义逻辑
<ul>
<li><code>pre_randomize()</code>：在开始执行、求解约束之前自动调用</li>
<li><code>post_randomize()</code>：在成功执行、赋值之后自动调用</li>
<li>如果<code>randmoize()</code>失败，<code>post_randomize</code>不会被调用</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] length;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] payload[];</span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] checksum;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> valid_length &#123;</span><br><span class="line">        length <span class="keyword">inside</span> &#123; [<span class="number">1</span>:<span class="number">10</span>] &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在随机化前，动态调整payload数组的大小</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> pre_randomize();</span><br><span class="line">        payload = <span class="keyword">new</span>[length]; <span class="comment">// 根据length的约束值（但尚未随机化）预留空间</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Pre-randomize: Setting payload size to %0d&quot;</span>, length);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在随机化后，计算payload的校验和</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> post_randomize();</span><br><span class="line">        checksum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">foreach</span> (payload[i]) <span class="keyword">begin</span></span><br><span class="line">            checksum += payload[i];</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Post-randomize: Checksum calculated as 0x%h&quot;</span>, checksum);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="禁用函数">禁用函数</h2>
<h3 id="禁用变量">禁用变量</h3>
<ul>
<li>禁用变量：<code>rand_mode()</code>，临时关闭某个变量的随机化，使其在<code>randomize()</code>调用过程中保持当前值不变
<ul>
<li><code>rand_mode(0)</code>：关闭指定变量的随机化</li>
<li><code>rand_mode(1)</code>：开启指定变量的随机化</li>
<li><code>rand_mode()</code>：返回变量的当前随机化状态</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Register;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] value;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> test;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Register r = <span class="keyword">new</span>;</span><br><span class="line">r<span class="variable">.value</span><span class="variable">.rand_mode</span>(<span class="number">0</span>);    <span class="comment">// 关闭value的随机化</span></span><br><span class="line">r<span class="variable">.value</span> = <span class="number">4&#x27;b1010</span>; <span class="comment">// 手动赋值</span></span><br><span class="line">r<span class="variable">.randomize</span>();     <span class="comment">// 调用randomize()后，value的值将保持为4‘b1010不变</span></span><br></pre></td></tr></table></figure>
<h3 id="禁用约束">禁用约束</h3>
<ul>
<li>禁用约束：<code>constraint_mode()</code>，每个约束块都能被单独开启或关闭
<ul>
<li><code>constraint_mode(0)</code>：禁用指定的约束</li>
<li><code>constraint_mode(1)</code>：启用指定的约束</li>
<li><code>constraint_mode()</code>：返回当前约束的启用状态</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Bus;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> addr;</span><br><span class="line">    <span class="keyword">constraint</span> slow_addr &#123; addr <span class="keyword">inside</span> &#123; [<span class="number">0</span>:<span class="number">100</span>] &#125;; &#125;</span><br><span class="line">    <span class="keyword">constraint</span> fast_addr &#123; addr <span class="keyword">inside</span> &#123; [<span class="number">1000</span>:<span class="number">2000</span>] &#125;; &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Bus b = <span class="keyword">new</span>;</span><br><span class="line">b<span class="variable">.fast_addr</span><span class="variable">.constraint_mode</span>(<span class="number">0</span>); <span class="comment">// 禁用fast_addr约束</span></span><br><span class="line">b<span class="variable">.randomize</span>();                  <span class="comment">// addr 将在 0-100 内随机</span></span><br><span class="line">b<span class="variable">.slow_addr</span><span class="variable">.constraint_mode</span>(<span class="number">0</span>); <span class="comment">// 也禁用slow_addr约束</span></span><br><span class="line">b<span class="variable">.fast_addr</span><span class="variable">.constraint_mode</span>(<span class="number">1</span>); <span class="comment">// 启用fast_addr约束</span></span><br><span class="line">b<span class="variable">.randomize</span>();                  <span class="comment">// addr 将在 1000-2000 内随机</span></span><br></pre></td></tr></table></figure>
<h2 id="过程化随机">过程化随机</h2>
<h3 id="随机选择">随机选择</h3>
<ul>
<li><code>randcase</code>
<ul>
<li>是一个过程化的加权随机选择语句，根据指定权重从多个分支中随机选择一条来执行</li>
<li>不像概率约束中<a href="../SV%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%BA%A6%E6%9D%9F/#%E6%9D%83%E9%87%8D%E5%88%86%E5%B8%83">权重分布</a>用于随机化数据值，而是用于随机化控制流</li>
</ul>
</li>
<li>下例为使用<code>randcase</code>和<a href="#%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0">随机化函数</a><code>$urandom_range</code>的随机控制</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">bit</span> [<span class="number">15</span>:<span class="number">0</span>] len;</span><br><span class="line">    <span class="keyword">randcase</span></span><br><span class="line">        <span class="number">1</span>: len = $urandom_range(<span class="number">0</span>,<span class="number">2</span>); <span class="comment">// 10%: 0, 1, 2</span></span><br><span class="line">        <span class="number">8</span>: len = $urandom_range(<span class="number">3</span>,<span class="number">5</span>); <span class="comment">// 80%</span></span><br><span class="line">        <span class="number">1</span>: len = $urandom_range(<span class="number">6</span>,<span class="number">7</span>); <span class="comment">// 10%</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;len = %0d&quot;</span>, len);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="随机序列">随机序列</h3>
<ul>
<li>
<p><code>randsequence</code></p>
<ul>
<li>是一个过程化的随机序列生成语句，可以在执行过程中逐步调试</li>
<li>不像迭代约束中的<a href="../SV%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%BA%A6%E6%9D%9F/#%E9%9A%8F%E6%9C%BA%E5%BA%8F%E5%88%97">随机序列</a>只能通过调用<code>randomize()</code>得到随机化结果而无法知道执行过程</li>
</ul>
</li>
<li>
<p>两种过程化随机语句的比较</p>
<ul>
<li><code>randsequence</code>也能像<code>randcase</code>一样实现加权选择，但从代码可读性、编译速度等方面都逊于<code>randcase</code></li>
<li>反过来看，<code>randsequence</code>生成复杂、有序、多层次的序列是<code>randcase</code>无法做到的</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> do_something();</span><br><span class="line">    <span class="keyword">randcase</span></span><br><span class="line">        <span class="number">70</span> : generate_normal();    <span class="comment">// 70% 概率</span></span><br><span class="line">        <span class="number">20</span> : generate_corner();    <span class="comment">// 20% 概率</span></span><br><span class="line">        <span class="number">10</span> : generate_error();     <span class="comment">// 10% 概率</span></span><br><span class="line">    <span class="keyword">endcase</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> do_something();               <span class="comment">// 用 randsequence 模拟 randcase 的功能</span></span><br><span class="line">    <span class="keyword">randsequence</span> ( action )        <span class="comment">// 主产生式命名为 &#x27;action&#x27;</span></span><br><span class="line">        action : weight(<span class="number">70</span>) : &#123; generate_normal(); &#125;  |</span><br><span class="line">                  weight(<span class="number">20</span>) : &#123; generate_corner(); &#125;  |</span><br><span class="line">                  weight(<span class="number">10</span>) : &#123; generate_error(); &#125;   ;</span><br><span class="line">    <span class="keyword">endsequence</span></span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">randsequence</span> ( test_flow )          <span class="comment">// 只能用 randsequence 实现的复杂序列</span></span><br><span class="line">    test_flow   : setup ( read_operation | write_operation )+ check ; <span class="comment">// 序列结构，反映顺序</span></span><br><span class="line">    setup       : &#123; configure_dut(); &#125; ;</span><br><span class="line">    read_operation  : single_read | burst_read ; <span class="comment">// 子选择</span></span><br><span class="line">        single_read : &#123; do_single_read(); &#125; ;</span><br><span class="line">        burst_read  : &#123; do_burst_read(); &#125; ;</span><br><span class="line">    write_operation : &#123; do_write(); &#125; ;</span><br><span class="line">    check       : &#123; check_results(); &#125; ;</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>
<ul>
<li><code>randsequence</code>语法</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">randsequence</span> ( main ) <span class="comment">// 从&#x27;main&#x27;产生式开始</span></span><br><span class="line">  <span class="comment">// 主序列：配置，然后执行一些操作，最后检查</span></span><br><span class="line">  main : setup ( read_op | write_op )+ check &#123; <span class="built_in">$display</span>(<span class="string">&quot;Done&quot;</span>); &#125; ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 配置产生式</span></span><br><span class="line">  setup : &#123; <span class="built_in">$display</span>(<span class="string">&quot;Setup Phase&quot;</span>); &#125; </span><br><span class="line">          &#123; configure(); &#125; ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 带权重的读操作</span></span><br><span class="line">  read_op : weight(<span class="number">2</span>) : &#123; single_read(); &#125; | </span><br><span class="line">            weight(<span class="number">1</span>) : &#123; burst_read(); &#125; ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 写操作（可选的调试）</span></span><br><span class="line">  write_op : &#123; single_write(); &#125; </span><br><span class="line">             ( &#123; <span class="built_in">$display</span>(<span class="string">&quot;Debug&quot;</span>); &#125; )? ; <span class="comment">// 可选调试信息</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查产生式</span></span><br><span class="line">  check : &#123; verify(); &#125; ;</span><br><span class="line"><span class="keyword">endsequence</span></span><br></pre></td></tr></table></figure>
<ul>
<li>下例为使用<code>randsequence</code>进行递归操作的命令发生器
<ul>
<li>定义了一个名为<code>stream</code>的随机序列，其产生式定义了三种操作的权重分布</li>
<li>各操作的产生式都包含了两个选项，不指定权重时默认各占50%概率
<ul>
<li><code>cfg_read</code>操作的第一个选项为执行一次<code>cfg_read_task()</code>后结束</li>
<li>第二个选项为执行一次任务后，递归调用自身<code>cfg_read</code></li>
<li>因此<code>cfg_read</code>操作至少会执行一次<code>cfg_read_task()</code>，其余两个操作同理</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">15</span>; i++) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">randsequence</span> (stream)</span><br><span class="line">      stream: cfg_read = <span class="number">1</span> |                            <span class="comment">// 外部权重</span></span><br><span class="line">              io_read = <span class="number">2</span> |</span><br><span class="line">              mem_read = <span class="number">5</span>;                             <span class="comment">// steam的产生式</span></span><br><span class="line">      cfg_read: &#123; cfg_read_task(); &#125; |                  <span class="comment">// cfg_read的产生式</span></span><br><span class="line">                  &#123; cfg_read_task(); &#125; cfg_read;          <span class="comment">// 权重为50%，递归执行</span></span><br><span class="line">      io_read: weight(<span class="number">3</span>) : &#123; io_read_task(); &#125; |        <span class="comment">// 内部权重，权重为3</span></span><br><span class="line">                 weight(<span class="number">1</span>) : &#123; io_read_task(); &#125; io_read; <span class="comment">// 权重为1，但递归执行</span></span><br><span class="line">      mem_read: &#123; mem_read_task(); &#125; ;                  <span class="comment">// 该操作只执行一次任务</span></span><br><span class="line">    <span class="keyword">endsequence</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> cfg_read_task();</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endtask</span></span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h1 id="种子与函数">种子与函数</h1>
<h2 id="随机化种子">随机化种子</h2>
<ul>
<li>随机化算法是伪随机的，由一个初始的种子值驱动，相同的种子会产生完全相同的随机数序列</li>
<li><code>srandom(seed)</code>方法
<ul>
<li>为一个特定的对象实例设置随机数生成器的种子</li>
<li>每次运行仿真，该对象产生的随机序列都将完全一致，便于复现失败的测试用例</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Generator;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Generator g = <span class="keyword">new</span>;</span><br><span class="line">    g<span class="variable">.srandom</span>(<span class="number">100</span>); <span class="comment">// 将实例g的种子设置为100</span></span><br><span class="line">    g<span class="variable">.randomize</span>();  <span class="comment">// 每次仿真，只要种子是100，随机序列都相同</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>仿真参数控制
<ul>
<li>VCS允许通过命令行参数指定全局种子：<code>+ntb_random_seed=12345</code></li>
<li>如果不手动指定种子，仿真器通常会使用系统时间作为默认种子，每次运行都会得到不同结果（类似手动指定<code>+ntb_random_seed=$$(date +%N)</code>的效果）</li>
</ul>
</li>
</ul>
<h2 id="随机化函数">随机化函数</h2>
<ul>
<li>对于SV随机化，除了使用<a href="../SV%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%BA%A6%E6%9D%9F/#CRT%E6%9C%BA%E5%88%B6">CRT机制</a>创建对象和定义约束，也可以直接调用仿真器内置的系统函数快速生成随机数，或在CRT中调用<code>dist_*</code>系列函数完成复杂随机化的建模</li>
</ul>
<h3 id="标准函数">标准函数</h3>
<ul>
<li><code>random()</code>：返回一个32位有符号的随机整数</li>
<li><code>urandom()</code>：返回一个32位符号的随机整数</li>
<li><code>urandom_range(max,min)</code>：返回一个指定范围内的无符号整数
<ul>
<li>参数<code>min</code>的缺省值为<code>0</code></li>
<li>如果<code>max</code>比<code>min</code>小，参数列表会自动反向</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> signed_var;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] unsigned_var;</span><br><span class="line"><span class="keyword">int</span> int_val;</span><br><span class="line"></span><br><span class="line">signed_var = <span class="built_in">$random</span>;           <span class="comment">// 产生一个-2^18到2^18-1之间的随机整数，如 123456, -7854332</span></span><br><span class="line">unsigned_var = $urandom;        <span class="comment">// 产生一个0到2^32-1之间的随机整数，如 3489572349</span></span><br><span class="line">int_val  = $urandom_range(<span class="number">100</span>); <span class="comment">// 生成一个 0 到 100 之间的数</span></span><br></pre></td></tr></table></figure>
<h3 id="分布函数">分布函数</h3>
<ul>
<li><code>$dist_*</code>系列概率分布函数，使用局部种子生成具有特定统计特性的随机序列
<ul>
<li>用于模拟真实世界的噪声、延迟、故障间隔等场景</li>
<li>都需要种子<code>seed</code>作为参数，控制随机序列</li>
</ul>
</li>
<li>由于SV CRT的<a href="../SV%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%BA%A6%E6%9D%9F/#%E7%BA%A6%E6%9D%9F%E5%9D%97">约束块</a>是声明式的，而随机化函数是一个过程化调用，故不能直接在约束块中使用随机化函数
<ul>
<li>可以在约束块中使用<a href="../SV%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%BA%A6%E6%9D%9F/#%E6%A6%82%E7%8E%87%E7%BA%A6%E6%9D%9F">概率约束</a>中的<code>dist</code>关键词来近似模拟</li>
<li>或者在<a href="#%E5%88%86%E5%B8%83%E6%8E%A7%E5%88%B6">回调函数</a> <code>post_randomize()</code>中调用<code>dist_*</code>系列函数进行后处理</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// ==== 回调函数后处理 ==== //</span></span><br><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> delay; <span class="comment">// 用于驱动的延迟值</span></span><br><span class="line">    <span class="keyword">int</span> delay_seed; <span class="comment">// 专门用于delay分布的种子</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 约束可以为空，或定义其他无关的约束</span></span><br><span class="line">    <span class="keyword">constraint</span> c_delay_basic &#123;</span><br><span class="line">        delay <span class="keyword">inside</span> &#123; [<span class="number">0</span>:<span class="number">1000</span>] &#125;; <span class="comment">// 可以提供一个基本的范围约束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在随机化后处理函数中生成分布</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> post_randomize();</span><br><span class="line">        <span class="keyword">real</span> real_delay;</span><br><span class="line">        real_delay = <span class="built_in">$dist_exponential</span>(delay_seed, <span class="number">50</span><span class="variable">.0</span>); <span class="comment">// 生成均值为50的指数分布实数</span></span><br><span class="line">        delay = <span class="keyword">int</span>&#x27;(real_delay); <span class="comment">// 将实数转换为整数，赋值给delay</span></span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在new函数中初始化种子</span></span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>(<span class="keyword">int</span> seed);</span><br><span class="line">        delay_seed = seed;</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    Packet pkt = <span class="keyword">new</span>(<span class="number">123</span>); <span class="comment">// 初始化种子</span></span><br><span class="line">    pkt<span class="variable">.randomize</span>();       <span class="comment">// 此时，pkt.delay 的值将是一个符合指数分布的整数</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="均匀分布">均匀分布</h3>
<ul>
<li><code>dist_uniform(seed, start, end)</code>：以实数形式返回一个区间内的随机整数
<ul>
<li><code>start</code>：范围起始整数</li>
<li><code>end</code>：范围结束整数</li>
</ul>
</li>
</ul>
<img src="/images/image-20250827111723159.png" alt="image-20250827111723159" style="zoom: 50%;" />
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟掷骰子</span></span><br><span class="line"><span class="keyword">int</span> seed = <span class="number">123</span>; <span class="comment">// 初始化种子</span></span><br><span class="line"><span class="keyword">int</span> dice_roll;</span><br><span class="line">dice_roll = <span class="built_in">$dist_uniform</span>(seed, <span class="number">1</span>, <span class="number">6</span>); <span class="comment">// 生成 1, 2, 3, 4, 5, 6 中的一个</span></span><br></pre></td></tr></table></figure>
<h3 id="正态分布">正态分布</h3>
<ul>
<li><code>dist_normal(seed, mean, std_dev)</code>：经典“钟形分布”；返回一个符合正态分布的随机实数
<ul>
<li><code>mean</code>：分布均值（期望值）</li>
<li><code>std_dev</code>：分布标准差（大于0）</li>
</ul>
</li>
</ul>
<img src="/images/image-20250827111742532.png" alt="image-20250827111742532" style="zoom:50%;" />
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟一个期望值为 100ns，标准差为 15ns 的延迟</span></span><br><span class="line"><span class="keyword">int</span> seed = <span class="number">456</span>;</span><br><span class="line"><span class="keyword">real</span> delay;</span><br><span class="line">delay = <span class="built_in">$dist_normal</span>(seed, <span class="number">100</span><span class="variable">.0</span>, <span class="number">15</span><span class="variable">.0</span>); <span class="comment">// 大部分delay值在85-115ns之间</span></span><br></pre></td></tr></table></figure>
<h3 id="泊松分布">泊松分布</h3>
<ul>
<li><code>dist_poisson(seed, mean)</code>：描述某个时间或空间范围内，某事件发生$X$次的概率；以实数形式返回一个非负的随机整数
<ul>
<li><code>mean</code>：期望，等于标准差</li>
</ul>
</li>
</ul>
<img src="/images/image-20250827113840916.png" alt="image-20250827113840916" style="zoom:50%;" />
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟一个小时内平均发生 3 次错误</span></span><br><span class="line"><span class="keyword">real</span> error_count_real;</span><br><span class="line"><span class="keyword">int</span> error_count;</span><br><span class="line"><span class="keyword">int</span> seed = <span class="number">321</span>;</span><br><span class="line">error_count_real = <span class="built_in">$dist_poisson</span>(seed, <span class="number">3</span><span class="variable">.0</span>);</span><br><span class="line">error_count = <span class="keyword">int</span>&#x27;(error_count_real); <span class="comment">// 转换为整型，如0, 1, 2, 3, ...</span></span><br></pre></td></tr></table></figure>
<h3 id="指数分布">指数分布</h3>
<ul>
<li><code>dist_exponential(seed, mean)</code>：描述泊松过程（即事件以恒定的平均速率连续且独立地发生的过程）中随机事件发生的时间间隔；返回一个非负的随机实数
<ul>
<li><code>mean</code>：单位时间内，事件发生的次数</li>
</ul>
</li>
</ul>
<img src="/images/image-20250827113857767.png" alt="image-20250827113857767" style="zoom:50%;" />
<ul>
<li>模拟平均每秒到达 5 个数据包的流量</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> seed = <span class="number">789</span>;</span><br><span class="line"><span class="keyword">real</span> inter_arrival_time;</span><br><span class="line">inter_arrival_time = <span class="built_in">$dist_exponential</span>(seed, <span class="number">1</span><span class="variable">.0</span>/<span class="number">5</span><span class="variable">.0</span>); <span class="comment">// 平均间隔为0.2秒</span></span><br></pre></td></tr></table></figure>
<h3 id="卡方分布">卡方分布</h3>
<ul>
<li><code>dist_chi_square(seed, degree_of_freedom)</code>：$n$个服从标准正态分布的随机变量的平方和，构成新的随机变量的分布规律；返回一个非负的随机实数
<ul>
<li><code>degree_of_freedom</code>：自由度$n$，自由度越大，分布曲线越扁平，越接近正态分布</li>
</ul>
</li>
</ul>
<img src="/images/image-20250827161346569.png" alt="image-20250827161346569" style="zoom: 67%;" />
<ul>
<li>在验证中较少用于生成激励，更多用在测试平台分析组件或记分板进行统计检验
<ul>
<li>下例是用卡方分布函数比较期望频数与实际观测频数之间的差异，如果根据这个统计量计算出的概率非常小，说明在原假设成立的前提下，观察到</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 假设检验一个随机数生成器（0-9）</span></span><br><span class="line"><span class="keyword">int</span> observed[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> seed = <span class="number">123</span>;</span><br><span class="line"><span class="keyword">real</span> chi_square_statistic = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">real</span> expected_count;</span><br><span class="line"><span class="keyword">real</span> p_value_threshold = <span class="number">0</span><span class="variable">.05</span>; <span class="comment">// 显著性水平5%</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成大量随机数并统计，只考虑其中任意一个值如5时，只有是5与不是5两种情况，而根据中心极限定理，二项分布可以用正态分布近似，故后续可以统计这10个值的卡方分布</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) <span class="keyword">begin</span></span><br><span class="line">    <span class="keyword">int</span> val = $urandom_range(<span class="number">9</span>, <span class="number">0</span>);</span><br><span class="line">    observed[val]++;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算观测频数的卡方分布，卡方公式：Σ[(观测值 - 期望值)^2 / 期望值]</span></span><br><span class="line">expected_count = <span class="number">10000</span><span class="variable">.0</span> / <span class="number">10</span><span class="variable">.0</span>; <span class="comment">// 每个数字期望出现1000次</span></span><br><span class="line"><span class="keyword">foreach</span> (observed[i]) <span class="keyword">begin</span></span><br><span class="line">    chi_square_statistic += (observed[i] - expected_count) ** <span class="number">2</span> / expected_count;</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用dist函数获取临界值，自由度为9，因为总频数已知，知道其中9个值得频率，剩下的那个频数也就清楚了</span></span><br><span class="line"><span class="keyword">real</span> critical_value = <span class="built_in">$dist_chi_square</span>(seed, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 极度简化的判断逻辑，实际检验更复杂，用于检验这个随机假设是否符合要求</span></span><br><span class="line"><span class="keyword">if</span> (chi_square_statistic &gt; critical_value) <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;WARNING: RNG may be biased! Chi-Square = %f&quot;</span>, chi_square_statistic);</span><br><span class="line"><span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">begin</span></span><br><span class="line">    <span class="built_in">$display</span>(<span class="string">&quot;RNG looks uniform. Chi-Square = %f&quot;</span>, chi_square_statistic);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h3 id="T分布">T分布</h3>
<ul>
<li><code>dist_t(seed, degree_of_freedom)</code>：模拟出现极端值概率更高的随机现象；返回一个随机实数
<ul>
<li><code>degree_of_freedom</code>：自由度</li>
</ul>
</li>
</ul>
<img src="/images/image-20250901141101463.png" alt="image-20250901141101463" style="zoom:67%;" />
<ul>
<li>常用于对小样本或高方差过程进行建模，或模拟具有高不确定性的测量过程
<ul>
<li>下例为模拟不稳定的传感器读数，<code>$dist_t</code> 生成的误差值出现 -4、+5 等极端值的概率，远高于 <code>$dist_normal</code>；这使得测试可以更容易地捕获到设计在处理异常输入时的潜在问题</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">module</span> sensor_model;</span><br><span class="line">    <span class="keyword">real</span> nominal_voltage = <span class="number">3</span><span class="variable">.3</span>; <span class="comment">// 标称电压</span></span><br><span class="line">    <span class="keyword">real</span> measured_voltage;</span><br><span class="line">    <span class="keyword">int</span> t_seed = <span class="number">200</span>; <span class="comment">// t分布专用种子</span></span><br><span class="line">    <span class="keyword">real</span> error_scale = <span class="number">0</span><span class="variable">.1</span>; <span class="comment">// 误差的缩放因子</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">task</span> read_voltage();</span><br><span class="line">        <span class="keyword">real</span> t_error;</span><br><span class="line">        <span class="comment">// 生成一个服从t分布（df=5）的随机误差</span></span><br><span class="line">        t_error = <span class="built_in">$dist_t</span>(t_seed, <span class="number">5</span>);</span><br><span class="line">        <span class="comment">// 将误差缩放后加到标称值上，得到测量值</span></span><br><span class="line">        measured_voltage = nominal_voltage + (t_error * error_scale);</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;Measured Voltage: %f (Error: %f)&quot;</span>, measured_voltage, t_error);</span><br><span class="line">    <span class="keyword">endtask</span></span><br><span class="line"><span class="keyword">endmodule</span></span><br></pre></td></tr></table></figure>
<h3 id="埃尔朗分布">埃尔朗分布</h3>
<ul>
<li><code>dist_erlang(seed, k, mean)</code>：指数分布的广义形式，描述的是$k$次独立事件所需的总时间；返回一个非负的随机实数
<ul>
<li><code>k</code>：形状参数（阶数，整数）</li>
<li><code>mean</code>：分布的平均值</li>
</ul>
</li>
</ul>
<img src="/images/image-20250901141636517.png" alt="image-20250901141636517" style="zoom:67%;" />
<ul>
<li>常用在通信和排队论中模拟总服务时间或总等待时间
<ul>
<li>下例为模拟网络数据包的多级跳转传输延迟：假设一个数据包要依次经过 3 个网络节点（路由器）才能到达目的地；每个节点的处理延迟是随机的，且平均延迟为 1 个时间单位</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> NetworkPacket;</span><br><span class="line">    <span class="keyword">real</span> total_delay; <span class="comment">// 总延迟</span></span><br><span class="line">    <span class="keyword">int</span> erlang_seed = <span class="number">300</span>; <span class="comment">// 埃尔朗分布专用种子</span></span><br><span class="line">    <span class="keyword">constraint</span> delay_range &#123;</span><br><span class="line">        <span class="comment">// 总延迟的基本约束</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">void</span> post_randomize();</span><br><span class="line">        <span class="comment">// 生成总延迟：通过3个节点，平均总延迟为3.0个单位时间</span></span><br><span class="line">        total_delay = <span class="built_in">$dist_erlang</span>(erlang_seed, <span class="number">3</span>, <span class="number">3</span><span class="variable">.0</span>);</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LNotes</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>sv</tag>
      </tags>
  </entry>
  <entry>
    <title>Typora技巧</title>
    <url>/Typora%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="Typora技巧">Typora技巧</h1>
<h2 id="编辑">编辑</h2>
<ul>
<li>撤销：<code>ctrl</code>+<code>z</code></li>
<li>取消撤销：<code>ctrl</code>+<code>y</code></li>
<li>跳转至光标位置：<code>ctrl</code>+<code>j</code></li>
<li>跳转至顶部：<code>ctrl</code>+<code>home</code></li>
<li>跳转至底部：<code>ctrl</code>+<code>end</code></li>
<li>替代：<code>ctrl</code>+<code>h</code></li>
<li>查找下一个：<code>enter</code></li>
<li>查找上一个：<code>shift</code>+<code>enter</code></li>
<li>选择词：<code>ctrl</code>+<code>d</code></li>
<li>删除词：<code>ctrl</code>+<code>shift</code>+<code>d</code></li>
<li>选择行(表格中)/句子(句号或回车)：<code>ctrl</code>+<code>l</code></li>
<li>删除行(表格中)：<code>ctrl</code>+<code>shift</code>+<code>backspace</code></li>
<li>选择表格中单元格/段落中同格式：<code>ctrl</code>+<code>e</code></li>
</ul>
<h2 id="格式">格式</h2>
<ul>
<li><strong>加粗</strong>：快捷键<code>ctrl</code>+<code>b</code><br>
源代码：<code>**strong**</code></li>
<li><em>斜体</em>：快捷键<code>ctrl</code>+<code>i</code><br>
源代码：<code>*emphasis*</code></li>
<li><u>下划线</u>：快捷键<code>ctrl</code>+<code>u</code></li>
<li><s>删除线</s>：快捷键<code>alt</code>+<code>shift</code>+<code>5</code></li>
<li><code>代码</code>：快捷键<code>ctrl</code>+<code>shift</code>+<code>反单引号</code><br>
源代码：<code>反单引号 code 反单引号</code></li>
</ul>
<blockquote>
<p>以上格式均支持先快捷键后输入文本，及先输入文件后快捷键</p>
</blockquote>
<h2 id="标题">标题</h2>
<ul>
<li>设置标题：<code>ctrl</code>+<code>1~6</code><br>
源代码：<code>#</code>+<code>Space</code>+Heading</li>
<li>标题升级：<code>ctrl</code>+<code>=</code></li>
<li>标题降级：<code>ctrl</code>+<code>-</code></li>
<li>取消标题：<code>ctrl</code>+<code>0</code></li>
</ul>
<h2 id="段落">段落</h2>
<ul>
<li>新段落：<code>enter</code></li>
<li>同段落新行：<code>shift</code>+<code>enter</code></li>
<li>缩进：<code>ctrl</code>+<code>[</code> 或 <code>tab</code></li>
<li>减少缩进：<code>ctrl</code>+<code>]</code> 或 <code>shift</code>+ <code>tab</code></li>
</ul>
<h2 id="列表">列表</h2>
<h3 id="无序列表">无序列表</h3>
<ul>
<li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>]</code><br>
源代码：<code>*</code>/<code>+</code>/<code>-</code>+<code>Space </code>+ Paragraph</li>
<li>设置子列表等同缩进<br>
取消子列表等同取消缩进</li>
</ul>
<blockquote>
<p>无序列表示例：</p>
<ul>
<li>段落1 (Enter)</li>
<li>段落2行1 (Shift+Enter)<br>
段落2行2</li>
<li>段落3
<ul>
<li>子列表段落1</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="有序列表">有序列表</h3>
<ul>
<li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>[</code><br>
源代码：<code>1.</code> +<code>Space </code>+ Paragraph</li>
</ul>
<blockquote>
<p>有序列表示例：</p>
<ol>
<li>有序段落1
<ol>
<li>有序段落1.1
<ol>
<li>有序段落1.1.1</li>
</ol>
</li>
</ol>
</li>
</ol>
</blockquote>
<h3 id="任务列表">任务列表</h3>
<ul>
<li>任务列表：<code>ctrl</code>+<code>shift</code>+<code>x</code></li>
</ul>
<blockquote>
<p>任务列表示例：</p>
<ul class="contains-task-list">
<li class="task-list-item"><input class="task-list-item-checkbox" checked="" disabled="" type="checkbox"> 任务1</li>
<li class="task-list-item"><input class="task-list-item-checkbox" disabled="" type="checkbox"> 任务2</li>
</ul>
</blockquote>
<h2 id="功能">功能</h2>
<h3 id="区块">区块</h3>
<ul>
<li>段落引用：<code>ctrl</code>+<code>shift</code>+<code>Q</code><br>
源代码：<code>&gt;</code>+<code>Space</code></li>
<li>取消引用等同取消缩进</li>
</ul>
<blockquote>
<p>引用区块示例，用于进一步解释段落中的内容</p>
</blockquote>
<h3 id="链接">链接</h3>
<ul>
<li>将链接复制入剪切板后：<code>ctrl</code>+<code>k</code><br>
源代码：<code>[titile](url)</code> or <code>[titile](#handing)</code></li>
</ul>
<blockquote>
<p>示例：<br>
网页跳转：<a href="https://support.typora.io/Shortcut-Keys/#change-shortcut-keys">Typora快捷键</a><br>
文内跳转：标题-<a href="#%E7%BC%96%E8%BE%91">编译</a><br>
本地文件跳转同理</p>
</blockquote>
<ul>
<li>此外，提供另一种显示链接的方法，便于集中管理所有链接：
<ul>
<li>源代码：<code>[titile][]</code></li>
<li>UI界面：段落-&gt;链接引用，再补全<code>[titile]:link url &quot;optional&quot;</code></li>
</ul>
</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/he_nan/article/details/105850141" title="网页名称可选">链接测试</a></p>
</blockquote>
<h3 id="脚注">脚注</h3>
<ul>
<li>脚标源代码：<code>[^1]</code></li>
<li>脚注代码：<code>[^1]:脚注</code><br>
脚注UI：段落-&gt;脚注</li>
</ul>
<blockquote>
<p>示例：<br>
使用脚注对于正文扩展进行说明<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup><br>
在Typora的编辑中，可将脚标与脚注放在一起<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup></p>
</blockquote>
<ul>
<li>自定义快捷键
<ul>
<li>打开文件-偏好设置-通用-高级设置</li>
<li>配置conf.user.json文件，配置以下快捷键</li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="attr">&quot;keyBinding&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;Footnotes&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Ctrl+Shift+P&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br></pre></td></tr></table></figure>
<h3 id="代码">代码</h3>
<ul>
<li>段落内代码<br>
快捷键：<code>ctrl</code>+<code>shift</code>+<code>反单引号</code><br>
源代码：<code>反单引号 code 反单引号</code></li>
<li>代码块<br>
快捷键：<code>ctrl</code>+<code>shift</code>+<code>k</code><br>
源代码：<code>三反单引号 code block 三反单引号</code></li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pyperclip</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> io</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image, ImageGrab</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">image_to_base64</span>(<span class="params">image</span>):</span><br><span class="line">    buffered = io.BytesIO()</span><br><span class="line">    image.save(buffered, <span class="built_in">format</span>=<span class="string">&quot;PNG&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> base64.b64encode(buffered.getvalue()).decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">main</span>():</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        image = ImageGrab.grabclipboard()</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(image, Image.Image):</span><br><span class="line">            base64_image = image_to_base64(image)</span><br><span class="line">            pyperclip.copy(<span class="string">f&quot;![image](data:image/png;base64,<span class="subst">&#123;base64_image&#125;</span>)\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;图像已转换为Base64并复制&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        </span><br><span class="line">        raw_path = pyperclip.paste().strip(<span class="string">&#x27;&quot;&#x27;</span>)</span><br><span class="line">        file_path = os.path.normpath(raw_path)</span><br><span class="line">        <span class="keyword">if</span> os.path.isfile(file_path):</span><br><span class="line">            <span class="keyword">with</span> Image.<span class="built_in">open</span>(file_path) <span class="keyword">as</span> img:</span><br><span class="line">                base64_image = image_to_base64(img)</span><br><span class="line">            pyperclip.copy(<span class="string">f&quot;![image](data:image/png;base64,<span class="subst">&#123;base64_image&#125;</span>)\n&quot;</span>)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;文件图像已转换为Base64并复制&quot;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;剪切板无有效图像或文件&quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;错误: <span class="subst">&#123;e&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>
<h3 id="公式">公式</h3>
<ul>
<li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>m</code><br>
源代码：<code>$$math bock$$</code></li>
</ul>
<p>公式示例-薛定谔方程（一维定态）<br>
$$<br>
-\frac{\hbar<sup>2}{2m}\frac{d</sup>2\psi(x)}{dx^2} + V(x)\psi(x) = E\psi(x)<br>
$$</p>
<h3 id="图片">图片</h3>
<ul>
<li>快捷键：<code>ctrl</code>+<code>shift</code>+<code>i</code>或复制后直接<code>ctrl</code>+<code>v</code><br>
源代码：<code>![titile](url/localpath)</code></li>
</ul>
<img src="/images/image-20250709141106758.png" alt="image-20250709141106758" style="zoom: 33%;" />
<ul>
<li>设置本地图片副本存储位置</li>
<li>使用PicGo图床上传，在Gitee保存图片副本<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>
<ul>
<li>安装<a href="https://nodejs.org/en/">Node.js</a></li>
<li>注册<a href="https://gitee.com/">Gitee</a></li>
<li>新建开源Gitee<a href="https://gitee.com/arvinhwo/typoraimage">仓库</a></li>
<li>生成Gitee<a href="D:%5CDocument%5CPassword.txt">私人令牌</a></li>
<li>在Typora中下载<a href="C:%5CUsers%5Carvin%5CAppData%5CRoaming%5CTypora%5Cpicgo">PicGo-Core</a></li>
<li>打开配置文件</li>
<li>验证图片上传选项</li>
</ul>
</li>
<li>点击格式-图像-上传所有本地图片批量上传</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;picBed&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;uploader&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee&quot;</span><span class="punctuation">,</span> </span><br><span class="line">    <span class="attr">&quot;gitee&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;repo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;仓库地址（不带gitee的域名）&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;token&quot;</span><span class="punctuation">:</span> <span class="string">&quot;gitee 私人令牌 必填&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;path&quot;</span><span class="punctuation">:</span> <span class="string">&quot;自定义存储路径，可以不填&quot;</span><span class="punctuation">,</span> </span><br><span class="line">      <span class="attr">&quot;customUrl&quot;</span><span class="punctuation">:</span> <span class="string">&quot;域名，没有可以不填&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;branch&quot;</span><span class="punctuation">:</span> <span class="string">&quot;分支名，默认是 master&quot;</span> </span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgoPlugins&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-gitee-uploader&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;picgo-plugin-super-prefix&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;fileFormat&quot;</span><span class="punctuation">:</span> <span class="string">&quot;YYYYMMDDHHmmss&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span> </span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<img src="/images/image-20250709142115308.png" alt="image-20250709142115308" style="zoom:50%;" />
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>脚注可用于解释英文缩略词等 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p>脚注在导出HTML中会按顺序在文末 <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn3" class="footnote-item"><p><a href="https://juejin.cn/post/7089308017266524197">PicGo-Gitee参考教程</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
      <categories>
        <category>How-To</category>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>md</tag>
      </tags>
  </entry>
  <entry>
    <title>SV随机化约束</title>
    <url>/SV%E9%9A%8F%E6%9C%BA%E5%8C%96%E7%BA%A6%E6%9D%9F/</url>
    <content><![CDATA[<h1 id="CRT机制">CRT机制</h1>
<ul>
<li>在复杂数字电路中，完全依赖定向测试（手动编写特定测试用例）难以覆盖所有边界情况和异常场景</li>
<li>受约束的随机测试（Constrained Random Testing，CRT）是产生复杂设计所需激励的唯一可行的方法</li>
</ul>
<h2 id="关键词">关键词</h2>
<ul>
<li><code>rand</code>：声明普通随机变量，随机化范围内的取值概率是等同的，可能重复</li>
<li><code>randc</code>：声明循环随机变量，所有可能值都被取过之前不重复</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr;      <span class="comment">// 随机8位地址</span></span><br><span class="line">    <span class="keyword">randc</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] <span class="keyword">priority</span>; <span class="comment">// 循环随机优先级（0、1、2、3不重复出现）</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="约束块">约束块</h2>
<ul>
<li>通过<code>constraint</code>块限制随机值的范围，可以使用特定的<a href="#%E7%BA%A6%E6%9D%9F%E6%96%B9%E6%B3%95">约束方法</a>生成特定的随机序列</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constraint</span> addr_range &#123;</span><br><span class="line">    addr <span class="keyword">inside</span> &#123;[<span class="number">0</span>:<span class="number">100</span>]&#125;; <span class="comment">// 限制addr在0到100之间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="随机化方法">随机化方法</h2>
<ul>
<li>调用<code>randmozie()</code>方法为随机变量选取满足所有约束条件的新值
<ul>
<li>若随机化成功，则返回<code>1</code>，否则返回<code>0</code></li>
<li>当调用<code>randomize()</code>函数时只传递变量的一个子集，则只会随机化子集中的变量</li>
<li><code>randmozie()</code>是类的方法，需要通过对象调用，不能直接作为独立函数使用</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> packet;</span><br><span class="line">    <span class="keyword">randc</span> <span class="keyword">bit</span> [<span class="number">31</span>:<span class="number">0</span>] addr;    <span class="comment">// 随机化地址</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>]  data;     <span class="comment">// 随机化数据</span></span><br><span class="line">    <span class="keyword">int</span> test;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> valid_addr &#123;   <span class="comment">// 约束：地址在0x1000~0xFFFF范围内</span></span><br><span class="line">        addr <span class="keyword">inside</span> &#123;[<span class="number">32&#x27;h1000</span>:<span class="number">32&#x27;hFFFF</span>]&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> non_zero_data &#123; </span><br><span class="line">        data != <span class="number">0</span>;             <span class="comment">// 约束：数据非零</span></span><br><span class="line">    &#125; </span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">packet pkt0,pkt1;</span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    pkt0 = <span class="keyword">new</span>();</span><br><span class="line">    pkt1 = <span class="keyword">new</span>();</span><br><span class="line">    </span><br><span class="line">    pkt0<span class="variable">.randomize</span>();           <span class="comment">// 随机化addr, data</span></span><br><span class="line">    pkt0<span class="variable">.randomize</span>(addr);       <span class="comment">// 随机化addr，不随机化data</span></span><br><span class="line">    pkt0<span class="variable">.randomize</span>(test);       <span class="comment">// 随机化test，即使不是随机变量</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!pkt1<span class="variable">.randomize</span>())      <span class="comment">// 成功返回1</span></span><br><span class="line">        <span class="built_in">$finish</span>;</span><br><span class="line">    transmit(pkt1);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h1 id="约束方法">约束方法</h1>
<h2 id="唯一值约束">唯一值约束</h2>
<ul>
<li>唯一值约束来确保一组变量在随机化时被赋予互不相同的值</li>
<li><code>unique</code>操作符：约束块内使用<code>unique { }</code>包裹变量集合；也可以对数组使用，确保数组中所有元素的值都是唯一的</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] src_id, dst_id, seq_num; <span class="comment">// 三个4位随机变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> c_unique_ids &#123;</span><br><span class="line">        <span class="keyword">unique</span> &#123; src_id, dst_id &#125;; <span class="comment">// 保证 src_id 和 dst_id 的值不同</span></span><br><span class="line">    &#125;   <span class="comment">// seq_num 的值可以与它们相同，也可以不同，不受此约束影响</span></span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h2 id="范围约束">范围约束</h2>
<ul>
<li>范围约束用于限制随机变量的取值范围，确保随机化值落在指定的区间集合内
<ul>
<li>也可以把集合里的值保存到数组中，再进行范围约束</li>
</ul>
</li>
<li><code>inside</code>操作符指定范围，<code>!inside</code>指定排除范围</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data1, data2, data3;</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] vals = &#x27;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c_range &#123;</span><br><span class="line">    data1 <span class="keyword">inside</span> &#123; [<span class="number">0</span>:<span class="number">100</span>], <span class="number">200</span>, <span class="number">201</span>, <span class="number">255</span> &#125;; <span class="comment">// 约束 data 在 0 到 100 之间，或者是 200, 201, 255</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c_exclude &#123;</span><br><span class="line">    data2 !<span class="keyword">inside</span> &#123; [<span class="number">10</span>:<span class="number">20</span>] &#125;; <span class="comment">// data 的值不能在 10 到 20 之间</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c_fibonacci &#123;</span><br><span class="line">    data3 <span class="keyword">inside</span> vals;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>关系操作符<code>&gt;</code>，<code>&lt;</code>，<code>&gt;=</code>，<code>&lt;=</code>，<code>==</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data；</span><br><span class="line"><span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] vals = &#x27;&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">8</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c_relation &#123;</span><br><span class="line">    value &gt;= <span class="number">50</span>;</span><br><span class="line">    value &lt;  <span class="number">1000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c_fibonacci &#123;    <span class="comment">// 等价于上例中的c_fibonacci约束块</span></span><br><span class="line">    (data == vals[<span class="number">0</span>]) ||   <span class="comment">// data==1</span></span><br><span class="line">    (data == vals[<span class="number">1</span>]) ||   <span class="comment">// data==2</span></span><br><span class="line">    (data == vals[<span class="number">2</span>]) ||   <span class="comment">// data==3</span></span><br><span class="line">    (data == vals[<span class="number">3</span>]) ||   <span class="comment">// data==5</span></span><br><span class="line">    (data == vals[<span class="number">4</span>]) ||   <span class="comment">// data==8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="条件约束">条件约束</h2>
<h3 id="条件语句">条件语句</h3>
<ul>
<li><code>if-else</code>结构</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">bit</span> mode;</span><br><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> addr;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c_cond_if &#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == <span class="number">0</span>) <span class="comment">// 如果 mode 为 0</span></span><br><span class="line">        addr <span class="keyword">inside</span> &#123; [<span class="number">0</span> : <span class="number">127</span>] &#125;;    <span class="comment">// 地址在 0-127</span></span><br><span class="line">    <span class="keyword">else</span>           <span class="comment">// 否则 (mode 为 1)</span></span><br><span class="line">        addr <span class="keyword">inside</span> &#123; [<span class="number">128</span> : <span class="number">255</span>] &#125;;  <span class="comment">// 地址在 128-255</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="蕴含操作">蕴含操作</h3>
<ul>
<li>蕴含操作符<code>-&gt;</code>，逻辑上描述为“如果…，那么…”，可用于替代<code>if-else</code></li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constraint</span> c_cond_imply &#123;</span><br><span class="line">    (mode == <span class="number">0</span>) -&gt; (addr <span class="keyword">inside</span> &#123; [<span class="number">0</span> : <span class="number">127</span>] &#125;);</span><br><span class="line">    (mode == <span class="number">1</span>) -&gt; (addr <span class="keyword">inside</span> &#123; [<span class="number">128</span> : <span class="number">255</span>] &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>蕴含操作<code>A -&gt; B</code>逻辑等价于<code>!A || B</code>，其逆否命题<code>!B-&gt;!A</code>有相同的逻辑表达式和真值表</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">A</th>
<th style="text-align:center">B</th>
<th style="text-align:center">A→B，!B-&gt;!A</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">真</td>
<td style="text-align:center">真</td>
<td style="text-align:center">真</td>
</tr>
<tr>
<td style="text-align:center">真</td>
<td style="text-align:center">假</td>
<td style="text-align:center">假</td>
</tr>
<tr>
<td style="text-align:center">假</td>
<td style="text-align:center">真</td>
<td style="text-align:center">真</td>
</tr>
<tr>
<td style="text-align:center">假</td>
<td style="text-align:center">假</td>
<td style="text-align:center">真</td>
</tr>
</tbody>
</table>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constraint</span> c_cond_imply_contra &#123;                  <span class="comment">// c_cond_imply的等价约束</span></span><br><span class="line">    (addr !<span class="keyword">inside</span> &#123; [<span class="number">0</span> : <span class="number">127</span>] &#125;) -&gt; (mode == <span class="number">1</span>);  <span class="comment">// 对于bit mode, (mode != 0)就是(mode == 1)</span></span><br><span class="line">    (addr !<span class="keyword">inside</span> &#123; [<span class="number">128</span> : <span class="number">255</span>] &#125;) -&gt; (mode == <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上两个蕴含操作的例子都定义了以下行为
<ul>
<li><code>addr</code>必须落在$[0,255]$之间，否则随机化失败</li>
<li>当<code>mode</code>为0时，<code>addr</code>随机约束在$[0,127]$之间</li>
<li>当<code>mode</code>为1时，<code>addr</code>随机约束在$[128,255]$之间</li>
</ul>
</li>
</ul>
<h2 id="概率约束">概率约束</h2>
<h3 id="引导顺序">引导顺序</h3>
<ul>
<li>使用<code>solve...before</code>引导约束求解器的求解顺序，<strong>间接</strong>影响随机结果的概率分布，适用于存在约束关系的变量</li>
<li>下例为不引导顺序的蕴含操作，<code>a</code>随机化概率并不均匀</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Example;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> a;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> c &#123; a -&gt; b == <span class="number">0</span>; &#125; <span class="comment">// 若a为0，此约束不起作用；若a为1，则b必须为0</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 概率分布</span></span><br><span class="line">P(a == <span class="number">0</span>) = <span class="number">80</span>%</span><br><span class="line">    P(b == <span class="number">0</span> | a=<span class="number">0</span>) = <span class="number">25</span>%</span><br><span class="line">    P(b == <span class="number">1</span> | a=<span class="number">0</span>) = <span class="number">25</span>%</span><br><span class="line">    P(b == <span class="number">2</span> | a=<span class="number">0</span>) = <span class="number">25</span>%</span><br><span class="line">    P(b == <span class="number">3</span> | a=<span class="number">0</span>) = <span class="number">25</span>%</span><br><span class="line">P(a == <span class="number">1</span>) = <span class="number">20</span>%</span><br><span class="line">    P(b == <span class="number">0</span> | a=<span class="number">1</span>) = <span class="number">100</span>% (唯一选择)</span><br><span class="line">    P(b == <span class="number">1</span> | a=<span class="number">1</span>) = <span class="number">0</span>%</span><br><span class="line">    P(b == <span class="number">2</span> | a=<span class="number">1</span>) = <span class="number">0</span>%</span><br><span class="line">    P(b == <span class="number">3</span> | a=<span class="number">1</span>) = <span class="number">0</span>%</span><br></pre></td></tr></table></figure>
<ul>
<li>此时若希望<code>a</code>的随机化概率均匀分布，就可以使用<code>solve...before</code>来引导求解顺序，间接影响概率分布
<ul>
<li>告诉约束求解器，先随机化<code>a</code>在随机化<code>b</code></li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Example;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> a;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">1</span>:<span class="number">0</span>] b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> c &#123; a -&gt; b == <span class="number">0</span>; &#125; <span class="comment">// 定义解空间</span></span><br><span class="line">    <span class="keyword">constraint</span> prob_guide &#123; <span class="keyword">solve</span> a <span class="keyword">before</span> b; &#125; <span class="comment">// 引导概率分布</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 概率分布</span></span><br><span class="line">P(a == <span class="number">0</span>) = <span class="number">50</span>%</span><br><span class="line">    P(b == <span class="number">0</span> | a=<span class="number">0</span>) = <span class="number">25</span>%</span><br><span class="line">    P(b == <span class="number">1</span> | a=<span class="number">0</span>) = <span class="number">25</span>%</span><br><span class="line">    P(b == <span class="number">2</span> | a=<span class="number">0</span>) = <span class="number">25</span>%</span><br><span class="line">    P(b == <span class="number">3</span> | a=<span class="number">0</span>) = <span class="number">25</span>%</span><br><span class="line">P(a == <span class="number">1</span>) = <span class="number">50</span>%</span><br><span class="line">    P(b == <span class="number">0</span> | a=<span class="number">1</span>) = <span class="number">100</span>% (唯一选择)</span><br><span class="line">    P(b == <span class="number">1</span> | a=<span class="number">1</span>) = <span class="number">0</span>%</span><br><span class="line">    P(b == <span class="number">2</span> | a=<span class="number">1</span>) = <span class="number">0</span>%</span><br><span class="line">    P(b == <span class="number">3</span> | a=<span class="number">1</span>) = <span class="number">0</span>%</span><br></pre></td></tr></table></figure>
<ul>
<li>上述两例的解空间及概率分布如下</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">a</th>
<th style="text-align:center">b</th>
<th style="text-align:center">是否合法</th>
<th style="text-align:center">不引导顺序概率</th>
<th style="text-align:center">引导顺序概率</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
<td style="text-align:center">是</td>
<td style="text-align:center">1/5</td>
<td style="text-align:center">1/8</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">1</td>
<td style="text-align:center">是</td>
<td style="text-align:center">1/5</td>
<td style="text-align:center">1/8</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">2</td>
<td style="text-align:center">是</td>
<td style="text-align:center">1/5</td>
<td style="text-align:center">1/8</td>
</tr>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">3</td>
<td style="text-align:center">是</td>
<td style="text-align:center">1/5</td>
<td style="text-align:center">1/8</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">0</td>
<td style="text-align:center">是</td>
<td style="text-align:center">1/5</td>
<td style="text-align:center">1/2</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">1</td>
<td style="text-align:center">否</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">否</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">3</td>
<td style="text-align:center">否</td>
<td style="text-align:center">0</td>
<td style="text-align:center">0</td>
</tr>
</tbody>
</table>
<h3 id="权重分布">权重分布</h3>
<ul>
<li>使用<code>dist</code>操作符<strong>直接</strong>定义随机结果的概率权重，适用于独立变量</li>
<li><code>:=</code>操作符：指定单个值的权限，所有权重值是绝对的</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> opcode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c_dist &#123;</span><br><span class="line">    opcode <span class="keyword">dist</span> &#123;</span><br><span class="line">        <span class="number">0</span> := <span class="number">5</span>, <span class="comment">// opcode=0 的概率是 5/(5+3+2) = 50%</span></span><br><span class="line">        <span class="number">1</span> := <span class="number">3</span>, <span class="comment">// opcode=1 的概率是 3/(5+3+2) = 30%</span></span><br><span class="line">        <span class="number">2</span> := <span class="number">2</span>  <span class="comment">// opcode=2 的概率是 2/(5+3+2) = 20%</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>:/</code>操作符：指定一个值范围的权重，该权重会平均分配给范围内的每一个值</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">rand</span> <span class="keyword">int</span> delay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constraint</span> c_dist_range &#123;</span><br><span class="line">    delay <span class="keyword">dist</span> &#123;</span><br><span class="line">        [<span class="number">0</span>:<span class="number">2</span>]  :/ <span class="number">6</span>, <span class="comment">// 权重6平均分给0,1,2三个值，每个值权重为2，P(delay=0/1/2) = 2/10 = 20%</span></span><br><span class="line">        <span class="number">10</span>     :/ <span class="number">4</span>  <span class="comment">// 值10的权重为4，P(delay=10)= 4/10 = 40%</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="软约束">软约束</h2>
<ul>
<li>所有约束默认都是硬约束；使用<code>soft</code>关键词声明的软约束在冲突时可被忽略</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">soft</span> <span class="keyword">constraint</span> c_default_len &#123; length <span class="keyword">inside</span> &#123; [<span class="number">32</span>:<span class="number">64</span>] &#125;; &#125; <span class="comment">// 软约束</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction t = <span class="keyword">new</span>;</span><br><span class="line">t<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123; length == <span class="number">128</span>; &#125;; <span class="comment">// 由于外部约束是硬的，c_default_len软约束会被违反，最终 length=128</span></span><br></pre></td></tr></table></figure>
<h2 id="内嵌约束">内嵌约束</h2>
<ul>
<li>在调用<code>randomize()</code>的同时，使用<code>with</code>关键词临时、局部地添加额外的约束</li>
</ul>
<h3 id="用法">用法</h3>
<ul>
<li>可以用来进一步限制变量的取值范围</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> length;</span><br><span class="line">    <span class="keyword">constraint</span> c_len &#123; length <span class="keyword">inside</span> &#123;[<span class="number">64</span>:<span class="number">1518</span>]&#125;; &#125; <span class="comment">// 通用约束：正常包长</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span></span><br><span class="line">Packet pkt = <span class="keyword">new</span>;</span><br><span class="line">pkt<span class="variable">.randomize</span>();  <span class="comment">// 通用随机化，生成64-1518的包</span></span><br><span class="line">pkt<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123; length <span class="keyword">inside</span> &#123;[<span class="number">64</span>:<span class="number">128</span>]&#125;; &#125;; <span class="comment">// 使用内嵌约束，临时覆盖c_len，只生成小包</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以用来临时定义类中变量中的关系</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] addr;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] data;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Transaction tr = <span class="keyword">new</span>;</span><br><span class="line">tr<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123; data == (addr &lt;&lt; <span class="number">1</span>); &#125;; <span class="comment">// 临时约束：让data的值总是addr的两倍（一个在类定义中不存在的规则）</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以用来引用所在作用域的局部变量</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">task</span> test_case(<span class="keyword">int</span> desired_addr);</span><br><span class="line">    Packet pkt = <span class="keyword">new</span>;</span><br><span class="line">    pkt<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123; addr == desired_addr; &#125;; <span class="comment">// 使用任务传入的参数desired_addr作为约束条件</span></span><br><span class="line">    <span class="comment">// ... 其他测试逻辑</span></span><br><span class="line"><span class="keyword">endtask</span></span><br></pre></td></tr></table></figure>
<h3 id="优先级">优先级</h3>
<ul>
<li>内嵌约束的优先级高于类内部定义的约束
<ul>
<li>当内嵌约束与对象内部的约束发生冲突时，约束求解器会优先满足内嵌约束</li>
<li>如果无法同时满足内嵌约束和内部约束，<code>randomize()</code>方法会失败并返回<code>0</code>
<ul>
<li>可以通过在内部使用<a href="#%E8%BD%AF%E7%BA%A6%E6%9D%9F">软约束</a>，使冲突可被忽略</li>
<li>或者通过<a href="../SV%E9%9A%8F%E6%9C%BA%E5%8C%96%E6%8E%A7%E5%88%B6/#%E7%A6%81%E7%94%A8%E7%BA%A6%E6%9D%9F">禁用函数</a><code>constraint_mode(0)</code>禁止冲突的约束</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Simple;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">constraint</span> c_x &#123; x &gt; <span class="number">10</span>; &#125; <span class="comment">// 内部约束：x必须大于10</span></span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line">Simple s = <span class="keyword">new</span>;</span><br><span class="line"><span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">status = s<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123; x &lt; <span class="number">20</span>; &#125;; <span class="comment">// 内嵌约束与内部约束不冲突，结果：10 &lt; x &lt; 20，成功 (status=1)</span></span><br><span class="line"></span><br><span class="line">status = s<span class="variable">.randomize</span>() <span class="keyword">with</span> &#123; x &lt; <span class="number">5</span>; &#125;;   <span class="comment">// 内嵌约束与内部约束冲突，冲突：无法同时满足 x&gt;10 和 x&lt;5，随机化失败 (status=0)</span></span><br></pre></td></tr></table></figure>
<h2 id="外部约束">外部约束</h2>
<ul>
<li>函数的函数体能在类的外部定义，同样约束的约束体也可以在类的外部定义
<ul>
<li>和类的<a href="../SV%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1/#%E5%8E%9F%E5%9E%8B%E6%96%B9%E6%B3%95">原型方法</a>一样，外部约束必须事先在原来的类里定义外部约束的原型</li>
<li>这种方法只能增加约束，不能改变已有的约束；相比于临时性的内嵌约束，具有更好的可复用性</li>
</ul>
</li>
<li>先定义一个只有空约束的类，后续在不同的测试里定义这个约束的不同版本以产生不同的激励</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="comment">// packet.sv</span></span><br><span class="line"><span class="keyword">class</span> Packet;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] length;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">7</span>:<span class="number">0</span>] payload[];</span><br><span class="line">    <span class="keyword">constraint</span> c_external;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// test.sv</span></span><br><span class="line"><span class="keyword">program</span> <span class="keyword">automatic</span> test;</span><br><span class="line">    <span class="meta">`<span class="keyword">include</span> &quot;packet.sv&quot;</span></span><br><span class="line">    <span class="keyword">constraint</span> Packet::c_external &#123;length == <span class="number">1</span>;&#125;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">endprogram</span></span><br></pre></td></tr></table></figure>
<h2 id="迭代约束">迭代约束</h2>
<h3 id="随机数组">随机数组</h3>
<ul>
<li>使用<code>foreach</code>用于约束随机数组的每一个元素</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> RandArray;</span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">byte</span> payload[]; <span class="comment">// 动态随机数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> c_array_size &#123;</span><br><span class="line">        payload<span class="variable">.size</span>() <span class="keyword">inside</span> &#123; [<span class="number">1</span>:MAX_SIZE] &#125;; <span class="comment">// 约束数组大小</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constraint</span> c_array_vals &#123;</span><br><span class="line">        <span class="keyword">foreach</span> (payload[i]) &#123;</span><br><span class="line">            payload[i] <span class="keyword">inside</span> &#123; [<span class="number">8&#x27;h00</span>:<span class="number">8&#x27;h7F</span>] &#125;; <span class="comment">// 约束每个元素的值</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                payload[i] &gt; payload[i-<span class="number">1</span>]; <span class="comment">// 约束元素值递增</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">            </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        payload = <span class="keyword">new</span>[MAX_SIZE]; <span class="comment">//按最大的容量分配</span></span><br><span class="line">    <span class="keyword">endfunction</span>;</span><br><span class="line"><span class="keyword">endclass</span></span><br></pre></td></tr></table></figure>
<h3 id="随机序列">随机序列</h3>
<ul>
<li>如果想为一个复杂的、多层次的协议生成激励，需要建立一个随机对象数组（随机序列）</li>
</ul>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> Transaction; <span class="comment">//简单事务</span></span><br><span class="line">    <span class="keyword">rand</span> <span class="keyword">bit</span> [<span class="number">3</span>:<span class="number">0</span>] src,dst;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Transaction_seq;</span><br><span class="line">    <span class="keyword">rand</span> Transaction items[<span class="number">10</span>]; <span class="comment">//事务句柄数组</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">function</span> <span class="keyword">new</span>();</span><br><span class="line">        <span class="keyword">foreach</span> (items[i])</span><br><span class="line">            items[i] = <span class="keyword">new</span>();</span><br><span class="line">    <span class="keyword">endfunction</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">constraint</span> c_ascent &#123; <span class="comment">// 每个dst地址都比前一个大</span></span><br><span class="line">        <span class="keyword">foreach</span> (items[i])</span><br><span class="line">            <span class="keyword">if</span> (i&gt;<span class="number">0</span>) items[i]<span class="variable">.dst</span> &gt; items[i-<span class="number">1</span>]<span class="variable">.dst</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">endclass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">initial</span> <span class="keyword">begin</span></span><br><span class="line">    seq = <span class="keyword">new</span>();</span><br><span class="line">    `SV_RAND_CHECK(seq<span class="variable">.randomize</span>());</span><br><span class="line">    <span class="keyword">foreach</span> (seq<span class="variable">.items</span>[i])</span><br><span class="line">        <span class="built_in">$display</span>(<span class="string">&quot;item[%0d] = %d&quot;</span>, i, seq<span class="variable">.items</span>[i]<span class="variable">.dst</span>);</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>LNotes</category>
        <category>SystemVerilog</category>
      </categories>
      <tags>
        <tag>sv</tag>
      </tags>
  </entry>
</search>
